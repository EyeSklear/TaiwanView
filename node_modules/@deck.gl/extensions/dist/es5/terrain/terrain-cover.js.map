{"version":3,"sources":["../../../src/terrain/terrain-cover.ts"],"names":["TerrainCover","targetLayer","tile","getTile","id","Boolean","getCurrentLayer","viewport","layers","layerNeedsRedraw","sizeChanged","_updateViewport","layersChanged","_updateLayers","needsRedraw","getIntersectingLayers","length","i","map","layer","shouldRedraw","targetBounds","getBounds","targetBoundsCommon","newZoom","Math","ceil","zoom","bounds","oldZoom","renderViewport","newBounds","oldBounds","some","x","fbo","context","gl","props","pickable","pickingFbo","filter","includes","texture","delete","sourceTile","intersect","bbox","parent","b1","b2","west","east","south","north","left","right","top","bottom"],"mappings":"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","sourcesContent":["import {Framebuffer} from '@luma.gl/core';\n\nimport type {Layer, Viewport} from '@deck.gl/core';\n\nimport {createRenderTarget} from './utils';\nimport {joinLayerBounds, makeViewport, getRenderBounds, Bounds} from '../utils/projection-utils';\n\n// TODO - import from loaders when Tileset2D is split out\ntype GeoBoundingBox = {west: number; north: number; east: number; south: number};\ntype NonGeoBoundingBox = {left: number; top: number; right: number; bottom: number};\ntype Tile2DHeader = {\n  bbox: GeoBoundingBox | NonGeoBoundingBox;\n};\n\n/**\n * Manages the lifecycle of the terrain cover (draped textures over a terrain mesh).\n * One terrain cover is created for each unique terrain layer (primitive layer with operation:terrain).\n * It is updated when the terrain source layer's mesh changes or when any of the terrainDrawMode:drape\n * layers requires redraw.\n * During the draw call of a terrain layer, the drape texture is overlaid on top of the layer's own color.\n */\nexport class TerrainCover {\n  isDirty: boolean = true;\n  /** The terrain layer that this instance belongs to */\n  targetLayer: Layer;\n  /** Viewport used to draw into the texture */\n  renderViewport: Viewport | null = null;\n  /** Bounds of the terrain cover texture, in cartesian space */\n  bounds: Bounds | null = null;\n\n  private fbo?: Framebuffer;\n  private pickingFbo?: Framebuffer;\n  private layers: string[] = [];\n  private tile: Tile2DHeader | null;\n  /** Cached version of targetLayer.getBounds() */\n  private targetBounds: [number[], number[]] | null = null;\n  /** targetBounds in cartesian space */\n  private targetBoundsCommon: Bounds | null = null;\n\n  constructor(targetLayer: Layer) {\n    this.targetLayer = targetLayer;\n    this.tile = getTile(targetLayer);\n  }\n\n  get id() {\n    return this.targetLayer.id;\n  }\n\n  /** returns true if the target layer is still in use (i.e. not finalized) */\n  get isActive(): boolean {\n    return Boolean(this.targetLayer.getCurrentLayer());\n  }\n\n  shouldUpdate({\n    targetLayer,\n    viewport,\n    layers,\n    layerNeedsRedraw\n  }: {\n    targetLayer?: Layer;\n    viewport?: Viewport;\n    layers?: Layer[];\n    layerNeedsRedraw?: Record<string, boolean>;\n  }): boolean {\n    if (targetLayer) {\n      this.targetLayer = targetLayer;\n    }\n    const sizeChanged = viewport ? this._updateViewport(viewport) : false;\n\n    let layersChanged = layers ? this._updateLayers(layers) : false;\n\n    if (layerNeedsRedraw) {\n      for (const id of this.layers) {\n        if (layerNeedsRedraw[id]) {\n          layersChanged = true;\n          // console.log('layer needs redraw', id);\n          break;\n        }\n      }\n    }\n\n    return layersChanged || sizeChanged;\n  }\n\n  /** Compare layers with the last version. Only rerender if necessary. */\n  private _updateLayers(layers: Layer[]): boolean {\n    let needsRedraw = false;\n    layers = this.tile ? getIntersectingLayers(this.tile, layers) : layers;\n\n    if (layers.length !== this.layers.length) {\n      needsRedraw = true;\n      // console.log('layers count changed', this.layers.length, '>>', layers.length);\n    } else {\n      for (let i = 0; i < layers.length; i++) {\n        const id = layers[i].id;\n        if (id !== this.layers[i]) {\n          needsRedraw = true;\n          // console.log('layer added/removed', id);\n          break;\n        }\n      }\n    }\n    if (needsRedraw) {\n      this.layers = layers.map(layer => layer.id);\n    }\n    return needsRedraw;\n  }\n\n  /** Compare viewport and terrain bounds with the last version. Only rerender if necesary. */\n  private _updateViewport(viewport: Viewport): boolean {\n    const targetLayer = this.targetLayer;\n    let shouldRedraw = false;\n\n    if (this.targetBounds !== targetLayer.getBounds()) {\n      // console.log('bounds changed', this.bounds, '>>', newBounds);\n      shouldRedraw = true;\n      this.targetBounds = targetLayer.getBounds();\n      this.targetBoundsCommon = joinLayerBounds([targetLayer], viewport);\n    }\n\n    if (!this.targetBoundsCommon) {\n      return false;\n    }\n\n    const newZoom = Math.ceil(viewport.zoom + 0.5);\n    // If the terrain layer is bound to a tile, always render a texture that cover the whole tile.\n    // Otherwise, use the smaller of layer bounds and the viewport bounds.\n    if (this.tile) {\n      this.bounds = this.targetBoundsCommon;\n    } else {\n      const oldZoom = this.renderViewport?.zoom;\n      shouldRedraw = shouldRedraw || newZoom !== oldZoom;\n      const newBounds = getRenderBounds(this.targetBoundsCommon, viewport);\n      const oldBounds = this.bounds;\n      shouldRedraw = shouldRedraw || !oldBounds || newBounds.some((x, i) => x !== oldBounds[i]);\n      this.bounds = newBounds;\n    }\n\n    if (shouldRedraw) {\n      this.renderViewport = makeViewport({\n        bounds: this.bounds,\n        zoom: newZoom,\n        viewport\n      });\n    }\n\n    return shouldRedraw;\n  }\n\n  getRenderFramebuffer(): Framebuffer | null {\n    if (!this.renderViewport || this.layers.length === 0) {\n      return null;\n    }\n    if (!this.fbo) {\n      this.fbo = createRenderTarget(this.targetLayer.context.gl, {id: this.id});\n    }\n    return this.fbo;\n  }\n\n  getPickingFramebuffer(): Framebuffer | null {\n    if (!this.renderViewport || (this.layers.length === 0 && !this.targetLayer.props.pickable)) {\n      return null;\n    }\n    if (!this.pickingFbo) {\n      this.pickingFbo = createRenderTarget(this.targetLayer.context.gl, {id: `${this.id}-picking`});\n    }\n    return this.pickingFbo;\n  }\n\n  filterLayers(layers: Layer[]) {\n    return layers.filter(({id}) => this.layers.includes(id));\n  }\n\n  delete() {\n    const {fbo, pickingFbo} = this;\n    if (fbo) {\n      fbo.texture.delete();\n      fbo.delete();\n    }\n    if (pickingFbo) {\n      pickingFbo.texture.delete();\n      pickingFbo.delete();\n    }\n  }\n}\n\n/**\n * Remove layers that do not overlap with the current terrain cover.\n * This implementation only has effect when a TileLayer is overlaid on top of a TileLayer\n */\nfunction getIntersectingLayers(sourceTile: Tile2DHeader, layers: Layer[]): Layer[] {\n  return layers.filter(layer => {\n    const tile = getTile(layer);\n    if (tile) {\n      return intersect(sourceTile.bbox, tile.bbox);\n    }\n    return true;\n  });\n}\n\n/** If layer is the descendent of a TileLayer, return the corresponding tile. */\nfunction getTile(layer: Layer): Tile2DHeader | null {\n  while (layer) {\n    // @ts-expect-error tile may not exist\n    const {tile} = layer.props;\n    if (tile) {\n      return tile;\n    }\n    layer = layer.parent as Layer;\n  }\n  return null;\n}\n\nfunction intersect(\n  b1: GeoBoundingBox | NonGeoBoundingBox,\n  b2: GeoBoundingBox | NonGeoBoundingBox\n): boolean {\n  if ('west' in b1 && 'west' in b2) {\n    return b1.west < b2.east && b2.west < b1.east && b1.south < b2.north && b2.south < b1.north;\n  }\n  if ('left' in b1 && 'left' in b2) {\n    return b1.left < b2.right && b2.left < b1.right && b1.top < b2.bottom && b2.top < b1.bottom;\n  }\n  return false;\n}\n"],"file":"terrain-cover.js"}