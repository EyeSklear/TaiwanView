declare type PropType<T> = PropConstructor<T> | PropConstructor<T>[];
declare type PropConstructor<T = any> = {
    new (...args: any[]): T & {};
} | {
    (): T;
} | PropMethod<T>;
declare type PropMethod<T, TConstructor = any> = [T] extends [
    ((...args: any) => any) | undefined
] ? {
    new (): TConstructor;
    (): T;
    readonly prototype: TConstructor;
} : never;
/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
export declare function makeMap(str: string, expectsLowerCase?: boolean): (key: string) => boolean;
export default function conclude(configSequence: any[], config?: {
    type?: PropType<any>;
    default?: any;
    defaultIsDynamic?: boolean;
    required?: boolean;
    validator?: (prop: any) => boolean;
    camelizeObjectKeys?: boolean;
    mergeObject?: string | false;
    mergeObjectApplyOnlyToDefault?: boolean;
    mergeFunction?: false | ((accumulator: any, currentValue: any, index?: any, array?: any) => Function);
    mergeFunctionApplyOnlyToDefault?: boolean;
}): any;
export {};
