{
  "version": 3,
  "sources": ["../../@math.gl/geospatial/src/constants.ts", "../../@math.gl/geospatial/src/type-utils.ts", "../../@math.gl/geospatial/src/ellipsoid/helpers/scale-to-geodetic-surface.ts", "../../@math.gl/geospatial/src/ellipsoid/helpers/ellipsoid-transform.ts", "../../@math.gl/geospatial/src/ellipsoid/ellipsoid.ts", "../../@loaders.gl/tiles/src/utils/doubly-linked-list-node.ts", "../../@loaders.gl/tiles/src/utils/doubly-linked-list.ts", "../../@loaders.gl/tiles/src/tileset/tileset-cache.ts", "../../@loaders.gl/tiles/src/tileset/helpers/transform-utils.ts", "../../@math.gl/culling/src/constants.ts", "../../@math.gl/culling/src/lib/bounding-volumes/axis-aligned-bounding-box.ts", "../../@math.gl/culling/src/lib/bounding-volumes/bounding-sphere.ts", "../../@math.gl/culling/src/lib/bounding-volumes/oriented-bounding-box.ts", "../../@math.gl/culling/src/lib/plane.ts", "../../@math.gl/culling/src/lib/culling-volume.ts", "../../@math.gl/culling/src/lib/perspective-off-center-frustum.ts", "../../@math.gl/culling/src/lib/algorithms/bounding-sphere-from-points.ts", "../../@math.gl/culling/src/lib/algorithms/compute-eigen-decomposition.ts", "../../@math.gl/culling/src/lib/algorithms/bounding-box-from-points.ts", "../../@loaders.gl/tiles/src/tileset/helpers/frame-state.ts", "../../@loaders.gl/tiles/src/tileset/helpers/zoom.ts", "../../@loaders.gl/tiles/src/constants.ts", "../../@loaders.gl/tiles/src/tileset/helpers/bounding-volume.ts", "../../@loaders.gl/tiles/src/tileset/helpers/tiles-3d-lod.ts", "../../@loaders.gl/tiles/src/tileset/helpers/i3s-lod.ts", "../../@loaders.gl/tiles/src/tileset/helpers/3d-tiles-options.ts", "../../@loaders.gl/tiles/src/utils/managed-array.ts", "../../@loaders.gl/tiles/src/tileset/tileset-traverser.ts", "../../@loaders.gl/tiles/src/tileset/tile-3d.ts", "../../@loaders.gl/tiles/src/tileset/format-3d-tiles/tileset-3d-traverser.ts", "../../@loaders.gl/tiles/src/tileset/format-i3s/i3s-pending-tiles-register.ts", "../../@loaders.gl/tiles/src/tileset/format-i3s/i3s-tile-manager.ts", "../../@loaders.gl/tiles/src/tileset/format-i3s/i3s-tileset-traverser.ts", "../../@loaders.gl/tiles/src/tileset/tileset-3d.ts", "../../@loaders.gl/3d-tiles/src/lib/utils/version.ts", "../../@loaders.gl/3d-tiles/src/lib/constants.ts", "../../@loaders.gl/3d-tiles/src/lib/parsers/helpers/parse-utils.ts", "../../@loaders.gl/draco/src/lib/utils/version.ts", "../../@loaders.gl/draco/src/draco-loader.ts", "../../@loaders.gl/schema/src/lib/batches/base-table-batch-aggregator.ts", "../../@loaders.gl/schema/src/lib/utils/row-utils.ts", "../../@loaders.gl/schema/src/lib/batches/row-table-batch-aggregator.ts", "../../@loaders.gl/schema/src/lib/batches/columnar-table-batch-aggregator.ts", "../../@loaders.gl/schema/src/lib/batches/table-batch-builder.ts", "../../@loaders.gl/schema/src/category/mesh/mesh-utils.ts", "../../@loaders.gl/schema/src/lib/utils/assert.ts", "../../@loaders.gl/schema/src/lib/schema/impl/schema.ts", "../../@loaders.gl/schema/src/lib/schema/impl/field.ts", "../../@loaders.gl/schema/src/lib/schema/impl/enum.ts", "../../@loaders.gl/schema/src/lib/schema/impl/type.ts", "../../@loaders.gl/schema/src/lib/arrow/arrow-like-type-utils.ts", "../../@loaders.gl/schema/src/category/mesh/deduce-mesh-schema.ts", "../../@loaders.gl/schema/src/lib/utils/async-queue.ts", "../../@loaders.gl/draco/src/lib/utils/get-draco-schema.ts", "../../@loaders.gl/draco/src/lib/draco-parser.ts", "../../@loaders.gl/draco/src/lib/draco-module-loader.ts", "../../@loaders.gl/draco/src/index.ts", "../../@loaders.gl/math/src/geometry/constants.ts", "../../@loaders.gl/math/src/geometry/gl/gl-type.ts", "../../@loaders.gl/math/src/geometry/utils/assert.ts", "../../@loaders.gl/math/src/geometry/colors/rgb565.ts", "../../@loaders.gl/math/src/geometry/compression/attribute-compression.ts", "../../@loaders.gl/3d-tiles/src/lib/classes/tile-3d-feature-table.ts", "../../@loaders.gl/3d-tiles/src/lib/classes/helpers/tile-3d-accessor-utils.ts", "../../@loaders.gl/3d-tiles/src/lib/classes/tile-3d-batch-table-hierarchy.ts", "../../@loaders.gl/3d-tiles/src/lib/classes/tile-3d-batch-table.ts", "../../@loaders.gl/3d-tiles/src/lib/parsers/helpers/parse-3d-tile-header.ts", "../../@loaders.gl/3d-tiles/src/lib/parsers/helpers/parse-3d-tile-tables.ts", "../../@loaders.gl/3d-tiles/src/lib/parsers/helpers/normalize-3d-tile-colors.ts", "../../@loaders.gl/3d-tiles/src/lib/parsers/helpers/normalize-3d-tile-normals.ts", "../../@loaders.gl/3d-tiles/src/lib/parsers/helpers/normalize-3d-tile-positions.ts", "../../@loaders.gl/3d-tiles/src/lib/parsers/parse-3d-tile-point-cloud.ts", "../../@loaders.gl/gltf/src/lib/utils/version.ts", "../../@loaders.gl/textures/src/lib/utils/version.ts", "../../@loaders.gl/textures/src/lib/parsers/basis-module-loader.ts", "../../@loaders.gl/textures/src/lib/gl-extensions.ts", "../../@loaders.gl/textures/src/lib/utils/texture-formats.ts", "../../@loaders.gl/textures/node_modules/ktx-parse/src/constants.ts", "../../@loaders.gl/textures/node_modules/ktx-parse/src/container.ts", "../../@loaders.gl/textures/node_modules/ktx-parse/src/buffer-reader.ts", "../../@loaders.gl/textures/node_modules/ktx-parse/src/util.ts", "../../@loaders.gl/textures/node_modules/ktx-parse/src/read.ts", "../../@loaders.gl/textures/node_modules/ktx-parse/src/write.ts", "../../@loaders.gl/textures/src/lib/utils/extract-mipmap-images.ts", "../../@loaders.gl/textures/src/lib/utils/ktx-format-helper.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-ktx.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-basis.ts", "../../@loaders.gl/textures/src/basis-loader.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-dds.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-pvr.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-compressed-texture.ts", "../../@loaders.gl/textures/src/compressed-texture-loader.ts", "../../@loaders.gl/textures/src/lib/parsers/parse-npy.ts", "../../@loaders.gl/textures/src/npy-loader.ts", "../../@loaders.gl/gltf/src/lib/utils/assert.ts", "../../@loaders.gl/gltf/src/lib/gltf-utils/resolve-url.ts", "../../@loaders.gl/gltf/src/lib/gltf-utils/get-typed-array.ts", "../../@loaders.gl/gltf/src/lib/gltf-utils/gltf-utils.ts", "../../@loaders.gl/gltf/src/lib/api/gltf-scenegraph.ts", "../../@loaders.gl/gltf/src/meshopt/meshopt-decoder.ts", "../../@loaders.gl/gltf/src/lib/extensions/EXT_meshopt_compression.ts", "../../@loaders.gl/gltf/src/lib/extensions/EXT_texture_webp.ts", "../../@loaders.gl/gltf/src/lib/extensions/KHR_texture_basisu.ts", "../../@loaders.gl/gltf/src/lib/gltf-utils/gltf-attribute-utils.ts", "../../@loaders.gl/gltf/src/lib/extensions/KHR_draco_mesh_compression.ts", "../../@loaders.gl/gltf/src/lib/gltf-utils/gltf-constants.ts", "../../@loaders.gl/gltf/src/lib/extensions/KHR_texture_transform.ts", "../../@loaders.gl/gltf/src/lib/extensions/deprecated/KHR_lights_punctual.ts", "../../@loaders.gl/gltf/src/lib/extensions/deprecated/KHR_materials_unlit.ts", "../../@loaders.gl/gltf/src/lib/extensions/deprecated/KHR_techniques_webgl.ts", "../../@loaders.gl/gltf/src/lib/extensions/deprecated/EXT_feature_metadata.ts", "../../@loaders.gl/gltf/src/lib/api/gltf-extensions.ts", "../../@loaders.gl/gltf/src/lib/extensions/KHR_binary_gltf.ts", "../../@loaders.gl/gltf/src/lib/api/normalize-gltf-v1.ts", "../../@loaders.gl/gltf/src/lib/api/post-process-gltf.ts", "../../@loaders.gl/gltf/src/lib/parsers/parse-glb.ts", "../../@loaders.gl/gltf/src/lib/parsers/parse-gltf.ts", "../../@loaders.gl/gltf/src/gltf-loader.ts", "../../@loaders.gl/3d-tiles/src/lib/parsers/helpers/parse-3d-tile-gltf-view.ts", "../../@loaders.gl/3d-tiles/src/lib/parsers/parse-3d-tile-batched-model.ts", "../../@loaders.gl/3d-tiles/src/lib/parsers/parse-3d-tile-instanced-model.ts", "../../@loaders.gl/3d-tiles/src/lib/parsers/parse-3d-tile-composite.ts", "../../@loaders.gl/3d-tiles/src/lib/parsers/parse-3d-tile-gltf.ts", "../../@loaders.gl/3d-tiles/src/lib/parsers/parse-3d-tile.ts", "../../@loaders.gl/3d-tiles/src/lib/parsers/helpers/parse-3d-tile-subtree.ts", "../../@loaders.gl/3d-tiles/src/tile-3d-subtree-loader.ts", "../../@loaders.gl/3d-tiles/src/lib/parsers/helpers/parse-3d-implicit-tiles.ts", "../../@loaders.gl/3d-tiles/src/lib/parsers/parse-3d-tile-header.ts", "../../@loaders.gl/3d-tiles/src/tiles-3d-loader.ts", "../../@loaders.gl/3d-tiles/src/lib/ion/ion.ts", "../../@loaders.gl/3d-tiles/src/cesium-ion-loader.ts", "../../@loaders.gl/3d-tiles/src/lib/encoders/helpers/encode-3d-tile-header.ts", "../../@loaders.gl/3d-tiles/src/lib/encoders/encode-3d-tile-composite.ts", "../../@loaders.gl/3d-tiles/src/lib/encoders/encode-3d-tile-batched-model.ts", "../../@loaders.gl/3d-tiles/src/lib/encoders/encode-3d-tile-instanced-model.ts", "../../@loaders.gl/3d-tiles/src/lib/encoders/encode-3d-tile-point-cloud.ts", "../../@loaders.gl/3d-tiles/src/lib/encoders/encode-3d-tile.ts", "../../@loaders.gl/3d-tiles/src/tile-3d-writer.ts"],
  "sourcesContent": ["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nexport const WGS84_RADIUS_X = 6378137.0;\nexport const WGS84_RADIUS_Y = 6378137.0;\nexport const WGS84_RADIUS_Z = 6356752.3142451793;\n\n// Pre-calculated ellipsoid defaults to avoid utils depending on `ellipsoid.js`\n\nexport const WGS84_CONSTANTS = {\n  radii: [WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z],\n  radiiSquared: [\n    WGS84_RADIUS_X * WGS84_RADIUS_X,\n    WGS84_RADIUS_Y * WGS84_RADIUS_Y,\n    WGS84_RADIUS_Z * WGS84_RADIUS_Z\n  ],\n  oneOverRadii: [1.0 / WGS84_RADIUS_X, 1.0 / WGS84_RADIUS_Y, 1.0 / WGS84_RADIUS_Z],\n  oneOverRadiiSquared: [\n    1.0 / (WGS84_RADIUS_X * WGS84_RADIUS_X),\n    1.0 / (WGS84_RADIUS_Y * WGS84_RADIUS_Y),\n    1.0 / (WGS84_RADIUS_Z * WGS84_RADIUS_Z)\n  ],\n  maximumRadius: Math.max(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z),\n  centerToleranceSquared: 1e-1 // EPSILON1;\n};\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport type {NumericArray} from '@math.gl/core';\nimport {Vector3, toRadians, toDegrees, config} from '@math.gl/core';\nimport {WGS84_CONSTANTS} from './constants';\n\ntype LngLatHeightObject = {\n  longitude: number;\n  latitude: number;\n  height: number;\n};\n\ntype XYZObject = {\n  x: number;\n  y: number;\n  z: number;\n};\n\ntype Cartographic = LngLatHeightObject | XYZObject | NumericArray;\n\nfunction identity(x: number): number {\n  return x;\n}\n\nconst scratchVector = new Vector3();\n\nexport function fromCartographic(cartographic: Cartographic): number[];\nexport function fromCartographic<NumArrayT>(\n  cartographic: Cartographic,\n  result: NumArrayT,\n  map?: (x: number) => number\n): NumArrayT;\nexport function fromCartographic(\n  cartographic: Cartographic,\n  result = [] as number[],\n  map = identity\n): number[] {\n  if ('longitude' in cartographic) {\n    result[0] = map(cartographic.longitude);\n    result[1] = map(cartographic.latitude);\n    result[2] = cartographic.height;\n  } else if ('x' in cartographic) {\n    result[0] = map(cartographic.x);\n    result[1] = map(cartographic.y);\n    result[2] = cartographic.z;\n  } else {\n    result[0] = map(cartographic[0]);\n    result[1] = map(cartographic[1]);\n    result[2] = cartographic[2];\n  }\n  return result;\n}\n\nexport function fromCartographicToRadians(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToRadians<TArray>(\n  cartographic: Cartographic,\n  result: TArray\n): TArray;\nexport function fromCartographicToRadians(\n  cartographic: Cartographic,\n  vector = [] as number[]\n): number[] {\n  return fromCartographic(cartographic, vector, config._cartographicRadians ? identity : toRadians);\n}\n\nexport function fromCartographicToDegrees(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToDegrees<TArray>(\n  cartographic: Cartographic,\n  result: TArray\n): TArray;\nexport function fromCartographicToDegrees(\n  cartographic: Cartographic,\n  vector = [] as number[]\n): number[] {\n  return fromCartographic(cartographic, vector, config._cartographicRadians ? toDegrees : identity);\n}\n\nexport function toCartographic<T extends Cartographic>(\n  vector: Readonly<NumericArray>,\n  cartographic: T,\n  map: (x: number) => number = identity\n): T {\n  if ('longitude' in cartographic) {\n    cartographic.longitude = map(vector[0]);\n    cartographic.latitude = map(vector[1]);\n    cartographic.height = vector[2];\n  } else if ('x' in cartographic) {\n    cartographic.x = map(vector[0]);\n    cartographic.y = map(vector[1]);\n    cartographic.z = vector[2];\n  } else {\n    cartographic[0] = map(vector[0]);\n    cartographic[1] = map(vector[1]);\n    cartographic[2] = vector[2];\n  }\n  return cartographic;\n}\n\nexport function toCartographicFromRadians<T extends Cartographic>(\n  vector: Readonly<NumericArray>,\n  cartographic: T\n): T {\n  return toCartographic(vector, cartographic, config._cartographicRadians ? identity : toDegrees);\n}\n\nexport function toCartographicFromDegrees<T extends Cartographic>(\n  vector: Readonly<NumericArray>,\n  cartographic: T\n): T {\n  return toCartographic(vector, cartographic, config._cartographicRadians ? toRadians : identity);\n}\n\n// Estimates if a vector is close to the surface of the WGS84 Ellipsoid\nexport function isWGS84(vector: Readonly<NumericArray>): boolean {\n  if (!vector) {\n    return false;\n  }\n  scratchVector.from(vector);\n  const {oneOverRadiiSquared, centerToleranceSquared} = WGS84_CONSTANTS;\n  const x2 = vector[0] * vector[0] * oneOverRadiiSquared[0];\n  const y2 = vector[1] * vector[1] * oneOverRadiiSquared[1];\n  const z2 = vector[2] * vector[2] * oneOverRadiiSquared[2];\n  return Math.abs(x2 + y2 + z2 - 1) < centerToleranceSquared;\n}\n\n/*\n\nexport function fromCartographic(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographic(cartographic: Cartographic, result: TypedArray): TypedArray;\nexport function fromCartographicToRadians(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToRadians(\n  cartographic: Cartographic,\n  result: TypedArray\n): TypedArray;\nexport function fromCartographicToDegrees(cartographic: Cartographic, result?: number[]): number[];\nexport function fromCartographicToDegrees(\n  cartographic: Cartographic,\n  result: TypedArray\n): TypedArray;\n\nexport function toCartographic(vector: number[] | TypedArray, result: Cartographic): number[];\nexport function toCartographicFromRadians(\n  vector: number[] | TypedArray,\n  result: Cartographic\n): number[];\nexport function toCartographicFromDegrees(\n  vector: number[] | TypedArray,\n  result: Cartographic\n): number[];\n\n// Estimates if a vector is close to the surface of the WGS84 Ellipsoid\nexport function isWGS84(vector: number[] | TypedArray): boolean;\n*/\n", "/* eslint-disable */\nimport {Vector3, _MathUtils} from '@math.gl/core';\nimport type Ellipsoid from '../ellipsoid';\n\nconst scratchVector = new Vector3();\nconst scaleToGeodeticSurfaceIntersection = new Vector3();\nconst scaleToGeodeticSurfaceGradient = new Vector3();\n\n// Scales the provided Cartesian position along the geodetic surface normal\n// so that it is on the surface of this ellipsoid.  If the position is\n// at the center of the ellipsoid, this function returns undefined.\nexport default function scaleToGeodeticSurface(\n  cartesian: number[],\n  ellipsoid: Ellipsoid,\n  result: number[] = []\n): number[] {\n  const {oneOverRadii, oneOverRadiiSquared, centerToleranceSquared} = ellipsoid;\n\n  scratchVector.from(cartesian);\n\n  const positionX = scratchVector.x;\n  const positionY = scratchVector.y;\n  const positionZ = scratchVector.z;\n\n  const oneOverRadiiX = oneOverRadii.x;\n  const oneOverRadiiY = oneOverRadii.y;\n  const oneOverRadiiZ = oneOverRadii.z;\n\n  const x2 = positionX * positionX * oneOverRadiiX * oneOverRadiiX;\n  const y2 = positionY * positionY * oneOverRadiiY * oneOverRadiiY;\n  const z2 = positionZ * positionZ * oneOverRadiiZ * oneOverRadiiZ;\n\n  // Compute the squared ellipsoid norm.\n  const squaredNorm = x2 + y2 + z2;\n  const ratio = Math.sqrt(1.0 / squaredNorm);\n\n  // When very close to center or at center\n  if (!Number.isFinite(ratio)) {\n    return undefined;\n  }\n\n  // As an initial approximation, assume that the radial intersection is the projection point.\n  const intersection = scaleToGeodeticSurfaceIntersection;\n  intersection.copy(cartesian).scale(ratio);\n\n  // If the position is near the center, the iteration will not converge.\n  if (squaredNorm < centerToleranceSquared) {\n    return intersection.to(result);\n  }\n\n  const oneOverRadiiSquaredX = oneOverRadiiSquared.x;\n  const oneOverRadiiSquaredY = oneOverRadiiSquared.y;\n  const oneOverRadiiSquaredZ = oneOverRadiiSquared.z;\n\n  // Use the gradient at the intersection point in place of the true unit normal.\n  // The difference in magnitude will be absorbed in the multiplier.\n  const gradient = scaleToGeodeticSurfaceGradient;\n  gradient.set(\n    intersection.x * oneOverRadiiSquaredX * 2.0,\n    intersection.y * oneOverRadiiSquaredY * 2.0,\n    intersection.z * oneOverRadiiSquaredZ * 2.0\n  );\n\n  // Compute the initial guess at the normal vector multiplier, lambda.\n  let lambda = ((1.0 - ratio) * scratchVector.len()) / (0.5 * gradient.len());\n  let correction = 0.0;\n\n  let xMultiplier;\n  let yMultiplier;\n  let zMultiplier;\n  let func;\n\n  do {\n    lambda -= correction;\n\n    xMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredX);\n    yMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredY);\n    zMultiplier = 1.0 / (1.0 + lambda * oneOverRadiiSquaredZ);\n\n    const xMultiplier2 = xMultiplier * xMultiplier;\n    const yMultiplier2 = yMultiplier * yMultiplier;\n    const zMultiplier2 = zMultiplier * zMultiplier;\n\n    const xMultiplier3 = xMultiplier2 * xMultiplier;\n    const yMultiplier3 = yMultiplier2 * yMultiplier;\n    const zMultiplier3 = zMultiplier2 * zMultiplier;\n\n    func = x2 * xMultiplier2 + y2 * yMultiplier2 + z2 * zMultiplier2 - 1.0;\n\n    // \"denominator\" here refers to the use of this expression in the velocity and acceleration\n    // computations in the sections to follow.\n    const denominator =\n      x2 * xMultiplier3 * oneOverRadiiSquaredX +\n      y2 * yMultiplier3 * oneOverRadiiSquaredY +\n      z2 * zMultiplier3 * oneOverRadiiSquaredZ;\n\n    const derivative = -2.0 * denominator;\n\n    correction = func / derivative;\n  } while (Math.abs(func) > _MathUtils.EPSILON12);\n\n  return scratchVector.scale([xMultiplier, yMultiplier, zMultiplier]).to(result);\n}\n", "import {Vector3, assert, equals as equalsEpsilon} from '@math.gl/core';\n\nimport type Ellipsoid from '../ellipsoid';\n\nconst EPSILON14 = 1e-14;\n\nconst scratchOrigin = new Vector3();\n\n// Caclulate third axis from given two axii\nconst VECTOR_PRODUCT_LOCAL_FRAME = {\n  up: {\n    south: 'east',\n    north: 'west',\n    west: 'south',\n    east: 'north'\n  },\n  down: {\n    south: 'west',\n    north: 'east',\n    west: 'north',\n    east: 'south'\n  },\n  south: {\n    up: 'west',\n    down: 'east',\n    west: 'down',\n    east: 'up'\n  },\n  north: {\n    up: 'east',\n    down: 'west',\n    west: 'up',\n    east: 'down'\n  },\n  west: {\n    up: 'north',\n    down: 'south',\n    north: 'down',\n    south: 'up'\n  },\n  east: {\n    up: 'south',\n    down: 'north',\n    north: 'up',\n    south: 'down'\n  }\n} as const;\n\nconst degeneratePositionLocalFrame = {\n  north: [-1, 0, 0],\n  east: [0, 1, 0],\n  up: [0, 0, 1],\n  south: [1, 0, 0],\n  west: [0, -1, 0],\n  down: [0, 0, -1]\n} as const;\n\nconst scratchAxisVectors = {\n  east: new Vector3(),\n  north: new Vector3(),\n  up: new Vector3(),\n  west: new Vector3(),\n  south: new Vector3(),\n  down: new Vector3()\n};\n\nconst scratchVector1 = new Vector3();\nconst scratchVector2 = new Vector3();\nconst scratchVector3 = new Vector3();\n\ntype Axis = 'up' | 'down' | 'north' | 'east' | 'south' | 'west';\n\n// Computes a 4x4 transformation matrix from a reference frame\n// centered at the provided origin to the provided ellipsoid's fixed reference frame.\n// eslint-disable-next-line max-statements, max-params, complexity\nexport default function localFrameToFixedFrame(\n  ellipsoid: Ellipsoid,\n  firstAxis: Axis,\n  secondAxis: Axis,\n  thirdAxis: Axis,\n  cartesianOrigin: number[],\n  result: number[]\n): number[] {\n  const thirdAxisInferred =\n    VECTOR_PRODUCT_LOCAL_FRAME[firstAxis] &&\n    (VECTOR_PRODUCT_LOCAL_FRAME[firstAxis][secondAxis] as Axis);\n  // firstAxis and secondAxis must be east, north, up, west, south or down.');\n  assert(thirdAxisInferred && (!thirdAxis || thirdAxis === thirdAxisInferred));\n\n  let firstAxisVector: Vector3;\n  let secondAxisVector: Vector3;\n  let thirdAxisVector: Vector3;\n\n  const origin = scratchOrigin.copy(cartesianOrigin);\n\n  // If x and y are zero, assume origin is at a pole, which is a special case.\n  const atPole = equalsEpsilon(origin.x, 0.0, EPSILON14) && equalsEpsilon(origin.y, 0.0, EPSILON14);\n\n  if (atPole) {\n    // Look up axis value and adjust\n    const sign = Math.sign(origin.z);\n\n    firstAxisVector = scratchVector1.fromArray(degeneratePositionLocalFrame[firstAxis]);\n    if (firstAxis !== 'east' && firstAxis !== 'west') {\n      firstAxisVector.scale(sign);\n    }\n\n    secondAxisVector = scratchVector2.fromArray(degeneratePositionLocalFrame[secondAxis]);\n    if (secondAxis !== 'east' && secondAxis !== 'west') {\n      secondAxisVector.scale(sign);\n    }\n\n    thirdAxisVector = scratchVector3.fromArray(degeneratePositionLocalFrame[thirdAxis]);\n    if (thirdAxis !== 'east' && thirdAxis !== 'west') {\n      thirdAxisVector.scale(sign);\n    }\n  } else {\n    // Calculate all axis\n    const {up, east, north} = scratchAxisVectors;\n\n    east.set(-origin.y, origin.x, 0.0).normalize();\n    ellipsoid.geodeticSurfaceNormal(origin, up);\n    north.copy(up).cross(east);\n\n    const {down, west, south} = scratchAxisVectors;\n\n    down.copy(up).scale(-1);\n    west.copy(east).scale(-1);\n    south.copy(north).scale(-1);\n\n    // Pick three axis based on desired orientation\n    firstAxisVector = scratchAxisVectors[firstAxis];\n    secondAxisVector = scratchAxisVectors[secondAxis];\n    thirdAxisVector = scratchAxisVectors[thirdAxis];\n  }\n\n  // TODO - assuming the result is column-major\n  result[0] = firstAxisVector.x;\n  result[1] = firstAxisVector.y;\n  result[2] = firstAxisVector.z;\n  result[3] = 0.0;\n  result[4] = secondAxisVector.x;\n  result[5] = secondAxisVector.y;\n  result[6] = secondAxisVector.z;\n  result[7] = 0.0;\n  result[8] = thirdAxisVector.x;\n  result[9] = thirdAxisVector.y;\n  result[10] = thirdAxisVector.z;\n  result[11] = 0.0;\n  result[12] = origin.x;\n  result[13] = origin.y;\n  result[14] = origin.z;\n  result[15] = 1.0;\n  return result;\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {\n  Vector3,\n  Matrix4,\n  toRadians,\n  toDegrees,\n  assert,\n  equals,\n  _MathUtils,\n  NumericArray\n} from '@math.gl/core';\nimport * as vec3 from 'gl-matrix/vec3';\n\nimport {WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z} from '../constants';\nimport {fromCartographicToRadians, toCartographicFromRadians} from '../type-utils';\n\nimport scaleToGeodeticSurface from './helpers/scale-to-geodetic-surface';\nimport localFrameToFixedFrame from './helpers/ellipsoid-transform';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\nconst scratchK = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchHeight = new Vector3();\nconst scratchCartesian = new Vector3();\n\nlet wgs84;\n\n/**\n * A quadratic surface defined in Cartesian coordinates by the equation\n * `(x / a)^2 + (y / b)^2 + (z / c)^2 = 1`.  Primarily used\n * to represent the shape of planetary bodies.\n */\nexport default class Ellipsoid {\n  /** An Ellipsoid instance initialized to the WGS84 standard. */\n  static readonly WGS84: Ellipsoid = new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);\n\n  readonly radii: Vector3;\n  readonly radiiSquared: Vector3;\n  readonly radiiToTheFourth: Vector3;\n  readonly oneOverRadii: Vector3;\n  readonly oneOverRadiiSquared: Vector3;\n  readonly minimumRadius: number;\n  readonly maximumRadius: number;\n  readonly centerToleranceSquared: number = _MathUtils.EPSILON1;\n  readonly squaredXOverSquaredZ: number;\n\n  /** Creates an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions. */\n  constructor(x: number, y: number, z: number);\n  constructor();\n\n  constructor(x = 0.0, y = 0.0, z = 0.0) {\n    assert(x >= 0.0);\n    assert(y >= 0.0);\n    assert(z >= 0.0);\n\n    this.radii = new Vector3(x, y, z);\n\n    this.radiiSquared = new Vector3(x * x, y * y, z * z);\n\n    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);\n\n    this.oneOverRadii = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / x,\n      y === 0.0 ? 0.0 : 1.0 / y,\n      z === 0.0 ? 0.0 : 1.0 / z\n    );\n\n    this.oneOverRadiiSquared = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / (x * x),\n      y === 0.0 ? 0.0 : 1.0 / (y * y),\n      z === 0.0 ? 0.0 : 1.0 / (z * z)\n    );\n\n    this.minimumRadius = Math.min(x, y, z);\n\n    this.maximumRadius = Math.max(x, y, z);\n\n    if (this.radiiSquared.z !== 0) {\n      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;\n    }\n\n    Object.freeze(this);\n  }\n\n  /** Compares this Ellipsoid against the provided Ellipsoid componentwise */\n  equals(right: Ellipsoid): boolean {\n    return this === right || Boolean(right && this.radii.equals(right.radii));\n  }\n\n  /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */\n  toString(): string {\n    return this.radii.toString();\n  }\n\n  /** Converts the provided cartographic to Cartesian representation. */\n  cartographicToCartesian(cartographic: number[], result: Vector3): Vector3;\n  cartographicToCartesian(cartographic: number[], result?: number[]): number[];\n\n  cartographicToCartesian(cartographic, result = [0, 0, 0]) {\n    const normal = scratchNormal;\n    const k = scratchK;\n\n    const [, , height] = cartographic;\n    this.geodeticSurfaceNormalCartographic(cartographic, normal);\n    k.copy(this.radiiSquared).scale(normal);\n\n    const gamma = Math.sqrt(normal.dot(k));\n    k.scale(1 / gamma);\n\n    normal.scale(height);\n\n    k.add(normal);\n\n    return k.to(result);\n  }\n\n  /** Converts the provided cartesian to cartographic (lng/lat/z) representation.\n   * The cartesian is undefined at the center of the ellipsoid. */\n  cartesianToCartographic(cartesian: number[], result: Vector3): Vector3;\n  cartesianToCartographic(cartesian: number[], result?: number[]): number[];\n\n  cartesianToCartographic(cartesian, result = [0, 0, 0]) {\n    scratchCartesian.from(cartesian);\n    const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);\n\n    if (!point) {\n      return undefined;\n    }\n\n    const normal = this.geodeticSurfaceNormal(point, scratchNormal);\n\n    const h = scratchHeight;\n    h.copy(scratchCartesian).subtract(point);\n\n    const longitude = Math.atan2(normal.y, normal.x);\n    const latitude = Math.asin(normal.z);\n    const height = Math.sign(vec3.dot(h, scratchCartesian)) * vec3.length(h);\n\n    return toCartographicFromRadians([longitude, latitude, height], result);\n  }\n\n  /** Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes\n   * centered at the provided origin to the provided ellipsoid's fixed reference frame. */\n  eastNorthUpToFixedFrame(origin: number[], result?: Matrix4): Matrix4;\n  eastNorthUpToFixedFrame(origin: number[], result: number[]): number[];\n\n  eastNorthUpToFixedFrame(origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);\n  }\n\n  /** Computes a 4x4 transformation matrix from a reference frame centered at\n   * the provided origin to the ellipsoid's fixed reference frame.\n   */\n  localFrameToFixedFrame(\n    firstAxis: string,\n    secondAxis: string,\n    thirdAxis: string,\n    origin: Readonly<NumericArray>,\n    result?: Matrix4\n  ): Matrix4;\n  localFrameToFixedFrame<Matrix4T>(\n    firstAxis: string,\n    secondAxis: string,\n    thirdAxis: string,\n    origin: Readonly<NumericArray>,\n    result: number[]\n  ): number[];\n\n  // Computes a 4x4 transformation matrix from a reference frame centered at\n  // the provided origin to the ellipsoid's fixed reference frame.\n  localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);\n  }\n\n  /** Computes the unit vector directed from the center of this ellipsoid toward\n   * the provided Cartesian position. */\n  geocentricSurfaceNormal(cartesian: number[], result?: number[]): number[];\n  geocentricSurfaceNormal<NumArray>(cartesian: number[], result: NumArray): NumArray;\n  geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).normalize().to(result);\n  }\n\n  /** Computes the normal of the plane tangent to the surface of the ellipsoid at provided position. */\n  geodeticSurfaceNormalCartographic<NumArray>(cartographic: number[], result: NumArray): NumArray;\n  geodeticSurfaceNormalCartographic(cartographic: number[]): number[];\n  geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {\n    const cartographicVectorRadians = fromCartographicToRadians(cartographic);\n\n    const longitude = cartographicVectorRadians[0];\n    const latitude = cartographicVectorRadians[1];\n\n    const cosLatitude = Math.cos(latitude);\n\n    scratchVector\n      .set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude))\n      .normalize();\n\n    return scratchVector.to(result);\n  }\n\n  /** Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position. */\n  geodeticSurfaceNormal<NumArrayT>(cartesian: number[], result: NumArrayT): NumArrayT;\n  geodeticSurfaceNormal(cartesian: number[]): number[];\n  geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);\n  }\n\n  /** Scales the provided Cartesian position along the geodetic surface normal\n   * so that it is on the surface of this ellipsoid.  If the position is\n   * at the center of the ellipsoid, this function returns undefined. */\n  scaleToGeodeticSurface(cartesian: number[], result?: number[]): number[] {\n    return scaleToGeodeticSurface(cartesian, this, result);\n  }\n\n  /** Scales the provided Cartesian position along the geocentric surface normal\n   * so that it is on the surface of this ellipsoid. */\n  scaleToGeocentricSurface(cartesian: number[], result: number[] = [0, 0, 0]): number[] {\n    scratchPosition.from(cartesian);\n\n    const positionX = scratchPosition.x;\n    const positionY = scratchPosition.y;\n    const positionZ = scratchPosition.z;\n    const oneOverRadiiSquared = this.oneOverRadiiSquared;\n\n    const beta =\n      1.0 /\n      Math.sqrt(\n        positionX * positionX * oneOverRadiiSquared.x +\n          positionY * positionY * oneOverRadiiSquared.y +\n          positionZ * positionZ * oneOverRadiiSquared.z\n      );\n\n    return scratchPosition.multiplyScalar(beta).to(result);\n  }\n\n  /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n   * its components by the result of `Ellipsoid#oneOverRadii` */\n  transformPositionToScaledSpace(position: number[], result: number[] = [0, 0, 0]): number[] {\n    return scratchPosition.from(position).scale(this.oneOverRadii).to(result);\n  }\n\n  /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n   * its components by the result of `Ellipsoid#radii`. */\n  transformPositionFromScaledSpace(position: number[], result: number[] = [0, 0, 0]): number[] {\n    return scratchPosition.from(position).scale(this.radii).to(result);\n  }\n\n  /** Computes a point which is the intersection of the surface normal with the z-axis. */\n  getSurfaceNormalIntersectionWithZAxis(\n    position: number[],\n    buffer: number = 0,\n    result: number[] = [0, 0, 0]\n  ): number[] {\n    // Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\n    assert(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));\n    assert(this.radii.z > 0);\n\n    scratchPosition.from(position);\n    const z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);\n\n    if (Math.abs(z) >= this.radii.z - buffer) {\n      return undefined;\n    }\n\n    return scratchPosition.set(0.0, 0.0, z).to(result);\n  }\n}\n", "// loaders.gl, MIT license\n\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/**\n * Doubly linked list node\n * @private\n */\nexport class DoublyLinkedListNode {\n  item;\n  previous;\n  next;\n\n  constructor(item, previous, next) {\n    this.item = item;\n    this.previous = previous;\n    this.next = next;\n  }\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {DoublyLinkedListNode} from './doubly-linked-list-node';\n\n/**\n * Doubly linked list\n * @private\n */\nexport class DoublyLinkedList {\n  head: DoublyLinkedListNode | null = null;\n  tail: DoublyLinkedListNode | null = null;\n  _length = 0;\n\n  get length() {\n    return this._length;\n  }\n\n  /**\n   * Adds the item to the end of the list\n   * @param {*} [item]\n   * @return {DoublyLinkedListNode}\n   */\n  add(item) {\n    const node = new DoublyLinkedListNode(item, this.tail, null);\n\n    if (this.tail) {\n      this.tail.next = node;\n      this.tail = node;\n    } else {\n      this.head = node;\n      this.tail = node;\n    }\n\n    ++this._length;\n\n    return node;\n  }\n\n  /**\n   * Removes the given node from the list\n   * @param {DoublyLinkedListNode} node\n   */\n  remove(node) {\n    if (!node) {\n      return;\n    }\n\n    if (node.previous && node.next) {\n      node.previous.next = node.next;\n      node.next.previous = node.previous;\n    } else if (node.previous) {\n      // Remove last node\n      node.previous.next = null;\n      this.tail = node.previous;\n    } else if (node.next) {\n      // Remove first node\n      node.next.previous = null;\n      this.head = node.next;\n    } else {\n      // Remove last node in the linked list\n      this.head = null;\n      this.tail = null;\n    }\n\n    node.next = null;\n    node.previous = null;\n\n    --this._length;\n  }\n\n  /**\n   * Moves nextNode after node\n   * @param {DoublyLinkedListNode} node\n   * @param {DoublyLinkedListNode} nextNode\n   */\n  splice(node, nextNode) {\n    if (node === nextNode) {\n      return;\n    }\n\n    // Remove nextNode, then insert after node\n    this.remove(nextNode);\n    this._insert(node, nextNode);\n  }\n\n  _insert(node, nextNode) {\n    const oldNodeNext = node.next;\n    node.next = nextNode;\n\n    // nextNode is the new tail\n    if (this.tail === node) {\n      this.tail = nextNode;\n    } else {\n      oldNodeNext.previous = nextNode;\n    }\n\n    nextNode.next = oldNodeNext;\n    nextNode.previous = node;\n\n    ++this._length;\n  }\n}\n", "// loaders.gl, MIT license\n\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {DoublyLinkedList} from '../utils/doubly-linked-list';\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\n/**\n * Stores tiles with content loaded.\n *\n * @private\n */\nexport class TilesetCache {\n  private _list: DoublyLinkedList;\n  private _sentinel: any;\n  private _trimTiles: boolean;\n\n  constructor() {\n    // [head, sentinel) -> tiles that weren't selected this frame and may be removed from the cache\n    // (sentinel, tail] -> tiles that were selected this frame\n    this._list = new DoublyLinkedList();\n    this._sentinel = this._list.add('sentinel');\n    this._trimTiles = false;\n  }\n\n  reset() {\n    // Move sentinel node to the tail so, at the start of the frame, all tiles\n    // may be potentially replaced.  Tiles are moved to the right of the sentinel\n    // when they are selected so they will not be replaced.\n    this._list.splice(this._list.tail, this._sentinel);\n  }\n\n  touch(tile) {\n    const node = tile._cacheNode;\n    if (defined(node)) {\n      this._list.splice(this._sentinel, node);\n    }\n  }\n\n  add(tileset, tile, addCallback) {\n    if (!defined(tile._cacheNode)) {\n      tile._cacheNode = this._list.add(tile);\n\n      if (addCallback) {\n        addCallback(tileset, tile);\n      }\n    }\n  }\n\n  unloadTile(tileset, tile, unloadCallback?) {\n    const node = tile._cacheNode;\n    if (!defined(node)) {\n      return;\n    }\n\n    this._list.remove(node);\n    tile._cacheNode = undefined;\n    if (unloadCallback) {\n      unloadCallback(tileset, tile);\n    }\n  }\n\n  unloadTiles(tileset, unloadCallback) {\n    const trimTiles = this._trimTiles;\n    this._trimTiles = false;\n\n    const list = this._list;\n\n    const maximumMemoryUsageInBytes = tileset.maximumMemoryUsage * 1024 * 1024;\n\n    // Traverse the list only to the sentinel since tiles/nodes to the\n    // right of the sentinel were used this frame.\n    // The sub-list to the left of the sentinel is ordered from LRU to MRU.\n    const sentinel = this._sentinel;\n    let node = list.head;\n\n    while (\n      node !== sentinel &&\n      (tileset.gpuMemoryUsageInBytes > maximumMemoryUsageInBytes || trimTiles)\n    ) {\n      // @ts-expect-error\n      const tile = node.item;\n      // @ts-expect-error\n      node = node.next;\n      this.unloadTile(tileset, tile, unloadCallback);\n    }\n  }\n\n  trim() {\n    this._trimTiles = true;\n  }\n}\n", "// loaders.gl, MIT license\n\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {Matrix4, Vector3} from '@math.gl/core';\nimport {assert} from '@loaders.gl/loader-utils';\n\nexport function calculateTransformProps(tileHeader, tile) {\n  assert(tileHeader);\n  assert(tile);\n\n  const {rtcCenter, gltfUpAxis} = tile;\n  const {\n    computedTransform,\n    boundingVolume: {center}\n  } = tileHeader;\n\n  let modelMatrix = new Matrix4(computedTransform);\n\n  // Translate if appropriate\n  if (rtcCenter) {\n    modelMatrix.translate(rtcCenter);\n  }\n\n  // glTF models need to be rotated from Y to Z up\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#y-up-to-z-up\n  switch (gltfUpAxis) {\n    case 'Z':\n      break;\n    case 'Y':\n      const rotationY = new Matrix4().rotateX(Math.PI / 2);\n      modelMatrix = modelMatrix.multiplyRight(rotationY);\n      break;\n    case 'X':\n      const rotationX = new Matrix4().rotateY(-Math.PI / 2);\n      modelMatrix = modelMatrix.multiplyRight(rotationX);\n      break;\n    default:\n      break;\n  }\n\n  // Scale/offset positions if normalized integers\n  if (tile.isQuantized) {\n    modelMatrix.translate(tile.quantizedVolumeOffset).scale(tile.quantizedVolumeScale);\n  }\n\n  // Option 1: Cartesian matrix and origin\n  const cartesianOrigin = new Vector3(center);\n\n  tile.cartesianModelMatrix = modelMatrix;\n  tile.cartesianOrigin = cartesianOrigin;\n\n  // Option 2: Cartographic matrix and origin\n  const cartographicOrigin = Ellipsoid.WGS84.cartesianToCartographic(\n    cartesianOrigin,\n    new Vector3()\n  );\n  const fromFixedFrameMatrix = Ellipsoid.WGS84.eastNorthUpToFixedFrame(cartesianOrigin);\n  const toFixedFrameMatrix = fromFixedFrameMatrix.invert();\n\n  tile.cartographicModelMatrix = toFixedFrameMatrix.multiplyRight(modelMatrix);\n  tile.cartographicOrigin = cartographicOrigin;\n\n  // Deprecated, drop\n  if (!tile.coordinateSystem) {\n    tile.modelMatrix = tile.cartographicModelMatrix;\n  }\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nexport const INTERSECTION = {\n  OUTSIDE: -1, // Represents that an object is not contained within the frustum.\n  INTERSECTING: 0, // Represents that an object intersects one of the frustum's planes.\n  INSIDE: 1 // Represents that an object is fully within the frustum.\n} as const;\n", "import {BoundingVolume} from './bounding-volume';\nimport {Vector3} from '@math.gl/core';\nimport Plane from '../plane';\nimport {INTERSECTION} from '../../constants';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\n\n/**\n * An axis aligned bounding box - aligned with coordinate axes\n * @see BoundingVolume\n * @see BoundingRectangle\n * @see OrientedBoundingBox\n */\nexport default class AxisAlignedBoundingBox implements BoundingVolume {\n  /** The center point of the bounding box. */\n  readonly center: Vector3;\n  /** The positive half diagonal of the bounding box. */\n  readonly halfDiagonal: Vector3;\n  /** The minimum point defining the bounding box. [0, 0, 0] for empty box */\n  readonly minimum: Vector3;\n  /** The maximum point defining the bounding box. [0, 0, 0] for empty box */\n  readonly maximum: Vector3;\n\n  /**\n   * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.\n   * @param minimum=[0, 0, 0] The minimum point along the x, y, and z axes.\n   * @param maximum=[0, 0, 0] The maximum point along the x, y, and z axes.\n   * @param center The center of the box; automatically computed if not supplied.\n   */\n  constructor(\n    minimum: readonly number[] = [0, 0, 0],\n    maximum: readonly number[] = [0, 0, 0],\n    center?: readonly number[]\n  ) {\n    // If center was not defined, compute it.\n    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);\n    this.center = new Vector3(center);\n    this.halfDiagonal = new Vector3(maximum).subtract(this.center);\n\n    /**\n     * The minimum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.minimum = new Vector3(minimum);\n\n    /**\n     * The maximum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.maximum = new Vector3(maximum);\n  }\n\n  /**\n   * Duplicates a AxisAlignedBoundingBox instance.\n   *\n   * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.\n   */\n  clone(): AxisAlignedBoundingBox {\n    return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n  }\n\n  /**\n   * Compares the provided AxisAlignedBoundingBox componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.\n   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n   */\n  equals(right: AxisAlignedBoundingBox): boolean {\n    return (\n      this === right ||\n      (Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum))\n    );\n  }\n\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns itself, i.e. the modified BoundingVolume.\n   */\n  transform(transform: readonly number[]): this {\n    this.center.transformAsPoint(transform);\n    // TODO - this.halfDiagonal.transformAsVector(transform);\n    this.halfDiagonal.transform(transform);\n    this.minimum.transform(transform);\n    this.maximum.transform(transform);\n    return this;\n  }\n\n  /**\n   * Determines which side of a plane a box is located.\n   */\n  intersectPlane(plane: Plane): number {\n    const {halfDiagonal} = this;\n    const normal = scratchNormal.from(plane.normal);\n    const e =\n      halfDiagonal.x * Math.abs(normal.x) +\n      halfDiagonal.y * Math.abs(normal.y) +\n      halfDiagonal.z * Math.abs(normal.z);\n    const s = this.center.dot(normal) + plane.distance; // signed distance from center\n\n    if (s - e > 0) {\n      return INTERSECTION.INSIDE;\n    }\n\n    if (s + e < 0) {\n      // Not in front because normals point inward\n      return INTERSECTION.OUTSIDE;\n    }\n\n    return INTERSECTION.INTERSECTING;\n  }\n\n  /** Computes the estimated distance from the closest point on a bounding box to a point. */\n  distanceTo(point: readonly number[]): number {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  /** Computes the estimated distance squared from the closest point on a bounding box to a point. */\n  distanceSquaredTo(point: readonly number[]): number {\n    const offset = scratchVector.from(point).subtract(this.center);\n    const {halfDiagonal} = this;\n\n    let distanceSquared = 0.0;\n    let d;\n\n    d = Math.abs(offset.x) - halfDiagonal.x;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.y) - halfDiagonal.y;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.z) - halfDiagonal.z;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {NumericArray, Vector3} from '@math.gl/core';\nimport * as mat4 from 'gl-matrix/mat4';\nimport {INTERSECTION} from '../../constants';\nimport {BoundingVolume} from './bounding-volume';\nimport Plane from '../plane';\n\nconst scratchVector = new Vector3();\nconst scratchVector2 = new Vector3();\n\n/** A BoundingSphere */\nexport default class BoundingSphere implements BoundingVolume {\n  center: Vector3;\n  radius: number;\n\n  /** Creates a bounding sphere */\n  constructor(center: readonly number[] = [0, 0, 0], radius: number = 0.0) {\n    this.radius = -0;\n    this.center = new Vector3();\n    this.fromCenterRadius(center, radius);\n  }\n\n  /** Sets the bounding sphere from `center` and `radius`. */\n  fromCenterRadius(center: readonly number[], radius: number): this {\n    this.center.from(center);\n    this.radius = radius;\n    return this;\n  }\n\n  /**\n   * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere\n   * tightly and fully encompasses the box.\n   */\n  fromCornerPoints(corner: readonly number[], oppositeCorner: readonly number[]): this {\n    oppositeCorner = scratchVector.from(oppositeCorner);\n    this.center = new Vector3().from(corner).add(oppositeCorner).scale(0.5);\n    this.radius = this.center.distance(oppositeCorner);\n    return this;\n  }\n\n  /** Compares the provided BoundingSphere component wise */\n  equals(right: BoundingSphere): boolean {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.radius === right.radius)\n    );\n  }\n\n  /** Duplicates a BoundingSphere instance. */\n  clone(): BoundingSphere {\n    return new BoundingSphere(this.center, this.radius);\n  }\n\n  /** Computes a bounding sphere that contains both the left and right bounding spheres. */\n  union(boundingSphere: BoundingSphere): BoundingSphere {\n    const leftCenter = this.center;\n    const leftRadius = this.radius;\n    const rightCenter = boundingSphere.center;\n    const rightRadius = boundingSphere.radius;\n\n    const toRightCenter = scratchVector.copy(rightCenter).subtract(leftCenter);\n    const centerSeparation = toRightCenter.magnitude();\n\n    if (leftRadius >= centerSeparation + rightRadius) {\n      // Left sphere wins.\n      return this.clone();\n    }\n\n    if (rightRadius >= centerSeparation + leftRadius) {\n      // Right sphere wins.\n      return boundingSphere.clone();\n    }\n\n    // There are two tangent points, one on far side of each sphere.\n    const halfDistanceBetweenTangentPoints = (leftRadius + centerSeparation + rightRadius) * 0.5;\n\n    // Compute the center point halfway between the two tangent points.\n    scratchVector2\n      .copy(toRightCenter)\n      .scale((-leftRadius + halfDistanceBetweenTangentPoints) / centerSeparation)\n      .add(leftCenter);\n\n    this.center.copy(scratchVector2);\n    this.radius = halfDistanceBetweenTangentPoints;\n\n    return this;\n  }\n\n  /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */\n  expand(point: readonly number[]): this {\n    const scratchPoint = scratchVector.from(point);\n    const radius = scratchPoint.subtract(this.center).magnitude();\n    if (radius > this.radius) {\n      this.radius = radius;\n    }\n    return this;\n  }\n\n  // BoundingVolume interface\n\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param sphere The bounding sphere to apply the transformation to.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns self.\n   */\n  transform(transform: readonly number[]): this {\n    this.center.transform(transform);\n    const scale = mat4.getScaling(scratchVector, transform);\n    this.radius = Math.max(scale[0], Math.max(scale[1], scale[2])) * this.radius;\n    return this;\n  }\n\n  /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */\n  distanceSquaredTo(point: Readonly<NumericArray>): number {\n    const d = this.distanceTo(point);\n    return d * d;\n  }\n\n  /** Computes the estimated distance from the closest point on a bounding sphere to a point. */\n  distanceTo(point: Readonly<NumericArray>): number {\n    const scratchPoint = scratchVector.from(point);\n    const delta = scratchPoint.subtract(this.center);\n    return Math.max(0, delta.len() - this.radius);\n  }\n\n  /** Determines which side of a plane a sphere is located. */\n  intersectPlane(plane: Plane): number {\n    const center = this.center;\n    const radius = this.radius;\n    const normal = plane.normal;\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    // The center point is negative side of the plane normal\n    if (distanceToPlane < -radius) {\n      return INTERSECTION.OUTSIDE;\n    }\n    // The center point is positive side of the plane, but radius extends beyond it; partial overlap\n    if (distanceToPlane < radius) {\n      return INTERSECTION.INTERSECTING;\n    }\n    // The center point and radius is positive side of the plane\n    return INTERSECTION.INSIDE;\n  }\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3, Matrix4, Quaternion, NumericArray} from '@math.gl/core';\nimport type {BoundingVolume} from './bounding-volume';\nimport BoundingSphere from './bounding-sphere';\nimport type Plane from '../plane';\nimport {INTERSECTION} from '../../constants';\n\nconst scratchVector3 = new Vector3();\nconst scratchOffset = new Vector3();\nconst scratchVectorU = new Vector3();\nconst scratchVectorV = new Vector3();\nconst scratchVectorW = new Vector3();\nconst scratchCorner = new Vector3();\nconst scratchToCenter = new Vector3();\n\nconst MATRIX3 = {\n  COLUMN0ROW0: 0,\n  COLUMN0ROW1: 1,\n  COLUMN0ROW2: 2,\n  COLUMN1ROW0: 3,\n  COLUMN1ROW1: 4,\n  COLUMN1ROW2: 5,\n  COLUMN2ROW0: 6,\n  COLUMN2ROW1: 7,\n  COLUMN2ROW2: 8\n};\n\n/**\n * An OrientedBoundingBox of some object is a closed and convex cuboid.\n * It can provide a tighter bounding volume than `BoundingSphere` or\n * `AxisAlignedBoundingBox` in many cases.\n */\nexport default class OrientedBoundingBox implements BoundingVolume {\n  center: Vector3;\n  halfAxes: Matrix3;\n\n  /**\n   * An OrientedBoundingBox of some object is a closed and convex cuboid.\n   * It can provide a tighter bounding volume than\n   * `BoundingSphere` or `AxisAlignedBoundingBox` in many cases.\n   */\n  constructor(center?: readonly number[], halfAxes?: readonly number[]);\n  constructor(center: Readonly<NumericArray> = [0, 0, 0], halfAxes = [0, 0, 0, 0, 0, 0, 0, 0, 0]) {\n    this.center = new Vector3().from(center);\n    this.halfAxes = new Matrix3(halfAxes);\n  }\n\n  /** Returns an array with three halfSizes for the bounding box */\n  get halfSize(): number[] {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    return [new Vector3(xAxis).len(), new Vector3(yAxis).len(), new Vector3(zAxis).len()];\n  }\n\n  /** Returns a quaternion describing the orientation of the bounding box */\n  get quaternion(): Quaternion {\n    const xAxis = this.halfAxes.getColumn(0);\n    const yAxis = this.halfAxes.getColumn(1);\n    const zAxis = this.halfAxes.getColumn(2);\n    const normXAxis = new Vector3(xAxis).normalize();\n    const normYAxis = new Vector3(yAxis).normalize();\n    const normZAxis = new Vector3(zAxis).normalize();\n    return new Quaternion().fromMatrix3(new Matrix3([...normXAxis, ...normYAxis, ...normZAxis]));\n  }\n\n  /**\n   * Create OrientedBoundingBox from quaternion based OBB,\n   */\n  fromCenterHalfSizeQuaternion(\n    center: number[],\n    halfSize: number[],\n    quaternion: number[]\n  ): OrientedBoundingBox {\n    const quaternionObject = new Quaternion(quaternion);\n    const directionsMatrix = new Matrix3().fromQuaternion(quaternionObject);\n    directionsMatrix[0] = directionsMatrix[0] * halfSize[0];\n    directionsMatrix[1] = directionsMatrix[1] * halfSize[0];\n    directionsMatrix[2] = directionsMatrix[2] * halfSize[0];\n    directionsMatrix[3] = directionsMatrix[3] * halfSize[1];\n    directionsMatrix[4] = directionsMatrix[4] * halfSize[1];\n    directionsMatrix[5] = directionsMatrix[5] * halfSize[1];\n    directionsMatrix[6] = directionsMatrix[6] * halfSize[2];\n    directionsMatrix[7] = directionsMatrix[7] * halfSize[2];\n    directionsMatrix[8] = directionsMatrix[8] * halfSize[2];\n    this.center = new Vector3().from(center);\n    this.halfAxes = directionsMatrix;\n    return this;\n  }\n\n  /** Duplicates a OrientedBoundingBox instance. */\n  clone(): OrientedBoundingBox {\n    return new OrientedBoundingBox(this.center, this.halfAxes);\n  }\n\n  /** Compares the provided OrientedBoundingBox component wise and returns */\n  equals(right: OrientedBoundingBox): boolean {\n    return (\n      this === right ||\n      (Boolean(right) && this.center.equals(right.center) && this.halfAxes.equals(right.halfAxes))\n    );\n  }\n\n  /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */\n  getBoundingSphere(result = new BoundingSphere()): BoundingSphere {\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    // Calculate \"corner\" vector\n    const cornerVector = scratchVector3.copy(u).add(v).add(w);\n\n    result.center.copy(this.center);\n    result.radius = cornerVector.magnitude();\n\n    return result;\n  }\n\n  /** Determines which side of a plane the oriented bounding box is located. */\n  intersectPlane(plane: Plane): number {\n    const center = this.center;\n    const normal = plane.normal;\n    const halfAxes = this.halfAxes;\n\n    const normalX = normal.x;\n    const normalY = normal.y;\n    const normalZ = normal.z;\n\n    // Plane is used as if it is its normal; the first three components are assumed to be normalized\n    const radEffective =\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN0ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN0ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN0ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN1ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN1ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN1ROW2]\n      ) +\n      Math.abs(\n        normalX * halfAxes[MATRIX3.COLUMN2ROW0] +\n          normalY * halfAxes[MATRIX3.COLUMN2ROW1] +\n          normalZ * halfAxes[MATRIX3.COLUMN2ROW2]\n      );\n    const distanceToPlane = normal.dot(center) + plane.distance;\n\n    if (distanceToPlane <= -radEffective) {\n      // The entire box is on the negative side of the plane normal\n      return INTERSECTION.OUTSIDE;\n    } else if (distanceToPlane >= radEffective) {\n      // The entire box is on the positive side of the plane normal\n      return INTERSECTION.INSIDE;\n    }\n    return INTERSECTION.INTERSECTING;\n  }\n\n  /** Computes the estimated distance from the closest point on a bounding box to a point. */\n  distanceTo(point: readonly number[]): number {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  /**\n   * Computes the estimated distance squared from the closest point\n   * on a bounding box to a point.\n   * See Geometric Tools for Computer Graphics 10.4.2\n   */\n  distanceSquaredTo(point: readonly number[]): number {\n    // Computes the estimated distance squared from the\n    // closest point on a bounding box to a point.\n    // See Geometric Tools for Computer Graphics 10.4.2\n    const offset = scratchOffset.from(point).subtract(this.center);\n\n    const halfAxes = this.halfAxes;\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    const uHalf = u.magnitude();\n    const vHalf = v.magnitude();\n    const wHalf = w.magnitude();\n\n    u.normalize();\n    v.normalize();\n    w.normalize();\n\n    let distanceSquared = 0.0;\n    let d;\n\n    d = Math.abs(offset.dot(u)) - uHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(v)) - vHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.dot(w)) - wHalf;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n\n  /**\n   * The distances calculated by the vector from the center of the bounding box\n   * to position projected onto direction.\n   *\n   * - If you imagine the infinite number of planes with normal direction,\n   *   this computes the smallest distance to the closest and farthest planes\n   *   from `position` that intersect the bounding box.\n   *\n   * @param position The position to calculate the distance from.\n   * @param direction The direction from position.\n   * @param result An Interval (array of length 2) to store the nearest and farthest distances.\n   * @returns Interval (array of length 2) with nearest and farthest distances\n   *   on the bounding box from position in direction.\n   */\n  // eslint-disable-next-line max-statements\n  computePlaneDistances(\n    position: readonly number[],\n    direction: Vector3,\n    result: number[] = [-0, -0]\n  ): number[] {\n    let minDist = Number.POSITIVE_INFINITY;\n    let maxDist = Number.NEGATIVE_INFINITY;\n\n    const center = this.center;\n    const halfAxes = this.halfAxes;\n\n    const u = halfAxes.getColumn(0, scratchVectorU);\n    const v = halfAxes.getColumn(1, scratchVectorV);\n    const w = halfAxes.getColumn(2, scratchVectorW);\n\n    // project first corner\n    const corner = scratchCorner.copy(u).add(v).add(w).add(center);\n\n    const toCenter = scratchToCenter.copy(corner).subtract(position);\n    let mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project second corner\n    corner.copy(center).add(u).add(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project third corner\n    corner.copy(center).add(u).subtract(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fourth corner\n    corner.copy(center).add(u).subtract(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project fifth corner\n    center.copy(corner).subtract(u).add(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project sixth corner\n    center.copy(corner).subtract(u).add(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project seventh corner\n    center.copy(corner).subtract(u).subtract(v).add(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    // project eighth corner\n    center.copy(corner).subtract(u).subtract(v).subtract(w);\n\n    toCenter.copy(corner).subtract(position);\n    mag = direction.dot(toCenter);\n\n    minDist = Math.min(mag, minDist);\n    maxDist = Math.max(mag, maxDist);\n\n    result[0] = minDist;\n    result[1] = maxDist;\n    return result;\n  }\n\n  /**\n   * Applies a 4x4 affine transformation matrix to a bounding sphere.\n   * @param transform The transformation matrix to apply to the bounding sphere.\n   * @returns itself, i.e. the modified BoundingVolume.\n   */\n  transform(transformation: readonly number[]): this {\n    this.center.transformAsPoint(transformation);\n\n    const xAxis = this.halfAxes.getColumn(0, scratchVectorU);\n    xAxis.transformAsPoint(transformation);\n\n    const yAxis = this.halfAxes.getColumn(1, scratchVectorV);\n    yAxis.transformAsPoint(transformation);\n\n    const zAxis = this.halfAxes.getColumn(2, scratchVectorW);\n    zAxis.transformAsPoint(transformation);\n\n    this.halfAxes = new Matrix3([...xAxis, ...yAxis, ...zAxis]);\n    return this;\n  }\n\n  getTransform(): Matrix4 {\n    // const modelMatrix = Matrix4.fromRotationTranslation(this.boundingVolume.halfAxes, this.boundingVolume.center);\n    // return modelMatrix;\n    throw new Error('not implemented');\n  }\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, equals, assert, NumericArray} from '@math.gl/core';\n\nconst scratchPosition = new Vector3();\nconst scratchNormal = new Vector3();\n\n// A plane in Hessian Normal Form\nexport default class Plane {\n  readonly normal: Vector3;\n  distance: number;\n\n  constructor(normal: Readonly<NumericArray> = [0, 0, 1], distance: number = 0) {\n    this.normal = new Vector3();\n    this.distance = -0;\n    this.fromNormalDistance(normal, distance);\n  }\n\n  /** Creates a plane from a normal and a distance from the origin. */\n  fromNormalDistance(normal: Readonly<NumericArray>, distance: number): this {\n    assert(Number.isFinite(distance));\n    this.normal.from(normal).normalize();\n    this.distance = distance;\n    return this;\n  }\n\n  /** Creates a plane from a normal and a point on the plane. */\n  fromPointNormal(point: Readonly<NumericArray>, normal: Readonly<NumericArray>): this {\n    point = scratchPosition.from(point);\n    this.normal.from(normal).normalize();\n    const distance = -this.normal.dot(point);\n    this.distance = distance;\n    return this;\n  }\n\n  /** Creates a plane from the general equation */\n  fromCoefficients(a: number, b: number, c: number, d: number): this {\n    this.normal.set(a, b, c);\n    assert(equals(this.normal.len(), 1));\n    this.distance = d;\n    return this;\n  }\n\n  /** Duplicates a Plane instance. */\n  clone(): Plane {\n    return new Plane(this.normal, this.distance);\n  }\n\n  /** Compares the provided Planes by normal and distance */\n  equals(right: Plane): boolean {\n    return equals(this.distance, right.distance) && equals(this.normal, right.normal);\n  }\n\n  /** Computes the signed shortest distance of a point to a plane.\n   * The sign of the distance determines which side of the plane the point is on.\n   */\n  getPointDistance(point: Readonly<NumericArray>): number {\n    return this.normal.dot(point) + this.distance;\n  }\n\n  /** Transforms the plane by the given transformation matrix. */\n  transform(matrix4: Readonly<NumericArray>): this {\n    const normal = scratchNormal.copy(this.normal).transformAsVector(matrix4).normalize();\n    const point = this.normal.scale(-this.distance).transform(matrix4);\n    return this.fromPointNormal(point, normal);\n  }\n\n  /** Projects a point onto the plane. */\n  projectPointOntoPlane(point: Readonly<NumericArray>, result: Vector3): Vector3;\n  projectPointOntoPlane(\n    point: Readonly<NumericArray>,\n    result?: readonly number[]\n  ): readonly number[];\n\n  projectPointOntoPlane(point, result = [0, 0, 0]) {\n    point = scratchPosition.from(point);\n    // projectedPoint = point - (normal.point + scale) * normal\n    const pointDistance = this.getPointDistance(point);\n    const scaledNormal = scratchNormal.copy(this.normal).scale(pointDistance);\n\n    return point.subtract(scaledNormal).to(result);\n  }\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, assert} from '@math.gl/core';\nimport {INTERSECTION} from '../constants';\nimport Plane from './plane';\nimport type {BoundingVolume} from './bounding-volumes/bounding-volume';\nimport type BoundingSphere from './bounding-volumes/bounding-sphere';\n\n// X, Y, Z Unit vectors\nconst faces = [new Vector3([1, 0, 0]), new Vector3([0, 1, 0]), new Vector3([0, 0, 1])];\n\nconst scratchPlaneCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\nconst scratchPlane = new Plane(new Vector3(1.0, 0.0, 0.0), 0.0);\n\n/** A culling volume defined by planes. */\nexport default class CullingVolume {\n  /**\n   * For plane masks (as used in {@link CullingVolume#computeVisibilityWithPlaneMask}), this special value\n   * represents the case where the object bounding volume is entirely outside the culling volume.\n   */\n  static MASK_OUTSIDE = 0xffffffff;\n\n  /**\n   * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n   * represents the case where the object bounding volume is entirely inside the culling volume.\n   */\n  static MASK_INSIDE = 0x00000000;\n\n  /**\n   * For plane masks (as used in {@link CullingVolume.prototype.computeVisibilityWithPlaneMask}), this value\n   * represents the case where the object bounding volume (may) intersect all planes of the culling volume.\n   */\n  static MASK_INDETERMINATE = 0x7fffffff;\n\n  /** Array of clipping planes. */\n  readonly planes: Plane[];\n\n  /**\n   * Create a new `CullingVolume` bounded by an array of clipping planed\n   * @param planes Array of clipping planes.\n   * */\n  constructor(planes: Plane[] = []) {\n    this.planes = planes;\n  }\n\n  /**\n   * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.\n   * The planes are aligned to the x, y, and z axes in world coordinates.\n   */\n  fromBoundingSphere(boundingSphere: BoundingSphere): CullingVolume {\n    this.planes.length = 2 * faces.length;\n\n    const center = boundingSphere.center;\n    const radius = boundingSphere.radius;\n\n    let planeIndex = 0;\n\n    for (const faceNormal of faces) {\n      let plane0 = this.planes[planeIndex];\n      let plane1 = this.planes[planeIndex + 1];\n\n      if (!plane0) {\n        plane0 = this.planes[planeIndex] = new Plane();\n      }\n      if (!plane1) {\n        plane1 = this.planes[planeIndex + 1] = new Plane();\n      }\n\n      const plane0Center = scratchPlaneCenter.copy(faceNormal).scale(-radius).add(center);\n      const plane0Distance = -faceNormal.dot(plane0Center);\n\n      plane0.fromPointNormal(plane0Center, faceNormal);\n\n      const plane1Center = scratchPlaneCenter.copy(faceNormal).scale(radius).add(center);\n\n      const negatedFaceNormal = scratchPlaneNormal.copy(faceNormal).negate();\n\n      const plane1Distance = -negatedFaceNormal.dot(plane1Center);\n\n      plane1.fromPointNormal(plane1Center, negatedFaceNormal);\n\n      planeIndex += 2;\n    }\n\n    return this;\n  }\n\n  /** Determines whether a bounding volume intersects the culling volume. */\n  computeVisibility(boundingVolume: BoundingVolume): number {\n    // const planes = this.planes;\n    let intersect: number = INTERSECTION.INSIDE;\n    for (const plane of this.planes) {\n      const result = boundingVolume.intersectPlane(plane);\n      switch (result) {\n        case INTERSECTION.OUTSIDE:\n          // We are done\n          return INTERSECTION.OUTSIDE;\n\n        case INTERSECTION.INTERSECTING:\n          // If no other intersection is outside, return INTERSECTING\n          intersect = INTERSECTION.INTERSECTING;\n          break;\n\n        default:\n      }\n    }\n\n    return intersect;\n  }\n\n  /**\n   * Determines whether a bounding volume intersects the culling volume.\n   *\n   * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling\n   *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then\n   *   the parent (and therefore this) volume is completely inside plane[planeIndex]\n   *   and that plane check can be skipped.\n   */\n  computeVisibilityWithPlaneMask(boundingVolume: BoundingVolume, parentPlaneMask: number): number {\n    assert(Number.isFinite(parentPlaneMask), 'parentPlaneMask is required.');\n\n    if (\n      parentPlaneMask === CullingVolume.MASK_OUTSIDE ||\n      parentPlaneMask === CullingVolume.MASK_INSIDE\n    ) {\n      // parent is completely outside or completely inside, so this child is as well.\n      return parentPlaneMask;\n    }\n\n    // Start with MASK_INSIDE (all zeros) so that after the loop, the return value can be compared with MASK_INSIDE.\n    // (Because if there are fewer than 31 planes, the upper bits wont be changed.)\n    let mask = CullingVolume.MASK_INSIDE;\n\n    const planes = this.planes;\n    for (let k = 0; k < this.planes.length; ++k) {\n      // For k greater than 31 (since 31 is the maximum number of INSIDE/INTERSECTING bits we can store), skip the optimization.\n      const flag = k < 31 ? 1 << k : 0;\n      if (k < 31 && (parentPlaneMask & flag) === 0) {\n        // boundingVolume is known to be INSIDE this plane.\n        continue;\n      }\n\n      const plane = planes[k];\n      const result = boundingVolume.intersectPlane(plane);\n      if (result === INTERSECTION.OUTSIDE) {\n        return CullingVolume.MASK_OUTSIDE;\n      } else if (result === INTERSECTION.INTERSECTING) {\n        mask |= flag;\n      }\n    }\n\n    return mask;\n  }\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n// Note: This class is still an experimental export, mainly used by other test cases\n// - It has not been fully adapted to math.gl conventions\n// - Documentation has not been ported\n\nimport {Vector3, Vector2, Matrix4, assert, NumericArray} from '@math.gl/core';\nimport CullingVolume from './culling-volume';\nimport Plane from './plane';\n\nconst scratchPlaneUpVector = new Vector3();\nconst scratchPlaneRightVector = new Vector3();\nconst scratchPlaneNearCenter = new Vector3();\nconst scratchPlaneFarCenter = new Vector3();\nconst scratchPlaneNormal = new Vector3();\n\ntype PerspectiveOffCenterFrustumOptions = {\n  left?: number;\n  right?: number;\n  top?: number;\n  bottom?: number;\n  near?: number;\n  far?: number;\n};\n\nexport default class PerspectiveOffCenterFrustum {\n  /**\n   * Defines the left clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  left?: number;\n  private _left?: number;\n  /**\n   * Defines the right clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  right?: number;\n  private _right?: number;\n  /**\n   * Defines the top clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  top?: number;\n  private _top?: number;\n  /**\n   * Defines the bottom clipping plane.\n   * @type {Number}\n   * @default undefined\n   */\n  bottom?: number;\n  private _bottom?: number;\n  /**\n   * The distance of the near plane.\n   * @type {Number}\n   * @default 1.0\n   */\n  near: number;\n  private _near: number;\n  /**\n   * The distance of the far plane.\n   * @type {Number}\n   * @default 500000000.0\n   */\n  far: number;\n  private _far: number;\n\n  private _cullingVolume = new CullingVolume([\n    new Plane(),\n    new Plane(),\n    new Plane(),\n    new Plane(),\n    new Plane(),\n    new Plane()\n  ]);\n  private _perspectiveMatrix = new Matrix4();\n  private _infinitePerspective = new Matrix4();\n\n  /**\n   * The viewing frustum is defined by 6 planes.\n   * Each plane is represented by a {@link Vector4} object, where the x, y, and z components\n   * define the unit vector normal to the plane, and the w component is the distance of the\n   * plane from the origin/camera position.\n   *\n   * @alias PerspectiveOffCenterFrustum\n   *\n   * @example\n   * const frustum = new PerspectiveOffCenterFrustum({\n   *     left : -1.0,\n   *     right : 1.0,\n   *     top : 1.0,\n   *     bottom : -1.0,\n   *     near : 1.0,\n   *     far : 100.0\n   * });\n   *\n   * @see PerspectiveFrustum\n   */\n  constructor(options: PerspectiveOffCenterFrustumOptions = {}) {\n    const {near = 1.0, far = 500000000.0} = options;\n\n    this.left = options.left;\n    this._left = undefined;\n\n    this.right = options.right;\n    this._right = undefined;\n\n    this.top = options.top;\n    this._top = undefined;\n\n    this.bottom = options.bottom;\n    this._bottom = undefined;\n\n    this.near = near;\n    this._near = near;\n\n    this.far = far;\n    this._far = far;\n  }\n\n  /**\n   * Returns a duplicate of a PerspectiveOffCenterFrustum instance.\n   * @returns {PerspectiveOffCenterFrustum} A new PerspectiveFrustum instance.\n   * */\n  clone(): PerspectiveOffCenterFrustum {\n    return new PerspectiveOffCenterFrustum({\n      right: this.right,\n      left: this.left,\n      top: this.top,\n      bottom: this.bottom,\n      near: this.near,\n      far: this.far\n    });\n  }\n\n  /**\n   * Compares the provided PerspectiveOffCenterFrustum componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @returns {Boolean} <code>true</code> if they are equal, <code>false</code> otherwise.\n   */\n  equals(other: PerspectiveOffCenterFrustum): boolean {\n    return (\n      other &&\n      other instanceof PerspectiveOffCenterFrustum &&\n      this.right === other.right &&\n      this.left === other.left &&\n      this.top === other.top &&\n      this.bottom === other.bottom &&\n      this.near === other.near &&\n      this.far === other.far\n    );\n  }\n\n  /**\n   * Gets the perspective projection matrix computed from the view frustum.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   *\n   * @see PerspectiveOffCenterFrustum#infiniteProjectionMatrix\n   */\n  get projectionMatrix(): Matrix4 {\n    this._update();\n    return this._perspectiveMatrix;\n  }\n\n  /**\n   * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.\n   * @memberof PerspectiveOffCenterFrustum.prototype\n   * @type {Matrix4}\n   *\n   * @see PerspectiveOffCenterFrustum#projectionMatrix\n   */\n  get infiniteProjectionMatrix(): Matrix4 {\n    this._update();\n    return this._infinitePerspective;\n  }\n\n  /**\n   * Creates a culling volume for this frustum.\n   * @returns {CullingVolume} A culling volume at the given position and orientation.\n   *\n   * @example\n   * // Check if a bounding volume intersects the frustum.\n   * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);\n   * const intersect = cullingVolume.computeVisibility(boundingVolume);\n   */\n  // eslint-disable-next-line complexity, max-statements\n  computeCullingVolume(\n    /** A Vector3 defines the eye position. */\n    position: Readonly<NumericArray>,\n    /** A Vector3 defines the view direction. */\n    direction: Readonly<NumericArray>,\n    /** A Vector3 defines the up direction. */\n    up: Readonly<NumericArray>\n  ): CullingVolume {\n    assert(position, 'position is required.');\n    assert(direction, 'direction is required.');\n    assert(up, 'up is required.');\n\n    const planes = this._cullingVolume.planes;\n\n    up = scratchPlaneUpVector.copy(up).normalize();\n    const right = scratchPlaneRightVector.copy(direction).cross(up).normalize();\n\n    const nearCenter = scratchPlaneNearCenter\n      .copy(direction)\n      .multiplyByScalar(this.near)\n      .add(position);\n\n    const farCenter = scratchPlaneFarCenter\n      .copy(direction)\n      .multiplyByScalar(this.far)\n      .add(position);\n\n    let normal = scratchPlaneNormal;\n\n    // Left plane computation\n    normal.copy(right).multiplyByScalar(this.left).add(nearCenter).subtract(position).cross(up);\n\n    planes[0].fromPointNormal(position, normal);\n\n    // Right plane computation\n    normal\n      .copy(right)\n      .multiplyByScalar(this.right)\n      .add(nearCenter)\n      .subtract(position)\n      .cross(up)\n      .negate();\n\n    planes[1].fromPointNormal(position, normal);\n\n    // Bottom plane computation\n    normal\n      .copy(up)\n      .multiplyByScalar(this.bottom)\n      .add(nearCenter)\n      .subtract(position)\n      .cross(right)\n      .negate();\n\n    planes[2].fromPointNormal(position, normal);\n\n    // Top plane computation\n    normal.copy(up).multiplyByScalar(this.top).add(nearCenter).subtract(position).cross(right);\n\n    planes[3].fromPointNormal(position, normal);\n\n    normal = new Vector3().copy(direction);\n\n    // Near plane computation\n    planes[4].fromPointNormal(nearCenter, normal);\n\n    // Far plane computation\n    normal.negate();\n\n    planes[5].fromPointNormal(farCenter, normal);\n\n    return this._cullingVolume;\n  }\n\n  /**\n   * Returns the pixel's width and height in meters.\n   *\n   * @returns {Vector2} The modified result parameter or a new instance of {@link Vector2} with the pixel's width and height in the x and y properties, respectively.\n   *\n   * @exception {DeveloperError} drawingBufferWidth must be greater than zero.\n   * @exception {DeveloperError} drawingBufferHeight must be greater than zero.\n   *\n   * @example\n   * // Example 1\n   * // Get the width and height of a pixel.\n   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, new Vector2());\n   *\n   * @example\n   * // Example 2\n   * // Get the width and height of a pixel if the near plane was set to 'distance'.\n   * // For example, get the size of a pixel of an image on a billboard.\n   * const position = camera.position;\n   * const direction = camera.direction;\n   * const toCenter = Vector3.subtract(primitive.boundingVolume.center, position, new Vector3());      // vector from camera to a primitive\n   * const toCenterProj = Vector3.multiplyByScalar(direction, Vector3.dot(direction, toCenter), new Vector3()); // project vector onto camera direction vector\n   * const distance = Vector3.magnitude(toCenterProj);\n   * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, new Vector2());\n   */\n  getPixelDimensions(\n    /** The width of the drawing buffer. */\n    drawingBufferWidth: number,\n    /** The height of the drawing buffer. */\n    drawingBufferHeight: number,\n    /** The distance to the near plane in meters. */\n    distance: number,\n    /** The object onto which to store the result. */\n    result: Vector2\n  ): Vector2 {\n    this._update();\n\n    assert(Number.isFinite(drawingBufferWidth) && Number.isFinite(drawingBufferHeight));\n    // 'Both drawingBufferWidth and drawingBufferHeight are required.'\n    assert(drawingBufferWidth > 0);\n    // 'drawingBufferWidth must be greater than zero.'\n    assert(drawingBufferHeight > 0);\n    // 'drawingBufferHeight must be greater than zero.'\n    assert(distance > 0);\n    // 'distance is required.');\n    assert(result);\n    // 'A result object is required.');\n\n    const inverseNear = 1.0 / this.near;\n    let tanTheta = this.top * inverseNear;\n    const pixelHeight = (2.0 * distance * tanTheta) / drawingBufferHeight;\n    tanTheta = this.right * inverseNear;\n    const pixelWidth = (2.0 * distance * tanTheta) / drawingBufferWidth;\n\n    result.x = pixelWidth;\n    result.y = pixelHeight;\n    return result;\n  }\n\n  // eslint-disable-next-line complexity, max-statements\n  private _update() {\n    assert(\n      Number.isFinite(this.right) &&\n        Number.isFinite(this.left) &&\n        Number.isFinite(this.top) &&\n        Number.isFinite(this.bottom) &&\n        Number.isFinite(this.near) &&\n        Number.isFinite(this.far)\n    );\n    // throw new DeveloperError('right, left, top, bottom, near, or far parameters are not set.');\n\n    const {top, bottom, right, left, near, far} = this;\n\n    if (\n      top !== this._top ||\n      bottom !== this._bottom ||\n      left !== this._left ||\n      right !== this._right ||\n      near !== this._near ||\n      far !== this._far\n    ) {\n      assert(\n        this.near > 0 && this.near < this.far,\n        'near must be greater than zero and less than far.'\n      );\n\n      this._left = left;\n      this._right = right;\n      this._top = top;\n      this._bottom = bottom;\n      this._near = near;\n      this._far = far;\n      this._perspectiveMatrix = new Matrix4().frustum({\n        left,\n        right,\n        bottom,\n        top,\n        near,\n        far\n      });\n      this._infinitePerspective = new Matrix4().frustum({\n        left,\n        right,\n        bottom,\n        top,\n        near,\n        far: Infinity\n      });\n    }\n  }\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3} from '@math.gl/core';\nimport BoundingSphere from '../bounding-volumes/bounding-sphere';\n\n/* eslint-disable */\nconst fromPointsXMin = new Vector3();\nconst fromPointsYMin = new Vector3();\nconst fromPointsZMin = new Vector3();\nconst fromPointsXMax = new Vector3();\nconst fromPointsYMax = new Vector3();\nconst fromPointsZMax = new Vector3();\nconst fromPointsCurrentPos = new Vector3();\nconst fromPointsScratch = new Vector3();\nconst fromPointsRitterCenter = new Vector3();\nconst fromPointsMinBoxPt = new Vector3();\nconst fromPointsMaxBoxPt = new Vector3();\nconst fromPointsNaiveCenterScratch = new Vector3();\nconst volumeConstant = (4.0 / 3.0) * Math.PI;\n\n/**\n * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.\n *\n * The bounding sphere is computed by running two algorithms, a naive algorithm and\n * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.\n * Bounding sphere computation article http://blogs.agi.com/insight3d/index.php/2008/02/04/a-bounding\n *\n * @param positions An array of points that the bounding sphere will enclose.\n * @param result Optional object onto which to store the result.\n * @returns The modified result parameter or a new `BoundingSphere` instance if not provided.\n */\nexport default function makeBoundingSphereFromPoints(\n  positions: number[][],\n  result: BoundingSphere = new BoundingSphere()\n): BoundingSphere {\n  if (!positions || positions.length === 0) {\n    return result.fromCenterRadius([0, 0, 0], 0);\n  }\n\n  const currentPos = fromPointsCurrentPos.copy(positions[0]);\n\n  const xMin = fromPointsXMin.copy(currentPos);\n  const yMin = fromPointsYMin.copy(currentPos);\n  const zMin = fromPointsZMin.copy(currentPos);\n\n  const xMax = fromPointsXMax.copy(currentPos);\n  const yMax = fromPointsYMax.copy(currentPos);\n  const zMax = fromPointsZMax.copy(currentPos);\n\n  for (const position of positions) {\n    currentPos.copy(position);\n\n    const x = currentPos.x;\n    const y = currentPos.y;\n    const z = currentPos.z;\n\n    // Store points containing the the smallest and largest components\n    if (x < xMin.x) {\n      xMin.copy(currentPos);\n    }\n\n    if (x > xMax.x) {\n      xMax.copy(currentPos);\n    }\n\n    if (y < yMin.y) {\n      yMin.copy(currentPos);\n    }\n\n    if (y > yMax.y) {\n      yMax.copy(currentPos);\n    }\n\n    if (z < zMin.z) {\n      zMin.copy(currentPos);\n    }\n\n    if (z > zMax.z) {\n      zMax.copy(currentPos);\n    }\n  }\n\n  // Compute x-, y-, and z-spans (Squared distances b/n each component's min. and max.).\n  const xSpan = fromPointsScratch.copy(xMax).subtract(xMin).magnitudeSquared();\n  const ySpan = fromPointsScratch.copy(yMax).subtract(yMin).magnitudeSquared();\n  const zSpan = fromPointsScratch.copy(zMax).subtract(zMin).magnitudeSquared();\n\n  // Set the diameter endpoints to the largest span.\n  let diameter1 = xMin;\n  let diameter2 = xMax;\n  let maxSpan = xSpan;\n  if (ySpan > maxSpan) {\n    maxSpan = ySpan;\n    diameter1 = yMin;\n    diameter2 = yMax;\n  }\n  if (zSpan > maxSpan) {\n    maxSpan = zSpan;\n    diameter1 = zMin;\n    diameter2 = zMax;\n  }\n\n  // Calculate the center of the initial sphere found by Ritter's algorithm\n  const ritterCenter = fromPointsRitterCenter;\n  ritterCenter.x = (diameter1.x + diameter2.x) * 0.5;\n  ritterCenter.y = (diameter1.y + diameter2.y) * 0.5;\n  ritterCenter.z = (diameter1.z + diameter2.z) * 0.5;\n\n  // Calculate the radius of the initial sphere found by Ritter's algorithm\n  let radiusSquared = fromPointsScratch.copy(diameter2).subtract(ritterCenter).magnitudeSquared();\n  let ritterRadius = Math.sqrt(radiusSquared);\n\n  // Find the center of the sphere found using the Naive method.\n  const minBoxPt = fromPointsMinBoxPt;\n  minBoxPt.x = xMin.x;\n  minBoxPt.y = yMin.y;\n  minBoxPt.z = zMin.z;\n\n  const maxBoxPt = fromPointsMaxBoxPt;\n  maxBoxPt.x = xMax.x;\n  maxBoxPt.y = yMax.y;\n  maxBoxPt.z = zMax.z;\n\n  const naiveCenter = fromPointsNaiveCenterScratch\n    .copy(minBoxPt)\n    .add(maxBoxPt)\n    .multiplyByScalar(0.5);\n\n  // Begin 2nd pass to find naive radius and modify the ritter sphere.\n  let naiveRadius = 0;\n  for (const position of positions) {\n    currentPos.copy(position);\n\n    // Find the furthest point from the naive center to calculate the naive radius.\n    const r = fromPointsScratch.copy(currentPos).subtract(naiveCenter).magnitude();\n    if (r > naiveRadius) {\n      naiveRadius = r;\n    }\n\n    // Make adjustments to the Ritter Sphere to include all points.\n    const oldCenterToPointSquared = fromPointsScratch\n      .copy(currentPos)\n      .subtract(ritterCenter)\n      .magnitudeSquared();\n\n    if (oldCenterToPointSquared > radiusSquared) {\n      const oldCenterToPoint = Math.sqrt(oldCenterToPointSquared);\n      // Calculate new radius to include the point that lies outside\n      ritterRadius = (ritterRadius + oldCenterToPoint) * 0.5;\n      radiusSquared = ritterRadius * ritterRadius;\n      // Calculate center of new Ritter sphere\n      const oldToNew = oldCenterToPoint - ritterRadius;\n      ritterCenter.x = (ritterRadius * ritterCenter.x + oldToNew * currentPos.x) / oldCenterToPoint;\n      ritterCenter.y = (ritterRadius * ritterCenter.y + oldToNew * currentPos.y) / oldCenterToPoint;\n      ritterCenter.z = (ritterRadius * ritterCenter.z + oldToNew * currentPos.z) / oldCenterToPoint;\n    }\n  }\n\n  if (ritterRadius < naiveRadius) {\n    ritterCenter.to(result.center);\n    result.radius = ritterRadius;\n  } else {\n    naiveCenter.to(result.center);\n    result.radius = naiveRadius;\n  }\n\n  return result;\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Matrix3, _MathUtils} from '@math.gl/core';\n\nconst scratchMatrix = new Matrix3();\nconst scratchUnitary = new Matrix3();\nconst scratchDiagonal = new Matrix3();\n\nconst jMatrix = new Matrix3();\nconst jMatrixTranspose = new Matrix3();\n\nexport type EigenDecomposition = {\n  unitary: Matrix3;\n  diagonal: Matrix3;\n};\n\n/**\n * Computes the eigenvectors and eigenvalues of a symmetric matrix.\n *\n * - Returns a diagonal matrix and unitary matrix such that:\n * `matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)`\n * - The values along the diagonal of the diagonal matrix are the eigenvalues. The columns\n * of the unitary matrix are the corresponding eigenvectors.\n * - This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n * section 8.4.3 The Classical Jacobi Algorithm\n *\n * @param matrix The 3x3 matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.\n * @param result Optional object with unitary and diagonal properties which are matrices onto which to store the result.\n * @returns An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.\n *\n * @example\n * const a = //... symmetric matrix\n * const result = {\n *   unitary : new Matrix3(),\n *   diagonal : new Matrix3()\n * };\n * computeEigenDecomposition(a, result);\n *\n * const unitaryTranspose = Matrix3.transpose(result.unitary, new Matrix3());\n * const b = Matrix3.multiply(result.unitary, result.diagonal, new Matrix3());\n * Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a\n *\n * const lambda = result.diagonal.getColumn(0, new Vector3()).x;  // first eigenvalue\n * const v = result.unitary.getColumn(0, new Vector3());          // first eigenvector\n * const c = v.multiplyByScalar(lambda);                          // equal to v.transformByMatrix3(a)\n */\nexport default function computeEigenDecomposition(\n  matrix: number[],\n  // @ts-expect-error accept empty object type\n  result: EigenDecomposition = {}\n): EigenDecomposition {\n  const EIGEN_TOLERANCE = _MathUtils.EPSILON20;\n  const EIGEN_MAX_SWEEPS = 10;\n\n  let count = 0;\n  let sweep = 0;\n\n  const unitaryMatrix = scratchUnitary;\n  const diagonalMatrix = scratchDiagonal;\n\n  unitaryMatrix.identity();\n  diagonalMatrix.copy(matrix);\n\n  const epsilon = EIGEN_TOLERANCE * computeFrobeniusNorm(diagonalMatrix);\n\n  while (sweep < EIGEN_MAX_SWEEPS && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {\n    shurDecomposition(diagonalMatrix, jMatrix);\n\n    jMatrixTranspose.copy(jMatrix).transpose();\n\n    diagonalMatrix.multiplyRight(jMatrix);\n    diagonalMatrix.multiplyLeft(jMatrixTranspose);\n    unitaryMatrix.multiplyRight(jMatrix);\n\n    if (++count > 2) {\n      ++sweep;\n      count = 0;\n    }\n  }\n\n  result.unitary = unitaryMatrix.toTarget(result.unitary);\n  result.diagonal = diagonalMatrix.toTarget(result.diagonal);\n\n  return result;\n}\n\nfunction computeFrobeniusNorm(matrix: Matrix3): number {\n  let norm = 0.0;\n  for (let i = 0; i < 9; ++i) {\n    const temp = matrix[i];\n    norm += temp * temp;\n  }\n  return Math.sqrt(norm);\n}\n\nconst rowVal = [1, 0, 0];\nconst colVal = [2, 2, 1];\n\n// Computes the \"off-diagonal\" Frobenius norm.\n// Assumes matrix is symmetric.\nfunction offDiagonalFrobeniusNorm(matrix: Matrix3): number {\n  let norm = 0.0;\n  for (let i = 0; i < 3; ++i) {\n    const temp = matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])];\n    norm += 2.0 * temp * temp;\n  }\n  return Math.sqrt(norm);\n}\n\n// The routine takes a matrix, which is assumed to be symmetric, and\n// finds the largest off-diagonal term, and then creates\n// a matrix (result) which can be used to help reduce it\n//\n// This routine was created based upon Matrix Computations, 3rd ed., by Golub and Van Loan,\n// section 8.4.2 The 2by2 Symmetric Schur Decomposition.\n//\n// eslint-disable-next-line max-statements\nfunction shurDecomposition(matrix: Matrix3, result: Matrix3): Matrix3 {\n  const tolerance = _MathUtils.EPSILON15;\n\n  let maxDiagonal = 0.0;\n  let rotAxis = 1;\n\n  // find pivot (rotAxis) based on max diagonal of matrix\n  for (let i = 0; i < 3; ++i) {\n    const temp = Math.abs(matrix[scratchMatrix.getElementIndex(colVal[i], rowVal[i])]);\n    if (temp > maxDiagonal) {\n      rotAxis = i;\n      maxDiagonal = temp;\n    }\n  }\n\n  const p = rowVal[rotAxis];\n  const q = colVal[rotAxis];\n\n  let c = 1.0;\n  let s = 0.0;\n\n  if (Math.abs(matrix[scratchMatrix.getElementIndex(q, p)]) > tolerance) {\n    const qq = matrix[scratchMatrix.getElementIndex(q, q)];\n    const pp = matrix[scratchMatrix.getElementIndex(p, p)];\n    const qp = matrix[scratchMatrix.getElementIndex(q, p)];\n\n    const tau = (qq - pp) / 2.0 / qp;\n    let t;\n\n    if (tau < 0.0) {\n      t = -1.0 / (-tau + Math.sqrt(1.0 + tau * tau));\n    } else {\n      t = 1.0 / (tau + Math.sqrt(1.0 + tau * tau));\n    }\n\n    c = 1.0 / Math.sqrt(1.0 + t * t);\n    s = t * c;\n  }\n\n  // Copy into result\n  Matrix3.IDENTITY.to(result);\n  result[scratchMatrix.getElementIndex(p, p)] = result[scratchMatrix.getElementIndex(q, q)] = c;\n  result[scratchMatrix.getElementIndex(q, p)] = s;\n  result[scratchMatrix.getElementIndex(p, q)] = -s;\n\n  return result;\n}\n", "// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3} from '@math.gl/core';\nimport computeEigenDecomposition from './compute-eigen-decomposition';\nimport OrientedBoundingBox from '../bounding-volumes/oriented-bounding-box';\nimport AxisAlignedBoundingBox from '../bounding-volumes/axis-aligned-bounding-box';\n\nconst scratchVector2 = new Vector3();\n\nconst scratchVector3 = new Vector3();\n\nconst scratchVector4 = new Vector3();\n\nconst scratchVector5 = new Vector3();\n\nconst scratchVector6 = new Vector3();\n\nconst scratchCovarianceResult = new Matrix3();\n\nconst scratchEigenResult = {\n  diagonal: new Matrix3(),\n  unitary: new Matrix3()\n};\n\n/**\n * Computes an instance of an OrientedBoundingBox of the given positions.\n *\n * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).\n * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf\n */\n/* eslint-disable max-statements */\nexport function makeOrientedBoundingBoxFromPoints(\n  positions: number[][],\n  result: OrientedBoundingBox = new OrientedBoundingBox()\n): OrientedBoundingBox {\n  if (!positions || positions.length === 0) {\n    result.halfAxes = new Matrix3([0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    result.center = new Vector3();\n    return result;\n  }\n\n  const length = positions.length;\n  const meanPoint = new Vector3(0, 0, 0);\n  for (const position of positions) {\n    meanPoint.add(position);\n  }\n  const invLength = 1.0 / length;\n  meanPoint.multiplyByScalar(invLength);\n\n  let exx = 0.0;\n  let exy = 0.0;\n  let exz = 0.0;\n  let eyy = 0.0;\n  let eyz = 0.0;\n  let ezz = 0.0;\n\n  for (const position of positions) {\n    const p = scratchVector2.copy(position).subtract(meanPoint);\n    exx += p.x * p.x;\n    exy += p.x * p.y;\n    exz += p.x * p.z;\n    eyy += p.y * p.y;\n    eyz += p.y * p.z;\n    ezz += p.z * p.z;\n  }\n\n  exx *= invLength;\n  exy *= invLength;\n  exz *= invLength;\n  eyy *= invLength;\n  eyz *= invLength;\n  ezz *= invLength;\n\n  const covarianceMatrix = scratchCovarianceResult;\n  covarianceMatrix[0] = exx;\n  covarianceMatrix[1] = exy;\n  covarianceMatrix[2] = exz;\n  covarianceMatrix[3] = exy;\n  covarianceMatrix[4] = eyy;\n  covarianceMatrix[5] = eyz;\n  covarianceMatrix[6] = exz;\n  covarianceMatrix[7] = eyz;\n  covarianceMatrix[8] = ezz;\n\n  const {unitary} = computeEigenDecomposition(covarianceMatrix, scratchEigenResult);\n  const rotation = result.halfAxes.copy(unitary);\n\n  let v1 = rotation.getColumn(0, scratchVector4);\n  let v2 = rotation.getColumn(1, scratchVector5);\n  let v3 = rotation.getColumn(2, scratchVector6);\n\n  let u1 = -Number.MAX_VALUE;\n  let u2 = -Number.MAX_VALUE;\n  let u3 = -Number.MAX_VALUE;\n  let l1 = Number.MAX_VALUE;\n  let l2 = Number.MAX_VALUE;\n  let l3 = Number.MAX_VALUE;\n\n  for (const position of positions) {\n    scratchVector2.copy(position);\n\n    u1 = Math.max(scratchVector2.dot(v1), u1);\n    u2 = Math.max(scratchVector2.dot(v2), u2);\n    u3 = Math.max(scratchVector2.dot(v3), u3);\n\n    l1 = Math.min(scratchVector2.dot(v1), l1);\n    l2 = Math.min(scratchVector2.dot(v2), l2);\n    l3 = Math.min(scratchVector2.dot(v3), l3);\n  }\n\n  v1 = v1.multiplyByScalar(0.5 * (l1 + u1));\n  v2 = v2.multiplyByScalar(0.5 * (l2 + u2));\n  v3 = v3.multiplyByScalar(0.5 * (l3 + u3));\n\n  result.center.copy(v1).add(v2).add(v3);\n\n  const scale = scratchVector3.set(u1 - l1, u2 - l2, u3 - l3).multiplyByScalar(0.5);\n  const scaleMatrix = new Matrix3([scale[0], 0, 0, 0, scale[1], 0, 0, 0, scale[2]]);\n  result.halfAxes.multiplyRight(scaleMatrix);\n\n  return result;\n}\n\n/**\n * Computes an instance of an AxisAlignedBoundingBox. The box is determined by\n * finding the points spaced the farthest apart on the x, y, and z axes.\n */\nexport function makeAxisAlignedBoundingBoxFromPoints(\n  positions: readonly number[][],\n  result: AxisAlignedBoundingBox = new AxisAlignedBoundingBox()\n): AxisAlignedBoundingBox {\n  if (!positions || positions.length === 0) {\n    result.minimum.set(0, 0, 0);\n    result.maximum.set(0, 0, 0);\n    result.center.set(0, 0, 0);\n    result.halfDiagonal.set(0, 0, 0);\n    return result;\n  }\n\n  let minimumX = positions[0][0];\n  let minimumY = positions[0][1];\n  let minimumZ = positions[0][2];\n\n  let maximumX = positions[0][0];\n  let maximumY = positions[0][1];\n  let maximumZ = positions[0][2];\n\n  for (const p of positions) {\n    const x = p[0];\n    const y = p[1];\n    const z = p[2];\n\n    minimumX = Math.min(x, minimumX);\n    maximumX = Math.max(x, maximumX);\n    minimumY = Math.min(y, minimumY);\n    maximumY = Math.max(y, maximumY);\n    minimumZ = Math.min(z, minimumZ);\n    maximumZ = Math.max(z, maximumZ);\n  }\n\n  result.minimum.set(minimumX, minimumY, minimumZ);\n  result.maximum.set(maximumX, maximumY, maximumZ);\n  result.center.copy(result.minimum).add(result.maximum).scale(0.5);\n  result.halfDiagonal.copy(result.maximum).subtract(result.center);\n\n  return result;\n}\n", "import {Tile3D} from '@loaders.gl/tiles';\nimport {Vector3} from '@math.gl/core';\nimport {CullingVolume, Plane} from '@math.gl/culling';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {GeospatialViewport, Viewport} from '../../types';\n\nexport type FrameState = {\n  camera: {\n    position: number[];\n    direction: number[];\n    up: number[];\n  };\n  viewport: GeospatialViewport;\n  topDownViewport: GeospatialViewport; // Use it to calculate projected radius for a tile\n  height: number;\n  cullingVolume: CullingVolume;\n  frameNumber: number; // TODO: This can be the same between updates, what number is unique for between updates?\n  sseDenominator: number; // Assumes fovy = 60 degrees\n};\n\nconst scratchVector = new Vector3();\nconst scratchPosition = new Vector3();\nconst cullingVolume = new CullingVolume([\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane(),\n  new Plane()\n]);\n\n// Extracts a frame state appropriate for tile culling from a deck.gl viewport\n// TODO - this could likely be generalized and merged back into deck.gl for other culling scenarios\nexport function getFrameState(viewport: GeospatialViewport, frameNumber: number): FrameState {\n  // Traverse and and request. Update _selectedTiles so that we know what to render.\n  // Traverse and and request. Update _selectedTiles so that we know what to render.\n  const {cameraDirection, cameraUp, height} = viewport;\n  const {metersPerUnit} = viewport.distanceScales;\n\n  // TODO - Ellipsoid.eastNorthUpToFixedFrame() breaks on raw array, create a Vector.\n  // TODO - Ellipsoid.eastNorthUpToFixedFrame() takes a cartesian, is that intuitive?\n  const viewportCenterCartesian = worldToCartesian(viewport, viewport.center);\n  const enuToFixedTransform = Ellipsoid.WGS84.eastNorthUpToFixedFrame(viewportCenterCartesian);\n\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const cameraPositionCartesian = Ellipsoid.WGS84.cartographicToCartesian(\n    cameraPositionCartographic,\n    new Vector3()\n  );\n\n  // These should still be normalized as the transform has scale 1 (goes from meters to meters)\n  const cameraDirectionCartesian = new Vector3(\n    // @ts-ignore\n    enuToFixedTransform.transformAsVector(new Vector3(cameraDirection).scale(metersPerUnit))\n  ).normalize();\n  const cameraUpCartesian = new Vector3(\n    // @ts-ignore\n    enuToFixedTransform.transformAsVector(new Vector3(cameraUp).scale(metersPerUnit))\n  ).normalize();\n\n  commonSpacePlanesToWGS84(viewport);\n\n  const ViewportClass = viewport.constructor;\n  const {longitude, latitude, width, bearing, zoom} = viewport;\n  // @ts-ignore\n  const topDownViewport = new ViewportClass({\n    longitude,\n    latitude,\n    height,\n    width,\n    bearing,\n    zoom,\n    pitch: 0\n  });\n\n  // TODO: make a file/class for frameState and document what needs to be attached to this so that traversal can function\n  return {\n    camera: {\n      position: cameraPositionCartesian,\n      direction: cameraDirectionCartesian,\n      up: cameraUpCartesian\n    },\n    viewport,\n    topDownViewport,\n    height,\n    cullingVolume,\n    frameNumber, // TODO: This can be the same between updates, what number is unique for between updates?\n    sseDenominator: 1.15 // Assumes fovy = 60 degrees\n  };\n}\n\n/**\n * Limit `tiles` array length with `maximumTilesSelected` number.\n * The criteria for this filtering is distance of a tile center\n * to the `frameState.viewport`'s longitude and latitude\n * @param tiles - tiles array to filter\n * @param frameState - frameState to calculate distances\n * @param maximumTilesSelected - maximal amount of tiles in the output array\n * @returns new tiles array\n */\nexport function limitSelectedTiles(\n  tiles: Tile3D[],\n  frameState: FrameState,\n  maximumTilesSelected: number\n): [Tile3D[], Tile3D[]] {\n  if (maximumTilesSelected === 0 || tiles.length <= maximumTilesSelected) {\n    return [tiles, []];\n  }\n  // Accumulate distances in couples array: [tileIndex: number, distanceToViewport: number]\n  const tuples: [number, number][] = [];\n  const {longitude: viewportLongitude, latitude: viewportLatitude} = frameState.viewport;\n  for (const [index, tile] of tiles.entries()) {\n    const [longitude, latitude] = tile.header.mbs;\n    const deltaLon = Math.abs(viewportLongitude - longitude);\n    const deltaLat = Math.abs(viewportLatitude - latitude);\n    const distance = Math.sqrt(deltaLat * deltaLat + deltaLon * deltaLon);\n    tuples.push([index, distance]);\n  }\n  const tuplesSorted = tuples.sort((a, b) => a[1] - b[1]);\n  const selectedTiles: Tile3D[] = [];\n  for (let i = 0; i < maximumTilesSelected; i++) {\n    selectedTiles.push(tiles[tuplesSorted[i][0]]);\n  }\n  const unselectedTiles: Tile3D[] = [];\n  for (let i = maximumTilesSelected; i < tuplesSorted.length; i++) {\n    unselectedTiles.push(tiles[tuplesSorted[i][0]]);\n  }\n\n  return [selectedTiles, unselectedTiles];\n}\n\nfunction commonSpacePlanesToWGS84(viewport) {\n  // Extract frustum planes based on current view.\n  const frustumPlanes = viewport.getFrustumPlanes();\n\n  // Get the near/far plane centers\n  const nearCenterCommon = closestPointOnPlane(frustumPlanes.near, viewport.cameraPosition);\n  const nearCenterCartesian = worldToCartesian(viewport, nearCenterCommon);\n  const cameraCartesian = worldToCartesian(viewport, viewport.cameraPosition, scratchPosition);\n\n  let i = 0;\n  cullingVolume.planes[i++].fromPointNormal(\n    nearCenterCartesian,\n    scratchVector.copy(nearCenterCartesian).subtract(cameraCartesian)\n  );\n\n  for (const dir in frustumPlanes) {\n    if (dir === 'near') {\n      continue; // eslint-disable-line no-continue\n    }\n    const plane = frustumPlanes[dir];\n    const posCommon = closestPointOnPlane(plane, nearCenterCommon, scratchPosition);\n    const cartesianPos = worldToCartesian(viewport, posCommon, scratchPosition);\n\n    cullingVolume.planes[i++].fromPointNormal(\n      cartesianPos,\n      // Want the normal to point into the frustum since that's what culling expects\n      scratchVector.copy(nearCenterCartesian).subtract(cartesianPos)\n    );\n  }\n}\n\nfunction closestPointOnPlane(\n  plane: {distance: number; normal: Vector3},\n  refPoint: [number, number, number] | Vector3,\n  out: Vector3 = new Vector3()\n): Vector3 {\n  const distanceToRef = plane.normal.dot(refPoint);\n  out\n    .copy(plane.normal)\n    .scale(plane.distance - distanceToRef)\n    .add(refPoint);\n  return out;\n}\n\nfunction worldToCartesian(\n  viewport: Viewport,\n  point: number[] | Vector3,\n  out: Vector3 = new Vector3()\n): Vector3 {\n  const cartographicPos = viewport.unprojectPosition(point);\n  return Ellipsoid.WGS84.cartographicToCartesian(cartographicPos, out);\n}\n", "// loaders.gl, MIT license\n\nimport {Vector3} from '@math.gl/core';\nimport {BoundingSphere, OrientedBoundingBox} from '@math.gl/culling';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {BoundingRectangle} from '../../types';\n\nconst WGS84_RADIUS_X = 6378137.0;\nconst WGS84_RADIUS_Y = 6378137.0;\nconst WGS84_RADIUS_Z = 6356752.3142451793;\n\nconst scratchVector = new Vector3();\n\n/**\n * Calculate appropriate zoom value for a particular boundingVolume\n * @param boundingVolume - the instance of bounding volume\n * @param cartorgraphicCenter - cartographic center of the bounding volume\n * @returns {number} - zoom value\n */\nexport function getZoomFromBoundingVolume(\n  boundingVolume: BoundingSphere | OrientedBoundingBox | BoundingRectangle,\n  cartorgraphicCenter: Vector3\n) {\n  if (boundingVolume instanceof OrientedBoundingBox) {\n    // OrientedBoundingBox\n    const {halfAxes} = boundingVolume;\n    const obbSize = getObbSize(halfAxes);\n    // Use WGS84_RADIUS_Z to allign with BoundingSphere algorithm\n    // Add the tile elevation value for correct zooming to elevated tiles\n    return Math.log2(WGS84_RADIUS_Z / (obbSize + cartorgraphicCenter[2]));\n  } else if (boundingVolume instanceof BoundingSphere) {\n    // BoundingSphere\n    const {radius} = boundingVolume;\n    // Add the tile elevation value for correct zooming to elevated tiles\n    return Math.log2(WGS84_RADIUS_Z / (radius + cartorgraphicCenter[2]));\n  } else if (boundingVolume.width && boundingVolume.height) {\n    // BoundingRectangle\n    const {width, height} = boundingVolume;\n    const zoomX = Math.log2(WGS84_RADIUS_X / width);\n    const zoomY = Math.log2(WGS84_RADIUS_Y / height);\n\n    return (zoomX + zoomY) / 2;\n  }\n\n  return 1;\n}\n\n/**\n * Calculate initial zoom for the tileset from 3D `fullExtent` defined in\n * the tileset metadata\n * @param fullExtent - 3D extent of the tileset\n * @param fullExtent.xmin - minimal longitude in decimal degrees\n * @param fullExtent.xmax - maximal longitude in decimal degrees\n * @param fullExtent.ymin - minimal latitude in decimal degrees\n * @param fullExtent.ymax - maximal latitude in decimal degrees\n * @param fullExtent.zmin - minimal elevation in meters\n * @param fullExtent.zmax - maximal elevation in meters\n * @param cartorgraphicCenter - tileset center in cartographic coordinate system\n * @param cartesianCenter - tileset center in cartesian coordinate system\n * @returns - initial zoom for the tileset\n */\nexport function getZoomFromFullExtent(\n  fullExtent: {\n    xmin: number;\n    xmax: number;\n    ymin: number;\n    ymax: number;\n    zmin: number;\n    zmax: number;\n  },\n  cartorgraphicCenter: Vector3,\n  cartesianCenter: Vector3\n) {\n  const extentVertex = Ellipsoid.WGS84.cartographicToCartesian(\n    [fullExtent.xmax, fullExtent.ymax, fullExtent.zmax],\n    new Vector3()\n  );\n  const extentSize = Math.sqrt(\n    Math.pow(extentVertex[0] - cartesianCenter[0], 2) +\n      Math.pow(extentVertex[1] - cartesianCenter[1], 2) +\n      Math.pow(extentVertex[2] - cartesianCenter[2], 2)\n  );\n  return Math.log2(WGS84_RADIUS_Z / (extentSize + cartorgraphicCenter[2]));\n}\n\n/**\n * Calculate initial zoom for the tileset from 2D `extent` defined in\n * the tileset metadata\n * @param extent - 2D extent of the tileset. It is array of 4 elements [xmin, ymin, xmax, ymax]\n * @param extent[0] - minimal longitude in decimal degrees\n * @param extent[1] - minimal latitude in decimal degrees\n * @param extent[2] - maximal longitude in decimal degrees\n * @param extent[3] - maximal latitude in decimal degrees\n * @param cartorgraphicCenter - tileset center in cartographic coordinate system\n * @param cartesianCenter - tileset center in cartesian coordinate system\n * @returns - initial zoom for the tileset\n */\nexport function getZoomFromExtent(\n  extent: [number, number, number, number],\n  cartorgraphicCenter: Vector3,\n  cartesianCenter: Vector3\n) {\n  const [xmin, ymin, xmax, ymax] = extent;\n  return getZoomFromFullExtent(\n    {xmin, xmax, ymin, ymax, zmin: 0, zmax: 0},\n    cartorgraphicCenter,\n    cartesianCenter\n  );\n}\n\nfunction getObbSize(halfAxes) {\n  halfAxes.getColumn(0, scratchVector);\n  const axeY = halfAxes.getColumn(1);\n  const axeZ = halfAxes.getColumn(2);\n  const farthestVertex = scratchVector.add(axeY).add(axeZ);\n  const size = farthestVertex.len();\n  return size;\n}\n", "// loaders.gl, MIT license\n\nexport const TILE_CONTENT_STATE = {\n  UNLOADED: 0, // Has never been requested\n  LOADING: 1, // Is waiting on a pending request\n  PROCESSING: 2, // Request received.  Contents are being processed for rendering.  Depending on the content, it might make its own requests for external data.\n  READY: 3, // Ready to render.\n  EXPIRED: 4, // Is expired and will be unloaded once new content is loaded.\n  FAILED: 5 // Request failed.\n};\n\nexport const TILE_REFINEMENT = {\n  ADD: 1, // Render tile and, if screen space error exceeded, also refine to its children.\n  REPLACE: 2 // Render tile or, if screen space error exceeded, refine to its descendants instead.\n};\n\nexport const TILE_TYPE = {\n  EMPTY: 'empty',\n  SCENEGRAPH: 'scenegraph',\n  POINTCLOUD: 'pointcloud',\n  MESH: 'mesh'\n};\n\nexport const TILESET_TYPE = {\n  I3S: 'I3S',\n  TILES3D: 'TILES3D'\n};\n\nexport const LOD_METRIC_TYPE = {\n  GEOMETRIC_ERROR: 'geometricError',\n  MAX_SCREEN_THRESHOLD: 'maxScreenThreshold'\n};\n\n// Cesium 3D Tiles Specific\nexport const TILE3D_OPTIMIZATION_HINT = {\n  NOT_COMPUTED: -1,\n  USE_OPTIMIZATION: 1,\n  SKIP_OPTIMIZATION: 0\n};\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Quaternion, Vector3, Matrix3, Matrix4, degrees} from '@math.gl/core';\nimport {BoundingSphere, OrientedBoundingBox} from '@math.gl/culling';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {assert} from '@loaders.gl/loader-utils';\n\n// const scratchProjectedBoundingSphere = new BoundingSphere();\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\n// const scratchMatrix = new Matrix3();\nconst scratchScale = new Vector3();\nconst scratchNorthWest = new Vector3();\nconst scratchSouthEast = new Vector3();\n// const scratchRectangle = new Rectangle();\n// const scratchOrientedBoundingBox = new OrientedBoundingBox();\n// const scratchTransform = new Matrix4();\n\n/**\n * Create a bounding volume from the tile's bounding volume header.\n * @param {Object} boundingVolumeHeader The tile's bounding volume header.\n * @param {Matrix4} transform The transform to apply to the bounding volume.\n * @param [result] The object onto which to store the result.\n * @returns The modified result parameter or a new TileBoundingVolume instance if none was provided.\n */\nexport function createBoundingVolume(boundingVolumeHeader, transform, result) {\n  assert(boundingVolumeHeader, '3D Tile: boundingVolume must be defined');\n\n  // boundingVolume schema:\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/schema/boundingVolume.schema.json\n  if (boundingVolumeHeader.box) {\n    return createBox(boundingVolumeHeader.box, transform, result);\n  }\n  if (boundingVolumeHeader.region) {\n    // [west, south, east, north, minimum height, maximum height]\n    // Latitudes and longitudes are in the WGS 84 datum as defined in EPSG 4979 and are in radians.\n    // Heights are in meters above (or below) the WGS 84 ellipsoid.\n    const [west, south, east, north, minHeight, maxHeight] = boundingVolumeHeader.region;\n\n    const northWest = Ellipsoid.WGS84.cartographicToCartesian(\n      [degrees(west), degrees(north), minHeight],\n      scratchNorthWest\n    );\n    const southEast = Ellipsoid.WGS84.cartographicToCartesian(\n      [degrees(east), degrees(south), maxHeight],\n      scratchSouthEast\n    );\n    const centerInCartesian = new Vector3().addVectors(northWest, southEast).multiplyScalar(0.5);\n    const radius = new Vector3().subVectors(northWest, southEast).len() / 2.0;\n\n    // TODO improve region boundingVolume\n    // for now, create a sphere as the boundingVolume instead of box\n    return createSphere(\n      [centerInCartesian[0], centerInCartesian[1], centerInCartesian[2], radius],\n      new Matrix4()\n    );\n  }\n\n  if (boundingVolumeHeader.sphere) {\n    return createSphere(boundingVolumeHeader.sphere, transform, result);\n  }\n\n  throw new Error('3D Tile: boundingVolume must contain a sphere, region, or box');\n}\n\nfunction createBox(box, transform, result) {\n  // https://math.gl/modules/culling/docs/api-reference/oriented-bounding-box\n  // 1. A half-axes based representation.\n  // box: An array of 12 numbers that define an oriented bounding box.\n  // The first three elements define the x, y, and z values for the center of the box.\n  // The next three elements (with indices 3, 4, and 5) define the x axis direction and half-length.\n  // The next three elements (indices 6, 7, and 8) define the y axis direction and half-length.\n  // The last three elements (indices 9, 10, and 11) define the z axis direction and half-length.\n  // 2. A half-size-quaternion based representation.\n  // box: An array of 10 numbers that define an oriented bounding box.\n  // The first three elements define the x, y, and z values for the center of the box in a right-handed 3-axis (x, y, z) Cartesian coordinate system where the z-axis is up.\n  // The next three elements (with indices 3, 4, and 5) define the halfSize.\n  // The last four elements (indices 6, 7, 8 and 10) define the quaternion.\n  const center = new Vector3(box[0], box[1], box[2]);\n  transform.transform(center, center);\n  let origin: number[] = [];\n  if (box.length === 10) {\n    const halfSize = box.slice(3, 6);\n    const quaternion = new Quaternion();\n    quaternion.fromArray(box, 6);\n    const x = new Vector3([1, 0, 0]);\n    const y = new Vector3([0, 1, 0]);\n    const z = new Vector3([0, 0, 1]);\n    x.transformByQuaternion(quaternion);\n    x.scale(halfSize[0]);\n    y.transformByQuaternion(quaternion);\n    y.scale(halfSize[1]);\n    z.transformByQuaternion(quaternion);\n    z.scale(halfSize[2]);\n    origin = [...x.toArray(), ...y.toArray(), ...z.toArray()];\n  } else {\n    origin = [...box.slice(3, 6), ...box.slice(6, 9), ...box.slice(9, 12)];\n  }\n  const xAxis = transform.transformAsVector(origin.slice(0, 3));\n  const yAxis = transform.transformAsVector(origin.slice(3, 6));\n  const zAxis = transform.transformAsVector(origin.slice(6, 9));\n  const halfAxes = new Matrix3([\n    xAxis[0],\n    xAxis[1],\n    xAxis[2],\n    yAxis[0],\n    yAxis[1],\n    yAxis[2],\n    zAxis[0],\n    zAxis[1],\n    zAxis[2]\n  ]);\n\n  if (defined(result)) {\n    result.center = center;\n    result.halfAxes = halfAxes;\n    return result;\n  }\n\n  return new OrientedBoundingBox(center, halfAxes);\n}\n\n/*\nfunction createBoxFromTransformedRegion(region, transform, initialTransform, result) {\n  const rectangle = Rectangle.unpack(region, 0, scratchRectangle);\n  const minimumHeight = region[4];\n  const maximumHeight = region[5];\n\n  const orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n    rectangle,\n    minimumHeight,\n    maximumHeight,\n    Ellipsoid.WGS84,\n    scratchOrientedBoundingBox\n  );\n  const center = orientedBoundingBox.center;\n  const halfAxes = orientedBoundingBox.halfAxes;\n\n  // A region bounding volume is not transformed by the transform in the tileset JSON,\n  // but may be transformed by additional transforms applied in Cesium.\n  // This is why the transform is calculated as the difference between the initial transform and the current transform.\n  transform = Matrix4.multiplyTransformation(\n    transform,\n    Matrix4.inverseTransformation(initialTransform, scratchTransform),\n    scratchTransform\n  );\n  center = Matrix4.multiplyByPoint(transform, center, center);\n  const rotationScale = Matrix4.getRotation(transform, scratchMatrix);\n  halfAxes = Matrix3.multiply(rotationScale, halfAxes, halfAxes);\n\n  if (defined(result) && result instanceof TileOrientedBoundingBox) {\n    result.update(center, halfAxes);\n    return result;\n  }\n\n  return new TileOrientedBoundingBox(center, halfAxes);\n}\n\nfunction createRegion(region, transform, initialTransform, result) {\n  if (!Matrix4.equalsEpsilon(transform, initialTransform, CesiumMath.EPSILON8)) {\n    return createBoxFromTransformedRegion(region, transform, initialTransform, result);\n  }\n\n  if (defined(result)) {\n    return result;\n  }\n\n  const rectangleRegion = Rectangle.unpack(region, 0, scratchRectangle);\n\n  return new TileBoundingRegion({\n    rectangle: rectangleRegion,\n    minimumHeight: region[4],\n    maximumHeight: region[5]\n  });\n}\n*/\n\nfunction createSphere(sphere, transform, result?) {\n  // Find the transformed center\n  const center = new Vector3(sphere[0], sphere[1], sphere[2]);\n  transform.transform(center, center);\n  const scale = transform.getScale(scratchScale);\n\n  const uniformScale = Math.max(Math.max(scale[0], scale[1]), scale[2]);\n  const radius = sphere[3] * uniformScale;\n\n  if (defined(result)) {\n    result.center = center;\n    result.radius = radius;\n    return result;\n  }\n\n  return new BoundingSphere(center, radius);\n}\n", "// loaders.gl, MIT license\n\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n// TODO - Dynamic screen space error provides an optimization when looking at\n// tilesets from above\n\n/* eslint-disable */\n// @ts-nocheck\nimport {Matrix4, Vector3, clamp} from '@math.gl/core';\n\nconst scratchPositionNormal = new Vector3();\nconst scratchCartographic = new Vector3();\nconst scratchMatrix = new Matrix4();\nconst scratchCenter = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchDirection = new Vector3();\n\n// eslint-disable-next-line max-statements, complexity\nexport function calculateDynamicScreenSpaceError(root, {camera, mapProjection}, options = {}) {\n  const {dynamicScreenSpaceErrorHeightFalloff = 0.25, dynamicScreenSpaceErrorDensity = 0.00278} =\n    options;\n\n  let up;\n  let direction;\n  let height;\n  let minimumHeight;\n  let maximumHeight;\n\n  const tileBoundingVolume = root.contentBoundingVolume;\n\n  if (tileBoundingVolume instanceof TileBoundingRegion) {\n    up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);\n    direction = camera.directionWC;\n    height = camera.positionCartographic.height;\n    minimumHeight = tileBoundingVolume.minimumHeight;\n    maximumHeight = tileBoundingVolume.maximumHeight;\n  } else {\n    // Transform camera position and direction into the local coordinate system of the tileset\n    const transformLocal = Matrix4.inverseTransformation(root.computedTransform, scratchMatrix);\n    const ellipsoid = mapProjection.ellipsoid;\n    const boundingVolume = tileBoundingVolume.boundingVolume;\n    const centerLocal = Matrix4.multiplyByPoint(\n      transformLocal,\n      boundingVolume.center,\n      scratchCenter\n    );\n    if (Cartesian3.magnitude(centerLocal) > ellipsoid.minimumRadius) {\n      // The tileset is defined in WGS84. Approximate the minimum and maximum height.\n      const centerCartographic = Cartographic.fromCartesian(\n        centerLocal,\n        ellipsoid,\n        scratchCartographic\n      );\n      up = Cartesian3.normalize(camera.positionWC, scratchPositionNormal);\n      direction = camera.directionWC;\n      height = camera.positionCartographic.height;\n      minimumHeight = 0.0;\n      maximumHeight = centerCartographic.height * 2.0;\n    } else {\n      // The tileset is defined in local coordinates (z-up)\n      const positionLocal = Matrix4.multiplyByPoint(\n        transformLocal,\n        camera.positionWC,\n        scratchPosition\n      );\n      up = Cartesian3.UNIT_Z;\n      direction = Matrix4.multiplyByPointAsVector(\n        transformLocal,\n        camera.directionWC,\n        scratchDirection\n      );\n      direction = Cartesian3.normalize(direction, direction);\n      height = positionLocal.z;\n      if (tileBoundingVolume instanceof TileOrientedBoundingBox) {\n        // Assuming z-up, the last component stores the half-height of the box\n        const boxHeight = root._header.boundingVolume.box[11];\n        minimumHeight = centerLocal.z - boxHeight;\n        maximumHeight = centerLocal.z + boxHeight;\n      } else if (tileBoundingVolume instanceof TileBoundingSphere) {\n        const radius = boundingVolume.radius;\n        minimumHeight = centerLocal.z - radius;\n        maximumHeight = centerLocal.z + radius;\n      }\n    }\n  }\n\n  // The range where the density starts to lessen. Start at the quarter height of the tileset.\n  const heightFalloff = dynamicScreenSpaceErrorHeightFalloff;\n  const heightClose = minimumHeight + (maximumHeight - minimumHeight) * heightFalloff;\n  const heightFar = maximumHeight;\n\n  const t = clamp((height - heightClose) / (heightFar - heightClose), 0.0, 1.0);\n\n  // Increase density as the camera tilts towards the horizon\n  const dot = Math.abs(Cartesian3.dot(direction, up));\n\n  let horizonFactor = 1.0 - dot;\n\n  // Weaken the horizon factor as the camera height increases, implying the camera is further away from the tileset.\n  // The goal is to increase density for the \"street view\", not when viewing the tileset from a distance.\n  horizonFactor = horizonFactor * (1.0 - t);\n\n  return dynamicScreenSpaceErrorDensity * horizonFactor;\n}\n\nexport function fog(distanceToCamera, density) {\n  const scalar = distanceToCamera * density;\n  return 1.0 - Math.exp(-(scalar * scalar));\n}\n\nexport function getDynamicScreenSpaceError(tileset, distanceToCamera) {\n  if (tileset.dynamicScreenSpaceError && tileset.dynamicScreenSpaceErrorComputedDensity) {\n    const density = tileset.dynamicScreenSpaceErrorComputedDensity;\n    const factor = tileset.dynamicScreenSpaceErrorFactor;\n    // TODO: Refined screen space error that minimizes tiles in non-first-person\n    const dynamicError = fog(distanceToCamera, density) * factor;\n    return dynamicError;\n  }\n\n  return 0;\n}\n\nexport function getTiles3DScreenSpaceError(tile, frameState, useParentLodMetric) {\n  const tileset = tile.tileset;\n  const parentLodMetricValue = (tile.parent && tile.parent.lodMetricValue) || tile.lodMetricValue;\n  const lodMetricValue = useParentLodMetric ? parentLodMetricValue : tile.lodMetricValue;\n\n  // Leaf tiles do not have any error so save the computation\n  if (lodMetricValue === 0.0) {\n    return 0.0;\n  }\n\n  // TODO: Orthographic Frustum needs special treatment?\n  // this._getOrthograhicScreenSpaceError();\n\n  // Avoid divide by zero when viewer is inside the tile\n  const distance = Math.max(tile._distanceToCamera, 1e-7);\n  const {height, sseDenominator} = frameState;\n  const {viewDistanceScale} = tileset.options;\n  let error = (lodMetricValue * height * (viewDistanceScale || 1.0)) / (distance * sseDenominator);\n\n  error -= getDynamicScreenSpaceError(tileset, distance);\n\n  return error;\n}\n", "// loaders.gl, MIT license\n\nimport {Matrix4, Vector3} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {Tile3D} from '../tile-3d';\nimport {FrameState} from './frame-state';\n\nconst cameraPositionCartesian = new Vector3();\nconst toEye = new Vector3();\nconst cameraPositionEnu = new Vector3();\nconst extraVertexEnu = new Vector3();\nconst projectedOriginVector = new Vector3();\nconst enuToCartesianMatrix = new Matrix4();\nconst cartesianToEnuMatrix = new Matrix4();\n\n/**\n * For the maxScreenThreshold error metric, maxError means that you should replace the node with it's children\n   as soon as the nodes bounding sphere has a screen radius larger than maxError pixels.\n   In this sense a value of 0 means you should always load it's children,\n   or if it's a leaf node, you should always display it.\n * @param tile \n * @param frameState \n * @returns \n */\nexport function getLodStatus(tile: Tile3D, frameState: FrameState): 'DIG' | 'OUT' | 'DRAW' {\n  if (tile.lodMetricValue === 0 || isNaN(tile.lodMetricValue)) {\n    return 'DIG';\n  }\n  const screenSize = 2 * getProjectedRadius(tile, frameState);\n  if (screenSize < 2) {\n    return 'OUT';\n  }\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n  return 'OUT';\n}\n\n/**\n * Calculate size of MBS radius projected on the screen plane\n * @param tile\n * @param frameState\n * @returns\n */\n// eslint-disable-next-line max-statements\nexport function getProjectedRadius(tile: Tile3D, frameState: FrameState): number {\n  const {topDownViewport: viewport} = frameState;\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n  const mbsCenterCartesian = [...tile.boundingVolume.center];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  Ellipsoid.WGS84.cartographicToCartesian(cameraPositionCartographic, cameraPositionCartesian);\n\n  // ---------------------------\n  // Calculate mbs border vertex\n  // ---------------------------\n  toEye.copy(cameraPositionCartesian).subtract(mbsCenterCartesian).normalize();\n  // Add extra vector to form plane\n  Ellipsoid.WGS84.eastNorthUpToFixedFrame(mbsCenterCartesian, enuToCartesianMatrix);\n  cartesianToEnuMatrix.copy(enuToCartesianMatrix).invert();\n  cameraPositionEnu.copy(cameraPositionCartesian).transform(cartesianToEnuMatrix);\n  // Mean Proportionals in Right Triangles - Altitude rule\n  // https://mathbitsnotebook.com/Geometry/RightTriangles/RTmeanRight.html\n  const projection = Math.sqrt(\n    cameraPositionEnu[0] * cameraPositionEnu[0] + cameraPositionEnu[1] * cameraPositionEnu[1]\n  );\n  const extraZ = (projection * projection) / cameraPositionEnu[2];\n  extraVertexEnu.copy([cameraPositionEnu[0], cameraPositionEnu[1], extraZ]);\n  const extraVertexCartesian = extraVertexEnu.transform(enuToCartesianMatrix);\n  const extraVectorCartesian = extraVertexCartesian.subtract(mbsCenterCartesian).normalize();\n  // We need radius vector orthogonal to toEye vector\n  const radiusVector = toEye.cross(extraVectorCartesian).normalize().scale(mbsR);\n  const sphereMbsBorderVertexCartesian = radiusVector.add(mbsCenterCartesian);\n  const sphereMbsBorderVertexCartographic = Ellipsoid.WGS84.cartesianToCartographic(\n    sphereMbsBorderVertexCartesian\n  );\n  // ---------------------------\n\n  // Project center vertex and border vertex and calculate projected radius of MBS\n  const projectedOrigin = viewport.project([mbsLon, mbsLat, mbsZ]);\n  const projectedMbsBorderVertex = viewport.project(\n    sphereMbsBorderVertexCartographic as [number, number, number]\n  );\n  const projectedRadius = projectedOriginVector\n    .copy(projectedOrigin)\n    .subtract(projectedMbsBorderVertex)\n    .magnitude();\n  return projectedRadius;\n}\n", "export function get3dTilesOptions(tileset) {\n  return {\n    assetGltfUpAxis: (tileset.asset && tileset.asset.gltfUpAxis) || 'Y'\n  };\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {assert} from '@loaders.gl/loader-utils';\n\n/**\n * A wrapper around arrays so that the internal length of the array can be manually managed.\n *\n * @alias ManagedArray\n * @constructor\n * @private\n *\n * @param {Number} [length=0] The initial length of the array.\n */\nexport class ManagedArray {\n  _map = new Map();\n  _array: any[];\n  _length: number;\n\n  constructor(length = 0) {\n    this._array = new Array(length);\n    this._length = length;\n  }\n\n  /**\n   * Gets or sets the length of the array.\n   * If the set length is greater than the length of the internal array, the internal array is resized.\n   *\n   * @memberof ManagedArray.prototype\n   * @type Number\n   */\n  get length() {\n    return this._length;\n  }\n\n  set length(length) {\n    this._length = length;\n    if (length > this._array.length) {\n      this._array.length = length;\n    }\n  }\n\n  /**\n   * Gets the internal array.\n   *\n   * @memberof ManagedArray.prototype\n   * @type Array\n   * @readonly\n   */\n  get values() {\n    return this._array;\n  }\n\n  /**\n   * Gets the element at an index.\n   *\n   * @param {Number} index The index to get.\n   */\n  get(index) {\n    assert(index < this._array.length);\n    return this._array[index];\n  }\n\n  /**\n   * Sets the element at an index. Resizes the array if index is greater than the length of the array.\n   *\n   * @param {Number} index The index to set.\n   * @param {*} element The element to set at index.\n   */\n  set(index, element) {\n    assert(index >= 0);\n\n    if (index >= this.length) {\n      this.length = index + 1;\n    }\n\n    if (this._map.has(this._array[index])) {\n      this._map.delete(this._array[index]);\n    }\n\n    this._array[index] = element;\n    this._map.set(element, index);\n  }\n\n  delete(element) {\n    const index = this._map.get(element);\n    if (index >= 0) {\n      this._array.splice(index, 1);\n      this._map.delete(element);\n      this.length--;\n    }\n  }\n\n  /**\n   * Returns the last element in the array without modifying the array.\n   *\n   * @returns {*} The last element in the array.\n   */\n  peek() {\n    return this._array[this._length - 1];\n  }\n\n  /**\n   * Push an element into the array.\n   *\n   * @param {*} element The element to push.\n   */\n  push(element) {\n    if (!this._map.has(element)) {\n      const index = this.length++;\n      this._array[index] = element;\n      this._map.set(element, index);\n    }\n  }\n\n  /**\n   * Pop an element from the array.\n   *\n   * @returns {*} The last element in the array.\n   */\n  pop() {\n    const element = this._array[--this.length];\n    this._map.delete(element);\n    return element;\n  }\n\n  /**\n   * Resize the internal array if length > _array.length.\n   *\n   * @param {Number} length The length.\n   */\n  reserve(length) {\n    assert(length >= 0);\n\n    if (length > this._array.length) {\n      this._array.length = length;\n    }\n  }\n\n  /**\n   * Resize the array.\n   *\n   * @param {Number} length The length.\n   */\n  resize(length) {\n    assert(length >= 0);\n\n    this.length = length;\n  }\n\n  /**\n   * Trim the internal array to the specified length. Defaults to the current length.\n   *\n   * @param {Number} [length] The length.\n   */\n  trim(length) {\n    if (length === null || length === undefined) {\n      length = this.length;\n    }\n    this._array.length = length;\n  }\n\n  reset() {\n    this._array = [];\n    this._map = new Map();\n    this._length = 0;\n  }\n\n  find(target) {\n    return this._map.has(target);\n  }\n}\n", "import {ManagedArray} from '../utils/managed-array';\nimport {TILE_REFINEMENT} from '../constants';\nimport {FrameState} from './helpers/frame-state';\n\nexport type TilesetTraverserProps = {\n  loadSiblings?: boolean;\n  skipLevelOfDetail?: boolean;\n  maximumScreenSpaceError?: number;\n  onTraversalEnd?: (frameState) => any;\n  viewportTraversersMap?: {[key: string]: any};\n  basePath?: string;\n  updateTransforms?: boolean;\n};\n\n// export type Props = {\n//   loadSiblings: boolean;\n//   skipLevelOfDetail: boolean;\n//   updateTransforms: boolean;\n//   maximumScreenSpaceError: number;\n//   onTraversalEnd: (frameState) => any;\n//   viewportTraversersMap: {[key: string]: any};\n//   basePath: string;\n// };\n\nexport const DEFAULT_PROPS: Required<TilesetTraverserProps> = {\n  loadSiblings: false,\n  skipLevelOfDetail: false,\n  maximumScreenSpaceError: 2,\n  updateTransforms: true,\n  onTraversalEnd: () => {},\n  viewportTraversersMap: {},\n  basePath: ''\n};\n\nexport class TilesetTraverser {\n  options: Required<TilesetTraverserProps>;\n\n  root: any;\n  requestedTiles: object;\n  selectedTiles: object;\n  emptyTiles: object;\n\n  protected lastUpdate: number = new Date().getTime();\n  protected readonly updateDebounceTime = 1000;\n  protected _traversalStack: ManagedArray;\n  protected _emptyTraversalStack: ManagedArray;\n  protected _frameNumber: number | null;\n\n  protected traversalFinished(frameState: FrameState): boolean {\n    return true;\n  }\n\n  // TODO nested props\n  constructor(options: TilesetTraverserProps) {\n    this.options = {...DEFAULT_PROPS, ...options};\n    // TRAVERSAL\n    // temporary storage to hold the traversed tiles during a traversal\n    this._traversalStack = new ManagedArray();\n    this._emptyTraversalStack = new ManagedArray();\n\n    // set in every traverse cycle\n    this._frameNumber = null;\n\n    // fulfill in traverse call\n    this.root = null;\n\n    // RESULT\n    // tiles should be rendered\n    this.selectedTiles = {};\n    // tiles should be loaded from server\n    this.requestedTiles = {};\n    // tiles does not have render content\n    this.emptyTiles = {};\n  }\n\n  // tiles should be visible\n  traverse(root, frameState, options) {\n    this.root = root; // for root screen space error\n    this.options = {...this.options, ...options};\n\n    // reset result\n    this.reset();\n\n    // update tile (visibility and expiration)\n    this.updateTile(root, frameState);\n\n    this._frameNumber = frameState.frameNumber;\n    this.executeTraversal(root, frameState);\n  }\n\n  reset() {\n    this.requestedTiles = {};\n    this.selectedTiles = {};\n    this.emptyTiles = {};\n    this._traversalStack.reset();\n    this._emptyTraversalStack.reset();\n  }\n\n  // execute traverse\n  // Depth-first traversal that traverses all visible tiles and marks tiles for selection.\n  // If skipLevelOfDetail is off then a tile does not refine until all children are loaded.\n  // This is the traditional replacement refinement approach and is called the base traversal.\n  // Tiles that have a greater screen space error than the base screen space error are part of the base traversal,\n  // all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree\n  // and rendering children and parent tiles simultaneously.\n  /* eslint-disable-next-line complexity, max-statements */\n  executeTraversal(root, frameState: FrameState) {\n    // stack to store traversed tiles, only visible tiles should be added to stack\n    // visible: visible in the current view frustum\n    const stack = this._traversalStack;\n    root._selectionDepth = 1;\n\n    stack.push(root);\n    while (stack.length > 0) {\n      // 1. pop tile\n      const tile = stack.pop();\n\n      // 2. check if tile needs to be refine, needs refine if a tile's LoD is not sufficient and tile has available children (available content)\n      let shouldRefine = false;\n      if (this.canTraverse(tile, frameState)) {\n        this.updateChildTiles(tile, frameState);\n        shouldRefine = this.updateAndPushChildren(\n          tile,\n          frameState,\n          stack,\n          tile.hasRenderContent ? tile._selectionDepth + 1 : tile._selectionDepth\n        );\n      }\n\n      // 3. decide if should render (select) this tile\n      //   - tile does not have render content\n      //   - tile has render content and tile is `add` type (pointcloud)\n      //   - tile has render content and tile is `replace` type (photogrammetry) and can't refine any further\n      const parent = tile.parent;\n      const parentRefines = Boolean(!parent || parent._shouldRefine);\n      const stoppedRefining = !shouldRefine;\n\n      if (!tile.hasRenderContent) {\n        this.emptyTiles[tile.id] = tile;\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n        // additive tiles\n      } else if (tile.refine === TILE_REFINEMENT.ADD) {\n        // Additive tiles are always loaded and selected\n        this.loadTile(tile, frameState);\n        this.selectTile(tile, frameState);\n\n        // replace tiles\n      } else if (tile.refine === TILE_REFINEMENT.REPLACE) {\n        // Always load tiles in the base traversal\n        // Select tiles that can't refine further\n        this.loadTile(tile, frameState);\n        if (stoppedRefining) {\n          this.selectTile(tile, frameState);\n        }\n      }\n\n      // 3. update cache, most recent touched tiles have higher priority to be fetched from server\n      this.touchTile(tile, frameState);\n\n      // 4. update tile refine prop and parent refinement status to trickle down to the descendants\n      tile._shouldRefine = shouldRefine && parentRefines;\n    }\n\n    const newTime = new Date().getTime();\n    if (this.traversalFinished(frameState) || newTime - this.lastUpdate > this.updateDebounceTime) {\n      this.lastUpdate = newTime;\n      this.options.onTraversalEnd(frameState);\n    }\n  }\n\n  updateChildTiles(tile, frameState) {\n    const children = tile.children;\n    for (const child of children) {\n      this.updateTile(child, frameState);\n    }\n    return true;\n  }\n\n  /* eslint-disable complexity, max-statements */\n  updateAndPushChildren(tile, frameState, stack, depth) {\n    const {loadSiblings, skipLevelOfDetail} = this.options;\n\n    const children = tile.children;\n\n    // sort children tiles\n    children.sort(this.compareDistanceToCamera.bind(this));\n\n    // For traditional replacement refinement only refine if all children are loaded.\n    // Empty tiles are exempt since it looks better if children stream in as they are loaded to fill the empty space.\n    const checkRefines =\n      tile.refine === TILE_REFINEMENT.REPLACE && tile.hasRenderContent && !skipLevelOfDetail;\n\n    let hasVisibleChild = false;\n    let refines = true;\n\n    for (const child of children) {\n      child._selectionDepth = depth;\n      if (child.isVisibleAndInRequestVolume) {\n        if (stack.find(child)) {\n          stack.delete(child);\n        }\n        stack.push(child);\n        hasVisibleChild = true;\n      } else if (checkRefines || loadSiblings) {\n        // Keep non-visible children loaded since they are still needed before the parent can refine.\n        // Or loadSiblings is true so always load tiles regardless of visibility.\n        this.loadTile(child, frameState);\n        this.touchTile(child, frameState);\n      }\n\n      if (checkRefines) {\n        let childRefines;\n        if (!child._inRequestVolume) {\n          childRefines = false;\n        } else if (!child.hasRenderContent) {\n          childRefines = this.executeEmptyTraversal(child, frameState);\n        } else {\n          childRefines = child.contentAvailable;\n        }\n        refines = refines && childRefines;\n\n        if (!refines) {\n          return false;\n        }\n      }\n    }\n\n    if (!hasVisibleChild) {\n      refines = false;\n    }\n    return refines;\n  }\n  /* eslint-enable complexity, max-statements */\n\n  updateTile(tile, frameState) {\n    this.updateTileVisibility(tile, frameState);\n  }\n\n  // tile to render in the browser\n  selectTile(tile, frameState) {\n    if (this.shouldSelectTile(tile)) {\n      // The tile can be selected right away and does not require traverseAndSelect\n      tile._selectedFrame = frameState.frameNumber;\n      this.selectedTiles[tile.id] = tile;\n    }\n  }\n\n  // tile to load from server\n  loadTile(tile, frameState) {\n    if (this.shouldLoadTile(tile)) {\n      tile._requestedFrame = frameState.frameNumber;\n      tile._priority = tile._getPriority();\n      this.requestedTiles[tile.id] = tile;\n    }\n  }\n\n  // cache tile\n  touchTile(tile, frameState) {\n    tile.tileset._cache.touch(tile);\n    tile._touchedFrame = frameState.frameNumber;\n  }\n\n  // tile should be visible\n  // tile should have children\n  // tile LoD (level of detail) is not sufficient under current viewport\n  canTraverse(tile, frameState, useParentMetric = false, ignoreVisibility = false) {\n    if (!tile.hasChildren) {\n      return false;\n    }\n\n    // cesium specific\n    if (tile.hasTilesetContent) {\n      // Traverse external this to visit its root tile\n      // Don't traverse if the subtree is expired because it will be destroyed\n      return !tile.contentExpired;\n    }\n\n    if (!ignoreVisibility && !tile.isVisibleAndInRequestVolume) {\n      return false;\n    }\n\n    return this.shouldRefine(tile, frameState, useParentMetric);\n  }\n\n  shouldLoadTile(tile) {\n    // if request tile is in current frame\n    // and has unexpired render content\n    return tile.hasUnloadedContent || tile.contentExpired;\n  }\n\n  shouldSelectTile(tile) {\n    // if select tile is in current frame\n    // and content available\n    return tile.contentAvailable && !this.options.skipLevelOfDetail;\n  }\n\n  // Decide if tile LoD (level of detail) is not sufficient under current viewport\n  shouldRefine(tile, frameState, useParentMetric) {\n    let screenSpaceError = tile._screenSpaceError;\n    if (useParentMetric) {\n      screenSpaceError = tile.getScreenSpaceError(frameState, true);\n    }\n\n    return screenSpaceError > this.options.maximumScreenSpaceError;\n  }\n\n  updateTileVisibility(tile, frameState) {\n    const viewportIds: string[] = [];\n    if (this.options.viewportTraversersMap) {\n      for (const key in this.options.viewportTraversersMap) {\n        const value = this.options.viewportTraversersMap[key];\n        if (value === frameState.viewport.id) {\n          viewportIds.push(key);\n        }\n      }\n    } else {\n      viewportIds.push(frameState.viewport.id);\n    }\n    tile.updateVisibility(frameState, viewportIds);\n  }\n\n  // UTILITIES\n\n  compareDistanceToCamera(b, a) {\n    return b._distanceToCamera - a._distanceToCamera;\n  }\n\n  anyChildrenVisible(tile, frameState) {\n    let anyVisible = false;\n    for (const child of tile.children) {\n      child.updateVisibility(frameState);\n      anyVisible = anyVisible || child.isVisibleAndInRequestVolume;\n    }\n    return anyVisible;\n  }\n\n  // Depth-first traversal that checks if all nearest descendants with content are loaded.\n  // Ignores visibility.\n  executeEmptyTraversal(root, frameState) {\n    let allDescendantsLoaded = true;\n    const stack = this._emptyTraversalStack;\n\n    stack.push(root);\n\n    while (stack.length > 0 && allDescendantsLoaded) {\n      const tile = stack.pop();\n\n      this.updateTile(tile, frameState);\n\n      if (!tile.isVisibleAndInRequestVolume) {\n        // Load tiles that aren't visible since they are still needed for the parent to refine\n        this.loadTile(tile, frameState);\n      }\n\n      this.touchTile(tile, frameState);\n\n      // Only traverse if the tile is empty - traversal stop at descendants with content\n      const traverse = !tile.hasRenderContent && this.canTraverse(tile, frameState, false, true);\n\n      if (traverse) {\n        const children = tile.children;\n        for (const child of children) {\n          // eslint-disable-next-line max-depth\n          if (stack.find(child)) {\n            stack.delete(child);\n          }\n          stack.push(child);\n        }\n      } else if (!tile.contentAvailable) {\n        allDescendantsLoaded = false;\n      }\n    }\n\n    return allDescendantsLoaded;\n  }\n}\n\n// TODO\n// enable expiration\n// enable optimization hint\n", "// loaders.gl, MIT license\n\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix4} from '@math.gl/core';\nimport {CullingVolume} from '@math.gl/culling';\n\nimport {load} from '@loaders.gl/core';\n\n// Note: circular dependency\nimport type {Tileset3D} from './tileset-3d';\nimport {TILE_REFINEMENT, TILE_CONTENT_STATE, TILESET_TYPE} from '../constants';\n\nimport {FrameState} from './helpers/frame-state';\nimport {createBoundingVolume} from './helpers/bounding-volume';\nimport {getTiles3DScreenSpaceError} from './helpers/tiles-3d-lod';\nimport {getProjectedRadius} from './helpers/i3s-lod';\nimport {get3dTilesOptions} from './helpers/3d-tiles-options';\nimport {TilesetTraverser} from './tileset-traverser';\n\nconst scratchVector = new Vector3();\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\n/**\n * @param tileset - Tileset3D instance\n * @param header - tile header - JSON loaded from a dataset\n * @param parentHeader - parent Tile3D instance\n * @param extendedId - optional ID to separate copies of a tile for different viewports.\n *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;\n */\nexport type Tile3DProps = {\n  tileset: Tileset3D;\n  header: Object;\n  parentHeader: Tile3D;\n  extendedId: string;\n};\n\n/**\n * A Tile3DHeader represents a tile as Tileset3D. When a tile is first created, its content is not loaded;\n * the content is loaded on-demand when needed based on the view.\n * Do not construct this directly, instead access tiles through {@link Tileset3D#tileVisible}.\n */\nexport class Tile3D {\n  tileset: Tileset3D;\n  header: any;\n  id: string;\n  url: string;\n  parent: Tile3D;\n  refine: number;\n  type: string;\n  contentUrl: string;\n  lodMetricType: string;\n  lodMetricValue: number;\n  boundingVolume: any;\n  content: any;\n  contentState: any;\n  gpuMemoryUsageInBytes: number;\n  children: Tile3D[];\n  depth: number;\n  viewportIds: any[];\n  transform: Matrix4;\n  extensions: any;\n  implicitTiling?: any;\n\n  // Container to store application specific data\n  userData: {[key: string]: any};\n  computedTransform: any;\n  hasEmptyContent: boolean;\n  hasTilesetContent: boolean;\n\n  traverser: object;\n\n  // @ts-ignore\n  private _cacheNode: any;\n  private _frameNumber: any;\n  // TODO i3s specific, needs to remove\n  // @ts-ignore\n  private _lodJudge: any;\n  // TODO Cesium 3d tiles specific\n  private _expireDate: any;\n  private _expiredContent: any;\n  // @ts-ignore\n  private _shouldRefine: boolean;\n\n  // Members this are updated every frame for tree traversal and rendering optimizations:\n  public _distanceToCamera: number;\n  // @ts-ignore\n  private _centerZDepth: number;\n  private _screenSpaceError: number;\n  private _visibilityPlaneMask: any;\n  private _visible?: boolean;\n  private _inRequestVolume: boolean;\n\n  // @ts-ignore\n  private _stackLength: number;\n  // @ts-ignore\n  private _selectionDepth: number;\n\n  // @ts-ignore\n  private _touchedFrame: number;\n  // @ts-ignore\n  private _visitedFrame: number;\n  private _selectedFrame: number;\n  // @ts-ignore\n  private _requestedFrame: number;\n\n  // @ts-ignore\n  private _priority: number;\n\n  private _contentBoundingVolume: any;\n  private _viewerRequestVolume: any;\n\n  _initialTransform: Matrix4;\n\n  /**\n   * @constructs\n   * Create a Tile3D instance\n   * @param tileset - Tileset3D instance\n   * @param header - tile header - JSON loaded from a dataset\n   * @param parentHeader - parent Tile3D instance\n   * @param extendedId - optional ID to separate copies of a tile for different viewports.\n   *    const extendedId = `${tile.id}-${frameState.viewport.id}`;\n   */\n  // eslint-disable-next-line max-statements\n  constructor(\n    tileset: Tileset3D,\n    header: {[key: string]: any},\n    parentHeader?: Tile3D,\n    extendedId = ''\n  ) {\n    // PUBLIC MEMBERS\n    // original tile data\n    this.header = header;\n\n    // The tileset containing this tile.\n    this.tileset = tileset;\n    this.id = extendedId || header.id;\n    this.url = header.url;\n\n    // This tile's parent or `undefined` if this tile is the root.\n    // @ts-ignore\n    this.parent = parentHeader;\n    this.refine = this._getRefine(header.refine);\n    this.type = header.type;\n    this.contentUrl = header.contentUrl;\n\n    // The error, in meters, introduced if this tile is rendered and its children are not.\n    this.lodMetricType = 'geometricError';\n    this.lodMetricValue = 0;\n\n    // Specifies the type of refine that is used when traversing this tile for rendering.\n    this.boundingVolume = null;\n\n    // The tile's content.  This represents the actual tile's payload,\n    // not the content's metadata in the tileset JSON file.\n    this.content = null;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n    this.gpuMemoryUsageInBytes = 0;\n\n    // The tile's children - an array of Tile3D objects.\n    this.children = [];\n\n    this.hasEmptyContent = false;\n    this.hasTilesetContent = false;\n\n    this.depth = 0;\n    this.viewportIds = [];\n\n    // Container to store application specific data\n    this.userData = {};\n    this.extensions = null;\n\n    // PRIVATE MEMBERS\n    this._priority = 0;\n    this._touchedFrame = 0;\n    this._visitedFrame = 0;\n    this._selectedFrame = 0;\n    this._requestedFrame = 0;\n    this._screenSpaceError = 0;\n\n    this._cacheNode = null;\n    this._frameNumber = null;\n    this._cacheNode = null;\n\n    this.traverser = new TilesetTraverser({});\n    this._shouldRefine = false;\n    this._distanceToCamera = 0;\n    this._centerZDepth = 0;\n    this._visible = undefined;\n    this._inRequestVolume = false;\n    this._stackLength = 0;\n    this._selectionDepth = 0;\n    this._initialTransform = new Matrix4();\n    this.transform = new Matrix4();\n\n    this._initializeLodMetric(header);\n    this._initializeTransforms(header);\n    this._initializeBoundingVolumes(header);\n    this._initializeContent(header);\n    this._initializeRenderingState(header);\n\n    // TODO i3s specific, needs to remove\n    this._lodJudge = null;\n\n    // TODO Cesium 3d tiles specific\n    this._expireDate = null;\n    this._expiredContent = null;\n    this.implicitTiling = null;\n\n    Object.seal(this);\n  }\n\n  destroy() {\n    this.header = null;\n  }\n\n  isDestroyed() {\n    return this.header === null;\n  }\n\n  get selected() {\n    return this._selectedFrame === this.tileset._frameNumber;\n  }\n\n  get isVisible() {\n    return this._visible;\n  }\n\n  get isVisibleAndInRequestVolume() {\n    return this._visible && this._inRequestVolume;\n  }\n\n  /** Returns true if tile is not an empty tile and not an external tileset */\n  get hasRenderContent() {\n    return !this.hasEmptyContent && !this.hasTilesetContent;\n  }\n\n  /** Returns true if tile has children */\n  get hasChildren() {\n    return this.children.length > 0 || (this.header.children && this.header.children.length > 0);\n  }\n\n  /**\n   * Determines if the tile's content is ready. This is automatically `true` for\n   * tiles with empty content.\n   */\n  get contentReady() {\n    return this.contentState === TILE_CONTENT_STATE.READY || this.hasEmptyContent;\n  }\n\n  /**\n   * Determines if the tile has available content to render.  `true` if the tile's\n   * content is ready or if it has expired content this renders while new content loads; otherwise,\n   */\n  get contentAvailable() {\n    return Boolean(\n      (this.contentReady && this.hasRenderContent) || (this._expiredContent && !this.contentFailed)\n    );\n  }\n\n  /** Returns true if tile has renderable content but it's unloaded */\n  get hasUnloadedContent() {\n    return this.hasRenderContent && this.contentUnloaded;\n  }\n\n  /**\n   * Determines if the tile's content has not be requested. `true` if tile's\n   * content has not be requested; otherwise, `false`.\n   */\n  get contentUnloaded() {\n    return this.contentState === TILE_CONTENT_STATE.UNLOADED;\n  }\n\n  /**\n   * Determines if the tile's content is expired. `true` if tile's\n   * content is expired; otherwise, `false`.\n   */\n  get contentExpired() {\n    return this.contentState === TILE_CONTENT_STATE.EXPIRED;\n  }\n\n  // Determines if the tile's content failed to load.  `true` if the tile's\n  // content failed to load; otherwise, `false`.\n  get contentFailed() {\n    return this.contentState === TILE_CONTENT_STATE.FAILED;\n  }\n\n  /**\n   * Distance from the tile's bounding volume center to the camera\n   */\n  get distanceToCamera(): number {\n    return this._distanceToCamera;\n  }\n\n  /**\n   * Screen space error for LOD selection\n   */\n  get screenSpaceError(): number {\n    return this._screenSpaceError;\n  }\n\n  /** Get the tile's screen space error. */\n  getScreenSpaceError(frameState, useParentLodMetric) {\n    switch (this.tileset.type) {\n      case TILESET_TYPE.I3S:\n        return getProjectedRadius(this, frameState);\n      case TILESET_TYPE.TILES3D:\n        return getTiles3DScreenSpaceError(this, frameState, useParentLodMetric);\n      default:\n        // eslint-disable-next-line\n        throw new Error('Unsupported tileset type');\n    }\n  }\n\n  /**\n   * Make tile unselected than means it won't be shown\n   * but it can be still loaded in memory\n   */\n  unselect(): void {\n    this._selectedFrame = 0;\n  }\n\n  /*\n   * If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.\n   * Tiles are prioritized by screen space error.\n   */\n  // eslint-disable-next-line complexity\n  _getPriority() {\n    const traverser = this.tileset._traverser;\n    const {skipLevelOfDetail} = traverser.options;\n\n    /*\n     * Tiles that are outside of the camera's frustum could be skipped if we are in 'ADD' mode\n     * or if we are using 'Skip Traversal' in 'REPLACE' mode.\n     * Otherewise, all 'touched' child tiles have to be loaded and displayed,\n     * this may include tiles that are outide of the camera frustum (so that we can hide the parent tile).\n     */\n    const maySkipTile = this.refine === TILE_REFINEMENT.ADD || skipLevelOfDetail;\n\n    // Check if any reason to abort\n    if (maySkipTile && !this.isVisible && this._visible !== undefined) {\n      return -1;\n    }\n    // Condition used in `cancelOutOfViewRequests` function in CesiumJS/Cesium3DTileset.js\n    if (this.tileset._frameNumber - this._touchedFrame >= 1) {\n      return -1;\n    }\n    if (this.contentState === TILE_CONTENT_STATE.UNLOADED) {\n      return -1;\n    }\n\n    // Based on the priority function `getPriorityReverseScreenSpaceError` in CesiumJS. Scheduling priority is based on the parent's screen space error when possible.\n    const parent = this.parent;\n    const useParentScreenSpaceError =\n      parent && (!maySkipTile || this._screenSpaceError === 0.0 || parent.hasTilesetContent);\n    const screenSpaceError = useParentScreenSpaceError\n      ? parent._screenSpaceError\n      : this._screenSpaceError;\n\n    const rootScreenSpaceError = traverser.root ? traverser.root._screenSpaceError : 0.0;\n\n    // Map higher SSE to lower values (e.g. root tile is highest priority)\n    return Math.max(rootScreenSpaceError - screenSpaceError, 0);\n  }\n\n  /**\n   *  Requests the tile's content.\n   * The request may not be made if the Request Scheduler can't prioritize it.\n   */\n  // eslint-disable-next-line max-statements, complexity\n  async loadContent(): Promise<boolean> {\n    if (this.hasEmptyContent) {\n      return false;\n    }\n\n    if (this.content) {\n      return true;\n    }\n\n    const expired = this.contentExpired;\n\n    if (expired) {\n      this._expireDate = null;\n    }\n\n    this.contentState = TILE_CONTENT_STATE.LOADING;\n\n    const requestToken = await this.tileset._requestScheduler.scheduleRequest(\n      this.id,\n      this._getPriority.bind(this)\n    );\n\n    if (!requestToken) {\n      // cancelled\n      this.contentState = TILE_CONTENT_STATE.UNLOADED;\n      return false;\n    }\n\n    try {\n      const contentUrl = this.tileset.getTileUrl(this.contentUrl);\n      // The content can be a binary tile ot a JSON tileset\n      const loader = this.tileset.loader;\n      const options = {\n        ...this.tileset.loadOptions,\n        [loader.id]: {\n          ...this.tileset.loadOptions[loader.id],\n          isTileset: this.type === 'json',\n          ...this._getLoaderSpecificOptions(loader.id)\n        }\n      };\n\n      this.content = await load(contentUrl, loader, options);\n\n      if (this.tileset.options.contentLoader) {\n        await this.tileset.options.contentLoader(this);\n      }\n\n      if (this._isTileset()) {\n        // Add tile headers for the nested tilset's subtree\n        // Async update of the tree should be fine since there would never be edits to the same node\n        // TODO - we need to capture the child tileset's URL\n        this.tileset._initializeTileHeaders(this.content, this);\n      }\n\n      this.contentState = TILE_CONTENT_STATE.READY;\n      this._onContentLoaded();\n      return true;\n    } catch (error) {\n      // Tile is unloaded before the content finishes loading\n      this.contentState = TILE_CONTENT_STATE.FAILED;\n      throw error;\n    } finally {\n      requestToken.done();\n    }\n  }\n\n  // Unloads the tile's content.\n  unloadContent() {\n    if (this.content && this.content.destroy) {\n      this.content.destroy();\n    }\n    this.content = null;\n    if (this.header.content && this.header.content.destroy) {\n      this.header.content.destroy();\n    }\n    this.header.content = null;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n    return true;\n  }\n\n  /**\n   * Update the tile's visibility\n   * @param {Object} frameState - frame state for tile culling\n   * @param {string[]} viewportIds - a list of viewport ids that show this tile\n   * @return {void}\n   */\n  updateVisibility(frameState, viewportIds) {\n    if (this._frameNumber === frameState.frameNumber) {\n      // Return early if visibility has already been checked during the traversal.\n      // The visibility may have already been checked if the cullWithChildrenBounds optimization is used.\n      return;\n    }\n\n    const parent = this.parent;\n    const parentVisibilityPlaneMask = parent\n      ? parent._visibilityPlaneMask\n      : CullingVolume.MASK_INDETERMINATE;\n\n    if (this.tileset._traverser.options.updateTransforms) {\n      const parentTransform = parent ? parent.computedTransform : this.tileset.modelMatrix;\n      this._updateTransform(parentTransform);\n    }\n\n    this._distanceToCamera = this.distanceToTile(frameState);\n    this._screenSpaceError = this.getScreenSpaceError(frameState, false);\n    this._visibilityPlaneMask = this.visibility(frameState, parentVisibilityPlaneMask); // Use parent's plane mask to speed up visibility test\n    this._visible = this._visibilityPlaneMask !== CullingVolume.MASK_OUTSIDE;\n    this._inRequestVolume = this.insideViewerRequestVolume(frameState);\n\n    this._frameNumber = frameState.frameNumber;\n    this.viewportIds = viewportIds;\n  }\n\n  // Determines whether the tile's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.\n  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.\n  visibility(frameState, parentVisibilityPlaneMask) {\n    const {cullingVolume} = frameState;\n    const {boundingVolume} = this;\n\n    // TODO Cesium specific - restore clippingPlanes\n    // const {clippingPlanes, clippingPlanesOriginMatrix} = tileset;\n    // if (clippingPlanes && clippingPlanes.enabled) {\n    //   const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n    //     boundingVolume,\n    //     clippingPlanesOriginMatrix\n    //   );\n    //   this._isClipped = intersection !== Intersect.INSIDE;\n    //   if (intersection === Intersect.OUTSIDE) {\n    //     return CullingVolume.MASK_OUTSIDE;\n    //   }\n    // }\n\n    // return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n    return cullingVolume.computeVisibilityWithPlaneMask(boundingVolume, parentVisibilityPlaneMask);\n  }\n\n  // Assuming the tile's bounding volume intersects the culling volume, determines\n  // whether the tile's content's bounding volume intersects the culling volume.\n  // @param {FrameState} frameState The frame state.\n  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.\n  contentVisibility() {\n    return true;\n\n    // TODO restore\n    /*\n    // Assumes the tile's bounding volume intersects the culling volume already, so\n    // just return Intersect.INSIDE if there is no content bounding volume.\n    if (!defined(this.contentBoundingVolume)) {\n      return Intersect.INSIDE;\n    }\n\n    if (this._visibilityPlaneMask === CullingVolume.MASK_INSIDE) {\n      // The tile's bounding volume is completely inside the culling volume so\n      // the content bounding volume must also be inside.\n      return Intersect.INSIDE;\n    }\n\n    // PERFORMANCE_IDEA: is it possible to burn less CPU on this test since we know the\n    // tile's (not the content's) bounding volume intersects the culling volume?\n    const cullingVolume = frameState.cullingVolume;\n    const boundingVolume = tile.contentBoundingVolume;\n\n    const tileset = this.tileset;\n    const clippingPlanes = tileset.clippingPlanes;\n    if (defined(clippingPlanes) && clippingPlanes.enabled) {\n      const intersection = clippingPlanes.computeIntersectionWithBoundingVolume(\n        boundingVolume,\n        tileset.clippingPlanesOriginMatrix\n      );\n      this._isClipped = intersection !== Intersect.INSIDE;\n      if (intersection === Intersect.OUTSIDE) {\n        return Intersect.OUTSIDE;\n      }\n    }\n\n    return cullingVolume.computeVisibility(boundingVolume);\n    */\n  }\n\n  /**\n   * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.\n   * @param frameState The frame state.\n   * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.\n   */\n  distanceToTile(frameState: FrameState): number {\n    const boundingVolume = this.boundingVolume;\n    return Math.sqrt(Math.max(boundingVolume.distanceSquaredTo(frameState.camera.position), 0));\n  }\n\n  /**\n   * Computes the tile's camera-space z-depth.\n   * @param frameState The frame state.\n   * @returns The distance, in meters.\n   */\n  cameraSpaceZDepth({camera}): number {\n    const boundingVolume = this.boundingVolume; // Gets the underlying OrientedBoundingBox or BoundingSphere\n    scratchVector.subVectors(boundingVolume.center, camera.position);\n    return camera.direction.dot(scratchVector);\n  }\n\n  /**\n   * Checks if the camera is inside the viewer request volume.\n   * @param {FrameState} frameState The frame state.\n   * @returns {Boolean} Whether the camera is inside the volume.\n   */\n  insideViewerRequestVolume(frameState: FrameState) {\n    const viewerRequestVolume = this._viewerRequestVolume;\n    return (\n      !viewerRequestVolume || viewerRequestVolume.distanceSquaredTo(frameState.camera.position) <= 0\n    );\n  }\n\n  // TODO Cesium specific\n\n  // Update whether the tile has expired.\n  updateExpiration() {\n    if (defined(this._expireDate) && this.contentReady && !this.hasEmptyContent) {\n      const now = Date.now();\n      // @ts-ignore Date.lessThan - replace with ms compare?\n      if (Date.lessThan(this._expireDate, now)) {\n        this.contentState = TILE_CONTENT_STATE.EXPIRED;\n        this._expiredContent = this.content;\n      }\n    }\n  }\n\n  get extras() {\n    return this.header.extras;\n  }\n\n  // INTERNAL METHODS\n\n  _initializeLodMetric(header) {\n    if ('lodMetricType' in header) {\n      this.lodMetricType = header.lodMetricType;\n    } else {\n      this.lodMetricType = (this.parent && this.parent.lodMetricType) || this.tileset.lodMetricType;\n      // eslint-disable-next-line\n      console.warn(`3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType`);\n    }\n\n    // This is used to compute screen space error, i.e., the error measured in pixels.\n    if ('lodMetricValue' in header) {\n      this.lodMetricValue = header.lodMetricValue;\n    } else {\n      this.lodMetricValue =\n        (this.parent && this.parent.lodMetricValue) || this.tileset.lodMetricValue;\n      // eslint-disable-next-line\n      console.warn(\n        '3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue'\n      );\n    }\n  }\n\n  _initializeTransforms(tileHeader) {\n    // The local transform of this tile.\n    this.transform = tileHeader.transform ? new Matrix4(tileHeader.transform) : new Matrix4();\n\n    const parent = this.parent;\n    const tileset = this.tileset;\n\n    const parentTransform =\n      parent && parent.computedTransform\n        ? parent.computedTransform.clone()\n        : tileset.modelMatrix.clone();\n    this.computedTransform = new Matrix4(parentTransform).multiplyRight(this.transform);\n\n    const parentInitialTransform =\n      parent && parent._initialTransform ? parent._initialTransform.clone() : new Matrix4();\n    this._initialTransform = new Matrix4(parentInitialTransform).multiplyRight(this.transform);\n  }\n\n  _initializeBoundingVolumes(tileHeader) {\n    this._contentBoundingVolume = null;\n    this._viewerRequestVolume = null;\n\n    this._updateBoundingVolume(tileHeader);\n  }\n\n  _initializeContent(tileHeader) {\n    // Empty tile by default\n    this.content = {_tileset: this.tileset, _tile: this};\n    this.hasEmptyContent = true;\n    this.contentState = TILE_CONTENT_STATE.UNLOADED;\n\n    // When `true`, the tile's content points to an external tileset.\n    // This is `false` until the tile's content is loaded.\n    this.hasTilesetContent = false;\n\n    if (tileHeader.contentUrl) {\n      this.content = null;\n      this.hasEmptyContent = false;\n    }\n  }\n\n  // TODO - remove anything not related to basic visibility detection\n  _initializeRenderingState(header) {\n    this.depth = header.level || (this.parent ? this.parent.depth + 1 : 0);\n    this._shouldRefine = false;\n\n    // Members this are updated every frame for tree traversal and rendering optimizations:\n    this._distanceToCamera = 0;\n    this._centerZDepth = 0;\n    this._screenSpaceError = 0;\n    this._visibilityPlaneMask = CullingVolume.MASK_INDETERMINATE;\n    this._visible = undefined;\n    this._inRequestVolume = false;\n\n    this._stackLength = 0;\n    this._selectionDepth = 0;\n\n    this._frameNumber = 0;\n    this._touchedFrame = 0;\n    this._visitedFrame = 0;\n    this._selectedFrame = 0;\n    this._requestedFrame = 0;\n\n    this._priority = 0.0;\n  }\n\n  _getRefine(refine) {\n    // Inherit from parent tile if omitted.\n    return refine || (this.parent && this.parent.refine) || TILE_REFINEMENT.REPLACE;\n  }\n\n  _isTileset() {\n    return this.contentUrl.indexOf('.json') !== -1;\n  }\n\n  _onContentLoaded() {\n    // Vector and Geometry tile rendering do not support the skip LOD optimization.\n    switch (this.content && this.content.type) {\n      case 'vctr':\n      case 'geom':\n        // @ts-ignore\n        this.tileset._traverser.disableSkipLevelOfDetail = true;\n        break;\n      default:\n    }\n\n    // The content may be tileset json\n    if (this._isTileset()) {\n      this.hasTilesetContent = true;\n    }\n  }\n\n  _updateBoundingVolume(header) {\n    // Update the bounding volumes\n    this.boundingVolume = createBoundingVolume(\n      header.boundingVolume,\n      this.computedTransform,\n      this.boundingVolume\n    );\n\n    const content = header.content;\n    if (!content) {\n      return;\n    }\n\n    // TODO Cesium specific\n    // Non-leaf tiles may have a content bounding-volume, which is a tight-fit bounding volume\n    // around only the features in the tile. This box is useful for culling for rendering,\n    // but not for culling for traversing the tree since it does not guarantee spatial coherence, i.e.,\n    // since it only bounds features in the tile, not the entire tile, children may be\n    // outside of this box.\n    if (content.boundingVolume) {\n      this._contentBoundingVolume = createBoundingVolume(\n        content.boundingVolume,\n        this.computedTransform,\n        this._contentBoundingVolume\n      );\n    }\n    if (header.viewerRequestVolume) {\n      this._viewerRequestVolume = createBoundingVolume(\n        header.viewerRequestVolume,\n        this.computedTransform,\n        this._viewerRequestVolume\n      );\n    }\n  }\n\n  // Update the tile's transform. The transform is applied to the tile's bounding volumes.\n  _updateTransform(parentTransform = new Matrix4()) {\n    const computedTransform = parentTransform.clone().multiplyRight(this.transform);\n    const didTransformChange = !computedTransform.equals(this.computedTransform);\n\n    if (!didTransformChange) {\n      return;\n    }\n\n    this.computedTransform = computedTransform;\n\n    this._updateBoundingVolume(this.header);\n  }\n\n  // Get options which are applicable only for the particular loader\n  _getLoaderSpecificOptions(loaderId) {\n    switch (loaderId) {\n      case 'i3s':\n        return {\n          ...this.tileset.options.i3s,\n          _tileOptions: {\n            attributeUrls: this.header.attributeUrls,\n            textureUrl: this.header.textureUrl,\n            textureFormat: this.header.textureFormat,\n            textureLoaderOptions: this.header.textureLoaderOptions,\n            materialDefinition: this.header.materialDefinition,\n            isDracoGeometry: this.header.isDracoGeometry,\n            mbs: this.header.mbs\n          },\n          _tilesetOptions: {\n            store: this.tileset.tileset.store,\n            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,\n            fields: this.tileset.tileset.fields\n          },\n          isTileHeader: false\n        };\n      case '3d-tiles':\n      case 'cesium-ion':\n      default:\n        return get3dTilesOptions(this.tileset.tileset);\n    }\n  }\n}\n", "// loaders.gl, MIT license\n\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {TILE3D_OPTIMIZATION_HINT, TILE_REFINEMENT} from '../../constants';\nimport {TilesetTraverser} from '../tileset-traverser';\n\nexport class Tileset3DTraverser extends TilesetTraverser {\n  compareDistanceToCamera(a, b) {\n    // Sort by farthest child first since this is going on a stack\n    return b._distanceToCamera === 0 && a._distanceToCamera === 0\n      ? b._centerZDepth - a._centerZDepth\n      : b._distanceToCamera - a._distanceToCamera;\n  }\n\n  updateTileVisibility(tile, frameState) {\n    super.updateTileVisibility(tile, frameState);\n\n    //  Optimization - if none of the tile's children are visible then this tile isn't visible\n    if (!tile.isVisibleAndInRequestVolume) {\n      return;\n    }\n\n    const hasChildren = tile.children.length > 0;\n    if (tile.hasTilesetContent && hasChildren) {\n      // Use the root tile's visibility instead of this tile's visibility.\n      // The root tile may be culled by the children bounds optimization in which\n      // case this tile should also be culled.\n      const firstChild = tile.children[0];\n      this.updateTileVisibility(firstChild, frameState);\n      tile._visible = firstChild._visible;\n      return;\n    }\n\n    if (this.meetsScreenSpaceErrorEarly(tile, frameState)) {\n      tile._visible = false;\n      return;\n    }\n\n    const replace = tile.refine === TILE_REFINEMENT.REPLACE;\n    const useOptimization =\n      tile._optimChildrenWithinParent === TILE3D_OPTIMIZATION_HINT.USE_OPTIMIZATION;\n    if (replace && useOptimization && hasChildren) {\n      if (!this.anyChildrenVisible(tile, frameState)) {\n        tile._visible = false;\n        return;\n      }\n    }\n  }\n\n  meetsScreenSpaceErrorEarly(tile, frameState) {\n    const {parent} = tile;\n    if (!parent || parent.hasTilesetContent || parent.refine !== TILE_REFINEMENT.ADD) {\n      return false;\n    }\n\n    // Use parent's geometric error with child's box to see if the tile already meet the SSE\n    return !this.shouldRefine(tile, frameState, true);\n  }\n}\n", "/**\n * Counter to register pending tile headers for the particular frameNumber\n * Until all tiles are loaded we won't call `onTraversalEnd` callback\n */\nexport class I3SPendingTilesRegister {\n  private frameNumberMap: Map<string, Map<number, number>> = new Map();\n\n  /**\n   * Register a new pending tile header for the particular frameNumber\n   * @param viewportId\n   * @param frameNumber\n   */\n  register(viewportId: string, frameNumber: number) {\n    const viewportMap = this.frameNumberMap.get(viewportId) || new Map();\n    const oldCount = viewportMap.get(frameNumber) || 0;\n    viewportMap.set(frameNumber, oldCount + 1);\n    this.frameNumberMap.set(viewportId, viewportMap);\n  }\n\n  /**\n   * Deregister a pending tile header for the particular frameNumber\n   * @param viewportId\n   * @param frameNumber\n   */\n  deregister(viewportId: string, frameNumber: number) {\n    const viewportMap = this.frameNumberMap.get(viewportId);\n    if (!viewportMap) {\n      return;\n    }\n    const oldCount = viewportMap.get(frameNumber) || 1;\n    viewportMap.set(frameNumber, oldCount - 1);\n  }\n\n  /**\n   * Check is there are no pending tile headers registered for the particular frameNumber\n   * @param viewportId\n   * @param frameNumber\n   * @returns\n   */\n  isZero(viewportId: string, frameNumber: number) {\n    const count = this.frameNumberMap.get(viewportId)?.get(frameNumber) || 0;\n    return count === 0;\n  }\n}\n", "import {FrameState} from '../helpers/frame-state';\nimport {I3SPendingTilesRegister} from './i3s-pending-tiles-register';\n\nconst STATUS = {\n  REQUESTED: 'REQUESTED',\n  COMPLETED: 'COMPLETED',\n  ERROR: 'ERROR'\n};\n\n// A helper class to manage tile metadata fetching\nexport class I3STileManager {\n  private _statusMap: object;\n  private pendingTilesRegister = new I3SPendingTilesRegister();\n\n  constructor() {\n    this._statusMap = {};\n  }\n\n  /**\n   * Add request to map\n   * @param request - node metadata request\n   * @param key - unique key\n   * @param callback - callback after request completed\n   * @param frameState - frameState data\n   */\n  add(request, key, callback, frameState: FrameState) {\n    if (!this._statusMap[key]) {\n      const {\n        frameNumber,\n        viewport: {id}\n      } = frameState;\n      this._statusMap[key] = {request, callback, key, frameState, status: STATUS.REQUESTED};\n      // Register pending request for the frameNumber\n      this.pendingTilesRegister.register(id, frameNumber);\n      request()\n        .then((data) => {\n          this._statusMap[key].status = STATUS.COMPLETED;\n          const {\n            frameNumber: actualFrameNumber,\n            viewport: {id}\n          } = this._statusMap[key].frameState;\n          // Deregister pending request for the frameNumber\n          this.pendingTilesRegister.deregister(id, actualFrameNumber);\n          this._statusMap[key].callback(data, frameState);\n        })\n        .catch((error) => {\n          this._statusMap[key].status = STATUS.ERROR;\n          const {\n            frameNumber: actualFrameNumber,\n            viewport: {id}\n          } = this._statusMap[key].frameState;\n          // Deregister pending request for the frameNumber\n          this.pendingTilesRegister.deregister(id, actualFrameNumber);\n          callback(error);\n        });\n    }\n  }\n\n  /**\n   * Update request if it is still actual for the new frameState\n   * @param key - unique key\n   * @param frameState - frameState data\n   */\n  update(key, frameState: FrameState) {\n    if (this._statusMap[key]) {\n      // Deregister pending request for the old frameNumber\n      const {\n        frameNumber,\n        viewport: {id}\n      } = this._statusMap[key].frameState;\n      this.pendingTilesRegister.deregister(id, frameNumber);\n\n      // Register pending request for the new frameNumber\n      const {\n        frameNumber: newFrameNumber,\n        viewport: {id: newViewportId}\n      } = frameState;\n      this.pendingTilesRegister.register(newViewportId, newFrameNumber);\n      this._statusMap[key].frameState = frameState;\n    }\n  }\n\n  /**\n   * Find request in the map\n   * @param key - unique key\n   * @returns\n   */\n  find(key) {\n    return this._statusMap[key];\n  }\n\n  /**\n   * Check it there are pending tile headers for the particular frameNumber\n   * @param viewportId\n   * @param frameNumber\n   * @returns\n   */\n  hasPendingTiles(viewportId: string, frameNumber: number): boolean {\n    return !this.pendingTilesRegister.isZero(viewportId, frameNumber);\n  }\n}\n", "import {load} from '@loaders.gl/core';\nimport {TilesetTraverser} from '../tileset-traverser';\n\nimport {getLodStatus} from '../helpers/i3s-lod';\nimport {Tile3D} from '../tile-3d';\nimport {I3STileManager} from './i3s-tile-manager';\nimport {FrameState} from '../helpers/frame-state';\n\nexport class I3STilesetTraverser extends TilesetTraverser {\n  private _tileManager: I3STileManager;\n\n  constructor(options) {\n    super(options);\n    this._tileManager = new I3STileManager();\n  }\n\n  /**\n   * Check if there are no penging tile header requests,\n   * that means the traversal is finished and we can call\n   * following-up callbacks.\n   */\n  traversalFinished(frameState: FrameState): boolean {\n    return !this._tileManager.hasPendingTiles(frameState.viewport.id, this._frameNumber || 0);\n  }\n\n  shouldRefine(tile, frameState: FrameState) {\n    tile._lodJudge = getLodStatus(tile, frameState);\n    return tile._lodJudge === 'DIG';\n  }\n\n  updateChildTiles(tile, frameState: FrameState): boolean {\n    const children = tile.header.children || [];\n    // children which are already fetched and constructed as Tile3D instances\n    const childTiles = tile.children;\n    const tileset = tile.tileset;\n\n    for (const child of children) {\n      const extendedId = `${child.id}-${frameState.viewport.id}`;\n      // if child tile is not fetched\n      const childTile = childTiles && childTiles.find((t) => t.id === extendedId);\n      if (!childTile) {\n        let request = () => this._loadTile(child.id, tileset);\n        const cachedRequest = this._tileManager.find(extendedId);\n        if (!cachedRequest) {\n          // eslint-disable-next-line max-depth\n          if (tileset.tileset.nodePages) {\n            request = () => tileset.tileset.nodePagesTile.formTileFromNodePages(child.id);\n          }\n          this._tileManager.add(\n            request,\n            extendedId,\n            (header) => this._onTileLoad(header, tile, extendedId),\n            frameState\n          );\n        } else {\n          // update frameNumber since it is still needed in current frame\n          this._tileManager.update(extendedId, frameState);\n        }\n      } else if (childTile) {\n        // if child tile is fetched and available\n        this.updateTile(childTile, frameState);\n      }\n    }\n    return false;\n  }\n\n  async _loadTile(nodeId, tileset) {\n    const {loader} = tileset;\n    const nodeUrl = tileset.getTileUrl(`${tileset.url}/nodes/${nodeId}`);\n    // load metadata\n    const options = {\n      ...tileset.loadOptions,\n      i3s: {\n        ...tileset.loadOptions.i3s,\n        isTileHeader: true\n      }\n    };\n\n    return await load(nodeUrl, loader, options);\n  }\n\n  /**\n   * The callback to init Tile3D instance after loading the tile JSON\n   * @param {Object} header - the tile JSON from a dataset\n   * @param {Tile3D} tile - the parent Tile3D instance\n   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.\n   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;\n   * @return {void}\n   */\n  _onTileLoad(header, tile, extendedId) {\n    // after child tile is fetched\n    const childTile = new Tile3D(tile.tileset, header, tile, extendedId);\n    tile.children.push(childTile);\n    const frameState = this._tileManager.find(childTile.id).frameState;\n    this.updateTile(childTile, frameState);\n\n    // after tile fetched, resume traversal if still in current update/traversal frame\n    if (\n      this._frameNumber === frameState.frameNumber &&\n      (this.traversalFinished(frameState) ||\n        new Date().getTime() - this.lastUpdate > this.updateDebounceTime)\n    ) {\n      this.executeTraversal(childTile, frameState);\n    }\n  }\n}\n", "// loaders.gl, MIT license\n\n// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/*\n\n  The Tileset loading and rendering flow is as below,\n  A rendered (i.e. deck.gl `Tile3DLayer`) triggers `tileset.update()` after a `tileset` is loaded\n  `tileset` starts traversing the tile tree and update `requestTiles` (tiles of which content need\n  to be fetched) and `selectedTiles` (tiles ready for rendering under the current viewport).\n  `Tile3DLayer` will update rendering based on `selectedTiles`.\n  `Tile3DLayer` also listens to `onTileLoad` callback and trigger another round of `update and then traversal`\n  when new tiles are loaded.\n\n  As I3S tileset have stored `tileHeader` file (metadata) and tile content files (geometry, texture, ...) separately.\n  During each traversal, it issues `tilHeader` requests if that `tileHeader` is not yet fetched,\n  after the tile header is fulfilled, it will resume the traversal starting from the tile just fetched (not root).\n\n  Tile3DLayer\n       |\n   await load(tileset)\n       |\n   tileset.update()\n       |                async load tileHeader\n   tileset.traverse() -------------------------- Queued\n       |        resume traversal after fetched  |\n       |----------------------------------------|\n       |\n       |                     async load tile content\n  tilset.requestedTiles  ----------------------------- RequestScheduler\n                                                              |\n  tilset.selectedTiles (ready for rendering)                  |\n       |         Listen to                                    |\n    Tile3DLayer ----------- onTileLoad  ----------------------|\n       |                         |   notify new tile is available\n    updateLayers                 |\n                        tileset.update // trigger another round of update\n*/\n\nimport {Matrix4, Vector3} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {Stats} from '@probe.gl/stats';\nimport {\n  RequestScheduler,\n  assert,\n  path,\n  LoaderWithParser,\n  LoaderOptions\n} from '@loaders.gl/loader-utils';\nimport {TilesetCache} from './tileset-cache';\nimport {calculateTransformProps} from './helpers/transform-utils';\nimport {FrameState, getFrameState, limitSelectedTiles} from './helpers/frame-state';\nimport {getZoomFromBoundingVolume, getZoomFromExtent, getZoomFromFullExtent} from './helpers/zoom';\nimport {Tile3D} from './tile-3d';\nimport {TILESET_TYPE} from '../constants';\nimport {GeospatialViewport, Viewport} from '../types';\n\nimport {TilesetTraverser} from './tileset-traverser';\n\n// TODO - these should be moved into their respective modules\nimport {Tileset3DTraverser} from './format-3d-tiles/tileset-3d-traverser';\nimport {I3STilesetTraverser} from './format-i3s/i3s-tileset-traverser';\n\nexport type Tileset3DProps = {\n  // loading\n  throttleRequests?: boolean;\n  maxRequests?: number;\n  loadOptions?: LoaderOptions;\n  loadTiles?: boolean;\n  basePath?: string;\n  maximumMemoryUsage?: number;\n  maximumTilesSelected?: number;\n  debounceTime?: number;\n\n  // Metadata\n  description?: string;\n  attributions?: string[];\n\n  // Transforms\n  ellipsoid?: object;\n  modelMatrix?: Matrix4;\n\n  // Traversal\n  maximumScreenSpaceError?: number;\n  viewportTraversersMap?: any;\n  updateTransforms?: boolean;\n  viewDistanceScale?: number;\n\n  // Callbacks\n  onTileLoad?: (tile: Tile3D) => any;\n  onTileUnload?: (tile: Tile3D) => any;\n  onTileError?: (tile: Tile3D, message: string, url: string) => any;\n  contentLoader?: (tile: Tile3D) => Promise<void>;\n  onTraversalComplete?: (selectedTiles: Tile3D[]) => Tile3D[];\n};\n\ntype Props = {\n  description: string;\n  ellipsoid: object;\n  modelMatrix: Matrix4;\n  throttleRequests: boolean;\n  maximumMemoryUsage: number;\n  maximumTilesSelected: number;\n  debounceTime: number;\n  onTileLoad: (tile: Tile3D) => any;\n  onTileUnload: (tile: Tile3D) => any;\n  onTileError: (tile: Tile3D, message: string, url: string) => any;\n  onTraversalComplete: (selectedTiles: Tile3D[]) => Tile3D[];\n  maximumScreenSpaceError: number;\n  viewportTraversersMap: any;\n  attributions: string[];\n  maxRequests: number;\n  loadTiles: boolean;\n  loadOptions: LoaderOptions;\n  updateTransforms: boolean;\n  viewDistanceScale: number;\n  basePath: string;\n  contentLoader?: (tile: Tile3D) => Promise<void>;\n  i3s: {[key: string]: any};\n};\n\nconst DEFAULT_PROPS: Props = {\n  description: '',\n\n  ellipsoid: Ellipsoid.WGS84,\n  // A 4x4 transformation matrix this transforms the entire tileset.\n  modelMatrix: new Matrix4(),\n\n  // Set to false to disable network request throttling\n  throttleRequests: true,\n\n  // Number of simultaneous requsts, if throttleRequests is true\n  maxRequests: 64,\n\n  maximumMemoryUsage: 32,\n  /** Maximum number limit of tiles selected for show. 0 means no limit */\n  maximumTilesSelected: 0,\n  /** Delay time before the tileset traversal. It prevents traversal requests spam.*/\n  debounceTime: 0,\n\n  /**\n   * Callback. Indicates this a tile's content was loaded\n   * @param tile {TileHeader}\n   */\n  onTileLoad: () => {},\n  /**\n   * Callback. Indicates this a tile's content was unloaded\n   * @param tile {TileHeader}\n   */\n  onTileUnload: () => {},\n  onTileError: () => {},\n  /**\n   * Callback. Allows post-process selectedTiles right after traversal.\n   * @param selectedTiles {TileHeader[]}\n   * @returns TileHeader[] - output array of tiles to return to deck.gl\n   */\n  onTraversalComplete: (selectedTiles: Tile3D[]) => selectedTiles,\n\n  // Optional async tile content loader\n  contentLoader: undefined,\n\n  // View distance scale modifier\n  viewDistanceScale: 1.0,\n\n  // The maximum screen space error used to drive level of detail refinement.\n  maximumScreenSpaceError: 8,\n\n  loadTiles: true,\n  updateTransforms: true,\n  viewportTraversersMap: null,\n\n  loadOptions: {fetch: {}},\n\n  attributions: [],\n  basePath: '',\n\n  i3s: {}\n};\n\n// Tracked Stats\nconst TILES_TOTAL = 'Tiles In Tileset(s)';\nconst TILES_IN_MEMORY = 'Tiles In Memory';\nconst TILES_IN_VIEW = 'Tiles In View';\nconst TILES_RENDERABLE = 'Tiles To Render';\nconst TILES_LOADED = 'Tiles Loaded';\nconst TILES_LOADING = 'Tiles Loading';\nconst TILES_UNLOADED = 'Tiles Unloaded';\nconst TILES_LOAD_FAILED = 'Failed Tile Loads';\nconst POINTS_COUNT = 'Points/Vertices';\nconst TILES_GPU_MEMORY = 'Tile Memory Use';\n\nexport class Tileset3D {\n  // props: Tileset3DProps;\n  options: Props;\n  loadOptions: {[key: string]: any};\n\n  type: string;\n  tileset: {[key: string]: any};\n  loader: LoaderWithParser;\n  url: string;\n  basePath: string;\n  modelMatrix: Matrix4;\n  ellipsoid: any;\n  lodMetricType: string;\n  lodMetricValue: number;\n  refine: string;\n  root: Tile3D | null;\n  roots: {[key: string]: Tile3D};\n  asset: {[key: string]: any};\n\n  description: string;\n  properties: any;\n  extras: any;\n  attributions: any;\n  credits: any;\n\n  stats: Stats;\n\n  /** flags that contain information about data types in nested tiles */\n  contentFormats = {draco: false, meshopt: false, dds: false, ktx2: false};\n\n  traverseCounter: number;\n  geometricError: number;\n  selectedTiles: Tile3D[];\n  private updatePromise: Promise<number> | null = null;\n  tilesetInitializationPromise: Promise<void>;\n\n  cartographicCenter: Vector3 | null;\n  cartesianCenter: Vector3 | null;\n  zoom: number;\n  boundingVolume: any;\n\n  // METRICS\n  // The maximum amount of GPU memory (in MB) that may be used to cache tiles.\n  // Tiles not in view are unloaded to enforce private\n  // The total amount of GPU memory in bytes used by the tileset.\n  gpuMemoryUsageInBytes: any;\n  dynamicScreenSpaceErrorComputedDensity: any;\n\n  // TRAVERSAL\n  _traverser: TilesetTraverser;\n  private _cache: TilesetCache;\n  _requestScheduler: RequestScheduler;\n\n  _frameNumber: number;\n  private _queryParamsString: string;\n  private _queryParams: any;\n  private _extensionsUsed: any;\n  private _tiles: {[id: string]: Tile3D};\n\n  // counter for tracking tiles requests\n  private _pendingCount: any;\n\n  // HOLD TRAVERSAL RESULTS\n  private lastUpdatedVieports: Viewport[] | Viewport | null;\n  private _requestedTiles: any;\n  private _emptyTiles: any;\n  private frameStateData: any;\n\n  maximumMemoryUsage: number;\n\n  /**\n   * Create a new Tileset3D\n   * @param json\n   * @param props\n   */\n  // eslint-disable-next-line max-statements\n  constructor(json: any, options?: Tileset3DProps) {\n    assert(json);\n\n    // PUBLIC MEMBERS\n    this.options = {...DEFAULT_PROPS, ...options};\n    // raw data\n    this.tileset = json;\n    this.loader = json.loader;\n    // could be  3d tiles, i3s\n    this.type = json.type;\n    // The url to a tileset JSON file.\n    this.url = json.url;\n    this.basePath = json.basePath || path.dirname(this.url);\n    this.modelMatrix = this.options.modelMatrix;\n    this.ellipsoid = this.options.ellipsoid;\n\n    // Geometric error when the tree is not rendered at all\n    this.lodMetricType = json.lodMetricType;\n    this.lodMetricValue = json.lodMetricValue;\n    this.refine = json.root.refine;\n\n    this.loadOptions = this.options.loadOptions || {};\n\n    this.root = null;\n    this.roots = {};\n    // view props\n    this.cartographicCenter = null;\n    this.cartesianCenter = null;\n    this.zoom = 1;\n    this.boundingVolume = null;\n\n    // TRAVERSAL\n    this.traverseCounter = 0;\n    this.geometricError = 0;\n    this._traverser = this._initializeTraverser();\n    this._cache = new TilesetCache();\n    this._requestScheduler = new RequestScheduler({\n      throttleRequests: this.options.throttleRequests,\n      maxRequests: this.options.maxRequests\n    });\n    // update tracker\n    // increase in each update cycle\n    this._frameNumber = 0;\n\n    // counter for tracking tiles requests\n    this._pendingCount = 0;\n\n    // HOLD TRAVERSAL RESULTS\n    this._tiles = {};\n    this.selectedTiles = [];\n    this._emptyTiles = [];\n    this._requestedTiles = [];\n    this.frameStateData = {};\n    this.lastUpdatedVieports = null;\n\n    this._queryParams = {};\n    this._queryParamsString = '';\n\n    // METRICS\n    // The maximum amount of GPU memory (in MB) that may be used to cache tiles.\n    // Tiles not in view are unloaded to enforce this.\n    this.maximumMemoryUsage = this.options.maximumMemoryUsage || 32;\n    // The total amount of GPU memory in bytes used by the tileset.\n    this.gpuMemoryUsageInBytes = 0;\n    this.stats = new Stats({id: this.url});\n    this._initializeStats();\n\n    // EXTRACTED FROM TILESET\n    this._extensionsUsed = undefined;\n    this.dynamicScreenSpaceErrorComputedDensity = 0.0; // Updated based on the camera position and direction\n    // Metadata for the entire tileset\n    this.extras = null;\n    this.asset = {};\n    this.credits = {};\n    this.description = this.options.description || '';\n\n    this.tilesetInitializationPromise = this._initializeTileSet(json);\n  }\n\n  /** Release resources */\n  destroy(): void {\n    this._destroy();\n  }\n\n  /** Is the tileset loaded (update needs to have been called at least once) */\n  isLoaded(): boolean {\n    // Check that `_frameNumber !== 0` which means that update was called at least once\n    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;\n  }\n\n  get tiles(): object[] {\n    return Object.values(this._tiles);\n  }\n\n  get frameNumber(): number {\n    return this._frameNumber;\n  }\n\n  get queryParams(): string {\n    if (!this._queryParamsString) {\n      this._queryParamsString = getQueryParamString(this._queryParams);\n    }\n    return this._queryParamsString;\n  }\n\n  setProps(props: Tileset3DProps): void {\n    this.options = {...this.options, ...props};\n  }\n\n  /** @deprecated */\n  setOptions(options: Tileset3DProps): void {\n    this.options = {...this.options, ...options};\n  }\n\n  /**\n   * Return a loadable tile url for a specific tile subpath\n   * @param tilePath a tile subpath\n   */\n  getTileUrl(tilePath: string): string {\n    const isDataUrl = tilePath.startsWith('data:');\n    if (isDataUrl) {\n      return tilePath;\n    }\n    return `${tilePath}${this.queryParams}`;\n  }\n\n  // TODO CESIUM specific\n  hasExtension(extensionName: string): boolean {\n    return Boolean(this._extensionsUsed && this._extensionsUsed.indexOf(extensionName) > -1);\n  }\n\n  /**\n   * Update visible tiles relying on a list of viewports\n   * @param viewports - list of viewports\n   * @deprecated\n   */\n  update(viewports: Viewport[] | Viewport | null = null) {\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.tilesetInitializationPromise.then(() => {\n      if (!viewports && this.lastUpdatedVieports) {\n        viewports = this.lastUpdatedVieports;\n      } else {\n        this.lastUpdatedVieports = viewports;\n      }\n      if (viewports) {\n        this.doUpdate(viewports);\n      }\n    });\n  }\n\n  /**\n   * Update visible tiles relying on a list of viewports.\n   * Do it with debounce delay to prevent update spam\n   * @param viewports viewports\n   * @returns Promise of new frameNumber\n   */\n  async selectTiles(viewports: Viewport[] | Viewport | null = null): Promise<number> {\n    await this.tilesetInitializationPromise;\n    if (viewports) {\n      this.lastUpdatedVieports = viewports;\n    }\n    if (!this.updatePromise) {\n      this.updatePromise = new Promise<number>((resolve) => {\n        setTimeout(() => {\n          if (this.lastUpdatedVieports) {\n            this.doUpdate(this.lastUpdatedVieports);\n          }\n          resolve(this._frameNumber);\n          this.updatePromise = null;\n        }, this.options.debounceTime);\n      });\n    }\n    return this.updatePromise;\n  }\n\n  /**\n   * Update visible tiles relying on a list of viewports\n   * @param viewports viewports\n   */\n  // eslint-disable-next-line max-statements, complexity\n  private doUpdate(viewports: Viewport[] | Viewport): void {\n    if ('loadTiles' in this.options && !this.options.loadTiles) {\n      return;\n    }\n    if (this.traverseCounter > 0) {\n      return;\n    }\n    const preparedViewports = viewports instanceof Array ? viewports : [viewports];\n\n    this._cache.reset();\n    this._frameNumber++;\n    this.traverseCounter = preparedViewports.length;\n    const viewportsToTraverse: string[] = [];\n    // First loop to decrement traverseCounter\n    for (const viewport of preparedViewports) {\n      const id = viewport.id;\n      if (this._needTraverse(id)) {\n        viewportsToTraverse.push(id);\n      } else {\n        this.traverseCounter--;\n      }\n    }\n\n    // Second loop to traverse\n    for (const viewport of preparedViewports) {\n      const id = viewport.id;\n      if (!this.roots[id]) {\n        this.roots[id] = this._initializeTileHeaders(this.tileset, null);\n      }\n\n      if (!viewportsToTraverse.includes(id)) {\n        continue; // eslint-disable-line no-continue\n      }\n      const frameState = getFrameState(viewport as GeospatialViewport, this._frameNumber);\n      this._traverser.traverse(this.roots[id], frameState, this.options);\n    }\n  }\n\n  /**\n   * Check if traversal is needed for particular viewport\n   * @param {string} viewportId - id of a viewport\n   * @return {boolean}\n   */\n  _needTraverse(viewportId: string): boolean {\n    let traverserId = viewportId;\n    if (this.options.viewportTraversersMap) {\n      traverserId = this.options.viewportTraversersMap[viewportId];\n    }\n    if (traverserId !== viewportId) {\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * The callback to post-process tiles after traversal procedure\n   * @param frameState - frame state for tile culling\n   */\n  _onTraversalEnd(frameState: FrameState): void {\n    const id = frameState.viewport.id;\n    if (!this.frameStateData[id]) {\n      this.frameStateData[id] = {selectedTiles: [], _requestedTiles: [], _emptyTiles: []};\n    }\n    const currentFrameStateData = this.frameStateData[id];\n    const selectedTiles = Object.values(this._traverser.selectedTiles);\n    const [filteredSelectedTiles, unselectedTiles] = limitSelectedTiles(\n      selectedTiles,\n      frameState,\n      this.options.maximumTilesSelected\n    );\n    currentFrameStateData.selectedTiles = filteredSelectedTiles;\n    for (const tile of unselectedTiles) {\n      tile.unselect();\n    }\n\n    currentFrameStateData._requestedTiles = Object.values(this._traverser.requestedTiles);\n    currentFrameStateData._emptyTiles = Object.values(this._traverser.emptyTiles);\n\n    this.traverseCounter--;\n    if (this.traverseCounter > 0) {\n      return;\n    }\n\n    this._updateTiles();\n  }\n\n  /**\n   * Update tiles relying on data from all traversers\n   */\n  _updateTiles(): void {\n    this.selectedTiles = [];\n    this._requestedTiles = [];\n    this._emptyTiles = [];\n\n    for (const frameStateKey in this.frameStateData) {\n      const frameStateDataValue = this.frameStateData[frameStateKey];\n      this.selectedTiles = this.selectedTiles.concat(frameStateDataValue.selectedTiles);\n      this._requestedTiles = this._requestedTiles.concat(frameStateDataValue._requestedTiles);\n      this._emptyTiles = this._emptyTiles.concat(frameStateDataValue._emptyTiles);\n    }\n\n    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);\n\n    for (const tile of this.selectedTiles) {\n      this._tiles[tile.id] = tile;\n    }\n\n    this._loadTiles();\n    this._unloadTiles();\n    this._updateStats();\n  }\n\n  _tilesChanged(oldSelectedTiles, selectedTiles) {\n    if (oldSelectedTiles.length !== selectedTiles.length) {\n      return true;\n    }\n    const set1 = new Set(oldSelectedTiles.map((t) => t.id));\n    const set2 = new Set(selectedTiles.map((t) => t.id));\n    let changed = oldSelectedTiles.filter((x) => !set2.has(x.id)).length > 0;\n    changed = changed || selectedTiles.filter((x) => !set1.has(x.id)).length > 0;\n    return changed;\n  }\n\n  _loadTiles() {\n    // Sort requests by priority before making any requests.\n    // This makes it less likely this requests will be cancelled after being issued.\n    // requestedTiles.sort((a, b) => a._priority - b._priority);\n    for (const tile of this._requestedTiles) {\n      if (tile.contentUnloaded) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this._loadTile(tile);\n      }\n    }\n  }\n\n  _unloadTiles() {\n    // unload tiles from cache when hit maximumMemoryUsage\n    this._cache.unloadTiles(this, (tileset, tile) => tileset._unloadTile(tile));\n  }\n\n  _updateStats() {\n    let tilesRenderable = 0;\n    let pointsRenderable = 0;\n    for (const tile of this.selectedTiles) {\n      if (tile.contentAvailable && tile.content) {\n        tilesRenderable++;\n        if (tile.content.pointCount) {\n          pointsRenderable += tile.content.pointCount;\n        } else {\n          // Calculate vertices for non point cloud tiles.\n          pointsRenderable += tile.content.vertexCount;\n        }\n      }\n    }\n\n    this.stats.get(TILES_IN_VIEW).count = this.selectedTiles.length;\n    this.stats.get(TILES_RENDERABLE).count = tilesRenderable;\n    this.stats.get(POINTS_COUNT).count = pointsRenderable;\n  }\n\n  async _initializeTileSet(tilesetJson) {\n    if (this.type === TILESET_TYPE.I3S) {\n      this.calculateViewPropsI3S();\n      tilesetJson.root = await tilesetJson.root;\n    }\n    this.root = this._initializeTileHeaders(tilesetJson, null);\n\n    if (this.type === TILESET_TYPE.TILES3D) {\n      this._initializeTiles3DTileset(tilesetJson);\n      this.calculateViewPropsTiles3D();\n    }\n\n    if (this.type === TILESET_TYPE.I3S) {\n      this._initializeI3STileset();\n    }\n  }\n\n  /**\n   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.\n   * These metrics help apps center view on tileset\n   * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props\n   * @returns\n   */\n  private calculateViewPropsI3S() {\n    // for I3S 1.8 try to calculate with fullExtent\n    const fullExtent = this.tileset.fullExtent;\n    if (fullExtent) {\n      const {xmin, xmax, ymin, ymax, zmin, zmax} = fullExtent;\n      this.cartographicCenter = new Vector3(\n        xmin + (xmax - xmin) / 2,\n        ymin + (ymax - ymin) / 2,\n        zmin + (zmax - zmin) / 2\n      );\n      this.cartesianCenter = Ellipsoid.WGS84.cartographicToCartesian(\n        this.cartographicCenter,\n        new Vector3()\n      );\n      this.zoom = getZoomFromFullExtent(fullExtent, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n    // for I3S 1.6-1.7 try to calculate with extent\n    const extent = this.tileset.store?.extent;\n    if (extent) {\n      const [xmin, ymin, xmax, ymax] = extent;\n      this.cartographicCenter = new Vector3(xmin + (xmax - xmin) / 2, ymin + (ymax - ymin) / 2, 0);\n      this.cartesianCenter = Ellipsoid.WGS84.cartographicToCartesian(\n        this.cartographicCenter,\n        new Vector3()\n      );\n      this.zoom = getZoomFromExtent(extent, this.cartographicCenter, this.cartesianCenter);\n      return;\n    }\n    // eslint-disable-next-line no-console\n    console.warn('Extent is not defined in the tileset header');\n    this.cartographicCenter = new Vector3();\n    this.zoom = 1;\n    return;\n  }\n\n  /**\n   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.\n   * These metrics help apps center view on tileset.\n   * For 3DTiles the root tile data is used to calculate view props.\n   * @returns\n   */\n  private calculateViewPropsTiles3D() {\n    const root = this.root as Tile3D;\n    assert(root);\n    const {center} = root.boundingVolume;\n    // TODO - handle all cases\n    if (!center) {\n      // eslint-disable-next-line no-console\n      console.warn('center was not pre-calculated for the root tile');\n      this.cartographicCenter = new Vector3();\n      this.zoom = 1;\n      return;\n    }\n\n    // cartographic coordinates are undefined at the center of the ellipsoid\n    if (center[0] !== 0 || center[1] !== 0 || center[2] !== 0) {\n      this.cartographicCenter = Ellipsoid.WGS84.cartesianToCartographic(center, new Vector3());\n    } else {\n      this.cartographicCenter = new Vector3(0, 0, -Ellipsoid.WGS84.radii[0]);\n    }\n    this.cartesianCenter = center;\n    this.zoom = getZoomFromBoundingVolume(root.boundingVolume, this.cartographicCenter);\n  }\n\n  _initializeStats() {\n    this.stats.get(TILES_TOTAL);\n    this.stats.get(TILES_LOADING);\n    this.stats.get(TILES_IN_MEMORY);\n    this.stats.get(TILES_IN_VIEW);\n    this.stats.get(TILES_RENDERABLE);\n    this.stats.get(TILES_LOADED);\n    this.stats.get(TILES_UNLOADED);\n    this.stats.get(TILES_LOAD_FAILED);\n    this.stats.get(POINTS_COUNT);\n    this.stats.get(TILES_GPU_MEMORY, 'memory');\n  }\n\n  // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.\n  // eslint-disable-next-line max-statements\n  _initializeTileHeaders(tilesetJson, parentTileHeader) {\n    // A tileset JSON file referenced from a tile may exist in a different directory than the root tileset.\n    // Get the basePath relative to the external tileset.\n    const rootTile = new Tile3D(this, tilesetJson.root, parentTileHeader); // resource\n\n    // If there is a parentTileHeader, add the root of the currently loading tileset\n    // to parentTileHeader's children, and update its depth.\n    if (parentTileHeader) {\n      parentTileHeader.children.push(rootTile);\n      rootTile.depth = parentTileHeader.depth + 1;\n    }\n\n    // 3DTiles knows the hierarchy beforehand\n    if (this.type === TILESET_TYPE.TILES3D) {\n      const stack: Tile3D[] = [];\n      stack.push(rootTile);\n\n      while (stack.length > 0) {\n        const tile = stack.pop() as Tile3D;\n        this.stats.get(TILES_TOTAL).incrementCount();\n        const children = tile.header.children || [];\n        for (const childHeader of children) {\n          const childTile = new Tile3D(this, childHeader, tile);\n          tile.children.push(childTile);\n          childTile.depth = tile.depth + 1;\n          stack.push(childTile);\n        }\n      }\n    }\n\n    return rootTile;\n  }\n\n  _initializeTraverser() {\n    let TraverserClass;\n    const type = this.type;\n    switch (type) {\n      case TILESET_TYPE.TILES3D:\n        TraverserClass = Tileset3DTraverser;\n        break;\n      case TILESET_TYPE.I3S:\n        TraverserClass = I3STilesetTraverser;\n        break;\n      default:\n        TraverserClass = TilesetTraverser;\n    }\n\n    return new TraverserClass({\n      basePath: this.basePath,\n      onTraversalEnd: this._onTraversalEnd.bind(this)\n    });\n  }\n\n  _destroyTileHeaders(parentTile) {\n    this._destroySubtree(parentTile);\n  }\n\n  async _loadTile(tile) {\n    let loaded;\n    try {\n      this._onStartTileLoading();\n      loaded = await tile.loadContent();\n    } catch (error) {\n      this._onTileLoadError(tile, error);\n    } finally {\n      this._onEndTileLoading();\n      this._onTileLoad(tile, loaded);\n    }\n  }\n\n  _onTileLoadError(tile, error) {\n    this.stats.get(TILES_LOAD_FAILED).incrementCount();\n\n    const message = error.message || error.toString();\n    const url = tile.url;\n    // TODO - Allow for probe log to be injected instead of console?\n    console.error(`A 3D tile failed to load: ${tile.url} ${message}`); // eslint-disable-line\n    this.options.onTileError(tile, message, url);\n  }\n\n  _onTileLoad(tile, loaded) {\n    if (!loaded) {\n      return;\n    }\n\n    if (this.type === TILESET_TYPE.I3S) {\n      // We can't calculate tiles total in I3S in advance so we calculate it dynamically.\n      const nodesInNodePages = this.tileset?.nodePagesTile?.nodesInNodePages || 0;\n      this.stats.get(TILES_TOTAL).reset();\n      this.stats.get(TILES_TOTAL).addCount(nodesInNodePages);\n    }\n\n    // add coordinateOrigin and modelMatrix to tile\n    if (tile && tile.content) {\n      calculateTransformProps(tile, tile.content);\n    }\n\n    this.updateContentTypes(tile);\n    this._addTileToCache(tile);\n    this.options.onTileLoad(tile);\n  }\n\n  /**\n   * Update information about data types in nested tiles\n   * @param tile instance of a nested Tile3D\n   */\n  private updateContentTypes(tile: Tile3D) {\n    if (this.type === TILESET_TYPE.I3S) {\n      if (tile.header.isDracoGeometry) {\n        this.contentFormats.draco = true;\n      }\n      switch (tile.header.textureFormat) {\n        case 'dds':\n          this.contentFormats.dds = true;\n          break;\n        case 'ktx2':\n          this.contentFormats.ktx2 = true;\n          break;\n        default:\n      }\n    } else if (this.type === TILESET_TYPE.TILES3D) {\n      const {extensionsRemoved = []} = tile.content?.gltf || {};\n      if (extensionsRemoved.includes('KHR_draco_mesh_compression')) {\n        this.contentFormats.draco = true;\n      }\n      if (extensionsRemoved.includes('EXT_meshopt_compression')) {\n        this.contentFormats.meshopt = true;\n      }\n      if (extensionsRemoved.includes('KHR_texture_basisu')) {\n        this.contentFormats.ktx2 = true;\n      }\n    }\n  }\n\n  _onStartTileLoading() {\n    this._pendingCount++;\n    this.stats.get(TILES_LOADING).incrementCount();\n  }\n\n  _onEndTileLoading() {\n    this._pendingCount--;\n    this.stats.get(TILES_LOADING).decrementCount();\n  }\n\n  _addTileToCache(tile) {\n    this._cache.add(this, tile, (tileset) => tileset._updateCacheStats(tile));\n  }\n\n  _updateCacheStats(tile) {\n    this.stats.get(TILES_LOADED).incrementCount();\n    this.stats.get(TILES_IN_MEMORY).incrementCount();\n\n    // Good enough? Just use the raw binary ArrayBuffer's byte length.\n    this.gpuMemoryUsageInBytes += tile.content.byteLength || 0;\n    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n  }\n\n  _unloadTile(tile) {\n    this.gpuMemoryUsageInBytes -= (tile.content && tile.content.byteLength) || 0;\n\n    this.stats.get(TILES_IN_MEMORY).decrementCount();\n    this.stats.get(TILES_UNLOADED).incrementCount();\n    this.stats.get(TILES_GPU_MEMORY).count = this.gpuMemoryUsageInBytes;\n\n    this.options.onTileUnload(tile);\n    tile.unloadContent();\n  }\n\n  // Traverse the tree and destroy all tiles\n  _destroy() {\n    const stack: Tile3D[] = [];\n\n    if (this.root) {\n      stack.push(this.root);\n    }\n\n    while (stack.length > 0) {\n      const tile: Tile3D = stack.pop() as Tile3D;\n\n      for (const child of tile.children) {\n        stack.push(child);\n      }\n\n      this._destroyTile(tile);\n    }\n    this.root = null;\n  }\n\n  // Traverse the tree and destroy all sub tiles\n  _destroySubtree(tile) {\n    const root = tile;\n    const stack: Tile3D[] = [];\n    stack.push(root);\n    while (stack.length > 0) {\n      tile = stack.pop();\n      for (const child of tile.children) {\n        stack.push(child);\n      }\n      if (tile !== root) {\n        this._destroyTile(tile);\n      }\n    }\n    root.children = [];\n  }\n\n  _destroyTile(tile) {\n    this._cache.unloadTile(this, tile);\n    this._unloadTile(tile);\n    tile.destroy();\n  }\n\n  _initializeTiles3DTileset(tilesetJson) {\n    this.asset = tilesetJson.asset;\n    if (!this.asset) {\n      throw new Error('Tileset must have an asset property.');\n    }\n    if (this.asset.version !== '0.0' && this.asset.version !== '1.0') {\n      throw new Error('The tileset must be 3D Tiles version 0.0 or 1.0.');\n    }\n\n    // Note: `asset.tilesetVersion` is version of the tileset itself (not the version of the 3D TILES standard)\n    // We add this version as a `v=1.0` query param to fetch the right version and not get an older cached version\n    if ('tilesetVersion' in this.asset) {\n      this._queryParams.v = this.asset.tilesetVersion;\n    }\n\n    // TODO - ion resources have a credits property we can use for additional attribution.\n    this.credits = {\n      attributions: this.options.attributions || []\n    };\n    this.description = this.options.description || '';\n\n    // Gets the tileset's properties dictionary object, which contains metadata about per-feature properties.\n    this.properties = tilesetJson.properties;\n    this.geometricError = tilesetJson.geometricError;\n    this._extensionsUsed = tilesetJson.extensionsUsed;\n    // Returns the extras property at the top of the tileset JSON (application specific metadata).\n    this.extras = tilesetJson.extras;\n  }\n\n  _initializeI3STileset() {\n    if (this.loadOptions.i3s && 'token' in this.loadOptions.i3s) {\n      this._queryParams.token = this.loadOptions.i3s.token;\n    }\n  }\n}\n\nfunction getQueryParamString(queryParams): string {\n  const queryParamStrings: string[] = [];\n  for (const key of Object.keys(queryParams)) {\n    queryParamStrings.push(`${key}=${queryParams[key]}`);\n  }\n  switch (queryParamStrings.length) {\n    case 0:\n      return '';\n    case 1:\n      return `?${queryParamStrings[0]}`;\n    default:\n      return `?${queryParamStrings.join('&')}`;\n  }\n}\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n", "// TILE TYPES\n\nexport const TILE3D_TYPE = {\n  COMPOSITE: 'cmpt',\n  POINT_CLOUD: 'pnts',\n  BATCHED_3D_MODEL: 'b3dm',\n  INSTANCED_3D_MODEL: 'i3dm',\n  GEOMETRY: 'geom',\n  VECTOR: 'vect',\n  GLTF: 'glTF'\n};\n\nexport const TILE3D_TYPES = Object.keys(TILE3D_TYPE);\n\nexport const MAGIC_ARRAY = {\n  BATCHED_MODEL: [98, 51, 100, 109],\n  INSTANCED_MODEL: [105, 51, 100, 109],\n  POINT_CLOUD: [112, 110, 116, 115],\n  COMPOSITE: [99, 109, 112, 116]\n};\n\n// TILE CONSTANTS\nexport const TILE3D_OPTIMIZATION_HINT = {\n  NOT_COMPUTED: -1,\n  USE_OPTIMIZATION: 1,\n  SKIP_OPTIMIZATION: 0\n};\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {assert} from '@loaders.gl/loader-utils';\n\n// Decode the JSON binary array into clear text\nexport function getStringFromArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  assert(arrayBuffer instanceof ArrayBuffer);\n  const textDecoder = new TextDecoder('utf8');\n  const typedArray = new Uint8Array(arrayBuffer, byteOffset, byteLength);\n  const string = textDecoder.decode(typedArray);\n  return string;\n}\n\n// Decode the JSON binary array into clear text\nexport function getStringFromTypedArray(typedArray) {\n  assert(ArrayBuffer.isView(typedArray));\n  const textDecoder = new TextDecoder('utf8');\n  const string = textDecoder.decode(typedArray);\n  return string;\n}\n\nexport function getMagicString(arrayBuffer, byteOffset = 0) {\n  const dataView = new DataView(arrayBuffer);\n  return `\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;\n}\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n", "import type {Loader, LoaderOptions} from '@loaders.gl/loader-utils';\nimport {isBrowser} from '@loaders.gl/worker-utils';\nimport type {DracoParseOptions} from './lib/draco-parser';\n// import type {DracoMeshData} from './types';\nimport {VERSION} from './lib/utils/version';\n\nexport type DracoLoaderOptions = LoaderOptions & {\n  draco?: DracoParseOptions & {\n    decoderType?: 'wasm' | 'js';\n    libraryPath?: string;\n    extraAttributes?;\n    attributeNameEntry?: string;\n    workerUrl?: string;\n  };\n};\n\nconst DEFAULT_DRACO_OPTIONS: DracoLoaderOptions = {\n  draco: {\n    decoderType: typeof WebAssembly === 'object' ? 'wasm' : 'js', // 'js' for IE11\n    libraryPath: 'libs/',\n    extraAttributes: {},\n    attributeNameEntry: undefined\n  }\n};\n\n/**\n * Worker loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n  name: 'Draco',\n  id: isBrowser ? 'draco' : 'draco-nodejs',\n  module: 'draco',\n  shapes: ['mesh'],\n  version: VERSION,\n  worker: true,\n  extensions: ['drc'],\n  mimeTypes: ['application/octet-stream'],\n  binary: true,\n  tests: ['DRACO'],\n  options: DEFAULT_DRACO_OPTIONS\n};\n\nexport const _TypecheckDracoLoader: Loader = DracoLoader;\n", "import type {Schema} from '../schema/schema';\nimport type {TableBatch} from '../../category/table/table-types';\nimport {TableBatchAggregator, TableBatchOptions} from './table-batch-aggregator';\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class RowTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  options: TableBatchOptions;\n\n  length: number = 0;\n  rows: any[] | null = null;\n  cursor: number = 0;\n  private _headers: string[] = [];\n\n  constructor(schema: Schema, options: TableBatchOptions) {\n    this.options = options;\n    this.schema = schema;\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    if (!Array.isArray(schema)) {\n      this._headers = [];\n      for (const key in schema) {\n        this._headers[schema[key].index] = schema[key].name;\n      }\n    }\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[], cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);\n    this.rows[this.length] = row;\n    this.length++;\n  }\n\n  addObjectRow(row: {[columnName: string]: any}, cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    this.rows = this.rows || new Array(DEFAULT_ROW_COUNT);\n    this.rows[this.length] = row;\n    this.length++;\n  }\n\n  getBatch(): TableBatch | null {\n    let rows = this.rows;\n    if (!rows) {\n      return null;\n    }\n\n    rows = rows.slice(0, this.length);\n    this.rows = null;\n\n    const batch: TableBatch = {\n      shape: this.options.shape,\n      batchType: 'data',\n      data: rows,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    };\n\n    return batch;\n  }\n}\n", "/** Convert an object row to an array row */\nexport function convertToObjectRow(\n  arrayRow: any[],\n  headers: string[]\n): {[columnName: string]: any} {\n  if (!arrayRow) {\n    throw new Error('null row');\n  }\n  if (!headers) {\n    throw new Error('no headers');\n  }\n  const objectRow = {};\n  for (let i = 0; i < headers.length; i++) {\n    objectRow[headers[i]] = arrayRow[i];\n  }\n  return objectRow;\n}\n\n/** Convert an object row to an array row */\nexport function convertToArrayRow(\n  objectRow: {[columnName: string]: any},\n  headers: string[]\n): any[] {\n  if (!objectRow) {\n    throw new Error('null row');\n  }\n  if (!headers) {\n    throw new Error('no headers');\n  }\n  const arrayRow = new Array(headers.length);\n  for (let i = 0; i < headers.length; i++) {\n    arrayRow[i] = objectRow[headers[i]];\n  }\n  return arrayRow;\n}\n", "import type {Schema} from '../schema/schema';\nimport type {TableBatch} from '../../category/table/table-types';\n// import type {ArrayRowTableBatch, ObjectRowTableBatch} from '../../category/table';\nimport {convertToArrayRow, convertToObjectRow} from '../utils/row-utils';\nimport {TableBatchAggregator, TableBatchOptions} from './table-batch-aggregator';\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class RowTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  options: TableBatchOptions;\n\n  length: number = 0;\n  objectRows: {[columnName: string]: any} | null = null;\n  arrayRows: any[] | null = null;\n  cursor: number = 0;\n  private _headers: string[] = [];\n\n  constructor(schema: Schema, options: TableBatchOptions) {\n    this.options = options;\n    this.schema = schema;\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    if (!Array.isArray(schema)) {\n      this._headers = [];\n      for (const key in schema) {\n        this._headers[schema[key].index] = schema[key].name;\n      }\n    }\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[], cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    // eslint-disable-next-line default-case\n    switch (this.options.shape) {\n      case 'object-row-table':\n        const rowObject = convertToObjectRow(row, this._headers);\n        this.addObjectRow(rowObject, cursor);\n        break;\n      case 'array-row-table':\n        this.arrayRows = this.arrayRows || new Array(DEFAULT_ROW_COUNT);\n        this.arrayRows[this.length] = row;\n        this.length++;\n        break;\n    }\n  }\n\n  addObjectRow(row: {[columnName: string]: any}, cursor?: number): void {\n    if (Number.isFinite(cursor)) {\n      this.cursor = cursor as number;\n    }\n\n    // eslint-disable-next-line default-case\n    switch (this.options.shape) {\n      case 'array-row-table':\n        const rowArray = convertToArrayRow(row, this._headers);\n        this.addArrayRow(rowArray, cursor);\n        break;\n      case 'object-row-table':\n        this.objectRows = this.objectRows || new Array(DEFAULT_ROW_COUNT);\n        this.objectRows[this.length] = row;\n        this.length++;\n        break;\n    }\n  }\n\n  getBatch(): TableBatch | null {\n    let rows = this.arrayRows || this.objectRows;\n    if (!rows) {\n      return null;\n    }\n\n    rows = rows.slice(0, this.length);\n    this.arrayRows = null;\n    this.objectRows = null;\n\n    return {\n      shape: this.options.shape,\n      batchType: 'data',\n      data: rows,\n      length: this.length,\n      schema: this.schema,\n      cursor: this.cursor\n    };\n  }\n}\n", "import type {Schema} from '../schema/schema';\nimport type {ColumnarTableBatch, ArrowTableBatch} from '../../category/table/table-types';\nimport {TableBatchAggregator} from './table-batch-aggregator';\n\ntype ColumnarTableBatchOptions = {};\n\nconst DEFAULT_ROW_COUNT = 100;\n\nexport default class ColumnarTableBatchAggregator implements TableBatchAggregator {\n  schema: Schema;\n  length: number = 0;\n  allocated: number = 0;\n  columns: {[columnName: string]: any[]} = {};\n\n  constructor(schema: Schema, options: ColumnarTableBatchOptions) {\n    this.schema = schema;\n    this._reallocateColumns();\n  }\n\n  rowCount(): number {\n    return this.length;\n  }\n\n  addArrayRow(row: any[]) {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this._reallocateColumns();\n    let i = 0;\n    // TODO what if no csv header, columns not populated?\n    for (const fieldName in this.columns) {\n      this.columns[fieldName][this.length] = row[i++];\n    }\n    this.length++;\n  }\n\n  addObjectRow(row: {[columnName: string]: any}): void {\n    // If user keeps pushing rows beyond batch size, reallocate\n    this._reallocateColumns();\n    for (const fieldName in row) {\n      this.columns[fieldName][this.length] = row[fieldName];\n    }\n    this.length++;\n  }\n\n  getBatch(): ColumnarTableBatch | ArrowTableBatch | null {\n    this._pruneColumns();\n    const columns = Array.isArray(this.schema) ? this.columns : {};\n\n    // schema is an array if there're no headers\n    // object if there are headers\n    // columns should match schema format\n    if (!Array.isArray(this.schema)) {\n      for (const fieldName in this.schema) {\n        const field = this.schema[fieldName];\n        columns[field.name] = this.columns[field.index];\n      }\n    }\n\n    this.columns = {};\n\n    const batch: ColumnarTableBatch = {\n      shape: 'columnar-table',\n      batchType: 'data',\n      data: columns,\n      schema: this.schema,\n      length: this.length\n    };\n\n    return batch;\n  }\n\n  // HELPERS\n\n  _reallocateColumns() {\n    if (this.length < this.allocated) {\n      return;\n    }\n\n    // @ts-ignore TODO\n    this.allocated = this.allocated > 0 ? (this.allocated *= 2) : DEFAULT_ROW_COUNT;\n    this.columns = {};\n\n    for (const fieldName in this.schema) {\n      const field = this.schema[fieldName];\n      const ArrayType = field.type || Float32Array;\n      const oldColumn = this.columns[field.index];\n\n      if (oldColumn && ArrayBuffer.isView(oldColumn)) {\n        // Copy the old data to the new array\n        const typedArray = new ArrayType(this.allocated);\n        typedArray.set(oldColumn);\n        this.columns[field.index] = typedArray;\n      } else if (oldColumn) {\n        // Plain array\n        oldColumn.length = this.allocated;\n        this.columns[field.index] = oldColumn;\n      } else {\n        // Create new\n        this.columns[field.index] = new ArrayType(this.allocated);\n      }\n    }\n  }\n\n  _pruneColumns() {\n    for (const [columnName, column] of Object.entries(this.columns)) {\n      this.columns[columnName] = column.slice(0, this.length);\n    }\n  }\n}\n", "import type {Schema} from '../schema/schema';\nimport type {TableBatch} from '../../category/table/table-types';\nimport type {TableBatchAggregator, TableBatchConstructor} from './table-batch-aggregator';\nimport BaseTableBatchAggregator from './base-table-batch-aggregator';\nimport RowTableBatchAggregator from './row-table-batch-aggregator';\nimport ColumnarTableBatchAggregator from './columnar-table-batch-aggregator';\n\n// TODO define interface instead\ntype TableBatchBuilderOptions = {\n  shape: 'row-table' | 'array-row-table' | 'object-row-table' | 'columnar-table' | 'arrow-table';\n  batchSize?: number | 'auto';\n  batchDebounceMs?: number;\n  limit: number;\n  _limitMB: number;\n};\n\ntype GetBatchOptions = {\n  bytesUsed?: number;\n  [key: string]: any;\n};\n\nconst DEFAULT_OPTIONS: Required<TableBatchBuilderOptions> = {\n  shape: 'array-row-table',\n  batchSize: 'auto',\n  batchDebounceMs: 0,\n  limit: 0,\n  _limitMB: 0\n};\n\nconst ERR_MESSAGE = 'TableBatchBuilder';\n\n/** Incrementally builds batches from a stream of rows */\nexport default class TableBatchBuilder {\n  schema: Schema;\n  options: Required<TableBatchBuilderOptions>;\n\n  private aggregator: TableBatchAggregator | null = null;\n  private batchCount: number = 0;\n  private bytesUsed: number = 0;\n  private isChunkComplete: boolean = false;\n  private lastBatchEmittedMs: number = Date.now();\n  private totalLength: number = 0;\n  private totalBytes: number = 0;\n  private rowBytes: number = 0;\n\n  static ArrowBatch?: TableBatchConstructor;\n\n  constructor(schema: Schema, options?: TableBatchBuilderOptions) {\n    this.schema = schema;\n    this.options = {...DEFAULT_OPTIONS, ...options};\n  }\n\n  limitReached(): boolean {\n    if (Boolean(this.options?.limit) && this.totalLength >= this.options.limit) {\n      return true;\n    }\n    if (Boolean(this.options?._limitMB) && this.totalBytes / 1e6 >= this.options._limitMB) {\n      return true;\n    }\n    return false;\n  }\n\n  /** @deprecated Use addArrayRow or addObjectRow */\n  addRow(row: any[] | {[columnName: string]: any}): void {\n    if (this.limitReached()) {\n      return;\n    }\n    this.totalLength++;\n    this.rowBytes = this.rowBytes || this._estimateRowMB(row);\n    this.totalBytes += this.rowBytes;\n    if (Array.isArray(row)) {\n      this.addArrayRow(row);\n    } else {\n      this.addObjectRow(row);\n    }\n  }\n\n  /** Add one row to the batch */\n  protected addArrayRow(row: any[]) {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addArrayRow(row);\n  }\n\n  /** Add one row to the batch */\n  protected addObjectRow(row: {[columnName: string]: any}): void {\n    if (!this.aggregator) {\n      const TableBatchType = this._getTableBatchType();\n      this.aggregator = new TableBatchType(this.schema, this.options);\n    }\n    this.aggregator.addObjectRow(row);\n  }\n\n  /** Mark an incoming raw memory chunk has completed */\n  chunkComplete(chunk: ArrayBuffer | string): void {\n    if (chunk instanceof ArrayBuffer) {\n      this.bytesUsed += chunk.byteLength;\n    }\n    if (typeof chunk === 'string') {\n      this.bytesUsed += chunk.length;\n    }\n    this.isChunkComplete = true;\n  }\n\n  getFullBatch(options?: GetBatchOptions): TableBatch | null {\n    return this._isFull() ? this._getBatch(options) : null;\n  }\n\n  getFinalBatch(options?: GetBatchOptions): TableBatch | null {\n    return this._getBatch(options);\n  }\n\n  // INTERNAL\n\n  _estimateRowMB(row: any[] | object): number {\n    return Array.isArray(row) ? row.length * 8 : Object.keys(row).length * 8;\n  }\n\n  private _isFull(): boolean {\n    // No batch, not ready\n    if (!this.aggregator || this.aggregator.rowCount() === 0) {\n      return false;\n    }\n\n    // if batchSize === 'auto' we wait for chunk to complete\n    // if batchSize === number, ensure we have enough rows\n    if (this.options.batchSize === 'auto') {\n      if (!this.isChunkComplete) {\n        return false;\n      }\n    } else if (this.options.batchSize > this.aggregator.rowCount()) {\n      return false;\n    }\n\n    // Debounce batches\n    if (this.options.batchDebounceMs > Date.now() - this.lastBatchEmittedMs) {\n      return false;\n    }\n\n    // Emit batch\n    this.isChunkComplete = false;\n    this.lastBatchEmittedMs = Date.now();\n    return true;\n  }\n\n  /**\n   * bytesUsed can be set via chunkComplete or via getBatch*\n   */\n  private _getBatch(options?: GetBatchOptions): TableBatch | null {\n    if (!this.aggregator) {\n      return null;\n    }\n\n    // TODO - this can overly increment bytes used?\n    if (options?.bytesUsed) {\n      this.bytesUsed = options.bytesUsed;\n    }\n    const normalizedBatch = this.aggregator.getBatch() as TableBatch;\n    normalizedBatch.count = this.batchCount;\n    normalizedBatch.bytesUsed = this.bytesUsed;\n    Object.assign(normalizedBatch, options);\n\n    this.batchCount++;\n    this.aggregator = null;\n    return normalizedBatch;\n  }\n\n  private _getTableBatchType(): TableBatchConstructor {\n    switch (this.options.shape) {\n      case 'row-table':\n        return BaseTableBatchAggregator;\n      case 'array-row-table':\n      case 'object-row-table':\n        return RowTableBatchAggregator;\n      case 'columnar-table':\n        return ColumnarTableBatchAggregator;\n      case 'arrow-table':\n        if (!TableBatchBuilder.ArrowBatch) {\n          throw new Error(ERR_MESSAGE);\n        }\n        return TableBatchBuilder.ArrowBatch;\n      default:\n        throw new Error(ERR_MESSAGE);\n    }\n  }\n}\n", "// Mesh category utilities\n// TODO - move to mesh category module, or to math.gl/geometry module\nimport {TypedArray} from '../../types';\nimport {MeshAttributes} from './mesh-types';\n\ntype TypedArrays = {[key: string]: TypedArray};\n\n/**\n * Holds an axis aligned bounding box\n * TODO - make sure AxisAlignedBoundingBox in math.gl/culling understands this format (or change this format)\n */\ntype BoundingBox = [[number, number, number], [number, number, number]];\n\n/**\n * Get number of vertices in mesh\n * @param attributes\n */\nexport function getMeshSize(attributes: TypedArrays): number {\n  let size = 0;\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    if (ArrayBuffer.isView(attribute)) {\n      // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT\n      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;\n    }\n  }\n  return size;\n}\n\n/**\n * Get the (axis aligned) bounding box of a mesh\n * @param attributes\n * @returns array of two vectors representing the axis aligned bounding box\n */\n// eslint-disable-next-line complexity\nexport function getMeshBoundingBox(attributes: MeshAttributes): BoundingBox {\n  let minX = Infinity;\n  let minY = Infinity;\n  let minZ = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let maxZ = -Infinity;\n\n  const positions = attributes.POSITION ? attributes.POSITION.value : [];\n  const len = positions && positions.length;\n\n  for (let i = 0; i < len; i += 3) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    const z = positions[i + 2];\n\n    minX = x < minX ? x : minX;\n    minY = y < minY ? y : minY;\n    minZ = z < minZ ? z : minZ;\n\n    maxX = x > maxX ? x : maxX;\n    maxY = y > maxY ? y : maxY;\n    maxZ = z > maxZ ? z : maxZ;\n  }\n  return [\n    [minX, minY, minZ],\n    [maxX, maxY, maxZ]\n  ];\n}\n", "// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport function assert(condition: boolean, message?: string) {\n  if (!condition) {\n    throw new Error(message || 'loader assertion failed.');\n  }\n}\n", "import {assert} from '../../utils/assert';\nimport Field from './field';\n\nexport type SchemaMetadata = Map<string, any>;\n\n/**\n * ArrowJS `Schema` API-compatible class for row-based tables (returned from `DataTable`)\n * https://loaders.gl/arrowjs/docs/api-reference/schema\n */\nexport default class Schema {\n  fields: Field[];\n  // TODO - Arrow just allows Map<string, string>\n  metadata: SchemaMetadata;\n\n  constructor(fields: Field[], metadata?: SchemaMetadata) {\n    assert(Array.isArray(fields));\n    checkNames(fields);\n    // For kepler fields, create arrow compatible `Fields` that have kepler fields as `metadata`\n    this.fields = fields;\n    this.metadata = metadata || new Map();\n  }\n\n  // TODO - arrow only seems to compare fields, not metadata\n  compareTo(other: Schema): boolean {\n    if (this.metadata !== other.metadata) {\n      return false;\n    }\n    if (this.fields.length !== other.fields.length) {\n      return false;\n    }\n    for (let i = 0; i < this.fields.length; ++i) {\n      if (!this.fields[i].compareTo(other.fields[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  select(...columnNames: string[]): Schema {\n    // Ensure column names reference valid fields\n    const nameMap = Object.create(null);\n    for (const name of columnNames) {\n      nameMap[name] = true;\n    }\n    const selectedFields = this.fields.filter((field) => nameMap[field.name]);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  selectAt(...columnIndices: number[]): Schema {\n    // Ensure column indices reference valid fields\n    const selectedFields = columnIndices.map((index) => this.fields[index]).filter(Boolean);\n    return new Schema(selectedFields, this.metadata);\n  }\n\n  assign(schemaOrFields: Schema | Field[]): Schema {\n    let fields: Field[];\n    let metadata: SchemaMetadata = this.metadata;\n\n    if (schemaOrFields instanceof Schema) {\n      const otherSchema = schemaOrFields;\n      fields = otherSchema.fields;\n      metadata = mergeMaps(mergeMaps(new Map(), this.metadata), otherSchema.metadata);\n    } else {\n      fields = schemaOrFields;\n    }\n\n    // Create a merged list of fields, overwrite fields in place, new fields at end\n    const fieldMap: {[key: string]: Field} = Object.create(null);\n\n    for (const field of this.fields) {\n      fieldMap[field.name] = field;\n    }\n\n    for (const field of fields) {\n      fieldMap[field.name] = field;\n    }\n\n    const mergedFields = Object.values(fieldMap);\n\n    return new Schema(mergedFields, metadata);\n  }\n}\n\n// Warn if any duplicated field names\nfunction checkNames(fields: Field[]): void {\n  const usedNames: Record<string, boolean> = {};\n  for (const field of fields) {\n    if (usedNames[field.name]) {\n      // eslint-disable-next-line\n      console.warn('Schema: duplicated field name', field.name, field);\n    }\n    usedNames[field.name] = true;\n  }\n}\n\nfunction mergeMaps<T>(m1: T, m2: T): T {\n  // @ts-ignore\n  return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n", "import {DataType} from './type';\n\n/**\n * ArrowJS `Field` API-compatible class for row-based tables\n * https://loaders.gl/arrowjs/docs/api-reference/field\n * A field holds name, nullable, and metadata information about a table \"column\"\n * A Schema is essentially a list of fields\n */\nexport default class Field {\n  name: string;\n  type: DataType;\n  nullable: boolean;\n  metadata: Map<string, string>;\n\n  constructor(\n    name: string,\n    type: DataType,\n    nullable = false,\n    metadata: Map<string, string> = new Map()\n  ) {\n    this.name = name;\n    this.type = type;\n    this.nullable = nullable;\n    this.metadata = metadata;\n  }\n\n  get typeId(): number {\n    return this.type && this.type.typeId;\n  }\n\n  clone(): Field {\n    return new Field(this.name, this.type, this.nullable, this.metadata);\n  }\n\n  compareTo(other: this): boolean {\n    return (\n      this.name === other.name &&\n      this.type === other.type &&\n      this.nullable === other.nullable &&\n      this.metadata === other.metadata\n    );\n  }\n\n  toString(): string {\n    return `${this.type}${this.nullable ? ', nullable' : ''}${\n      this.metadata ? `, metadata: ${this.metadata}` : ''\n    }`;\n  }\n}\n", "// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n\n/**\n * Main data type enumeration.\n *\n * Data types in this library are all *logical*. They can be expressed as\n * either a primitive physical type (bytes or bits of some fixed size), a\n * nested type consisting of other data types, or another data type (e.g. a\n * timestamp encoded as an int64).\n *\n * **Note**: Only enum values 0-17 (NONE through Map) are written to an Arrow\n * IPC payload.\n *\n * The rest of the values are specified here so TypeScript can narrow the type\n * signatures further beyond the base Arrow Types. The Arrow DataTypes include\n * metadata like `bitWidth` that impact the type signatures of the values we\n * accept and return.\n *\n * For example, the `Int8Vector` reads 1-byte numbers from an `Int8Array`, an\n * `Int32Vector` reads a 4-byte number from an `Int32Array`, and an `Int64Vector`\n * reads a pair of 4-byte lo, hi 32-bit integers as a zero-copy slice from the\n * underlying `Int32Array`.\n *\n * Library consumers benefit by knowing the narrowest type, since we can ensure\n * the types across all public methods are propagated, and never bail to `any`.\n * These values are _never_ used at runtime, and they will _never_ be written\n * to the flatbuffers metadata of serialized Arrow IPC payloads.\n */\nexport enum Type {\n  /** The default placeholder type */\n  NONE = 0,\n  /** A NULL type having no physical storage */\n  Null = 1,\n  /** Signed or unsigned 8, 16, 32, or 64-bit little-endian integer */\n  Int = 2,\n  /** 2, 4, or 8-byte floating point value */\n  Float = 3,\n  /** Variable-length bytes (no guarantee of UTF8-ness) */\n  Binary = 4,\n  /** UTF8 variable-length string as List<Char> */\n  Utf8 = 5,\n  /** Boolean as 1 bit, LSB bit-packed ordering */\n  Bool = 6,\n  /** Precision-and-scale-based decimal type. Storage type depends on the parameters. */\n  Decimal = 7,\n  /** int32_t days or int64_t milliseconds since the UNIX epoch */\n  Date = 8,\n  /** Time as signed 32 or 64-bit integer, representing either seconds, milliseconds, microseconds, or nanoseconds since midnight since midnight */\n  Time = 9,\n  /** Exact timestamp encoded with int64 since UNIX epoch (Default unit millisecond) */\n  Timestamp = 10,\n  /** YEAR_MONTH or DAY_TIME interval in SQL style */\n  Interval = 11,\n  /** A list of some logical data type */\n  List = 12,\n  /** Struct of logical types */\n  Struct = 13,\n  /** Union of logical types */\n  Union = 14,\n  /** Fixed-size binary. Each value occupies the same number of bytes */\n  FixedSizeBinary = 15,\n  /** Fixed-size list. Each value occupies the same number of bytes */\n  FixedSizeList = 16,\n  /** Map of named logical types */\n  Map = 17,\n\n  /** Dictionary aka Category type */\n  Dictionary = -1,\n  Int8 = -2,\n  Int16 = -3,\n  Int32 = -4,\n  Int64 = -5,\n  Uint8 = -6,\n  Uint16 = -7,\n  Uint32 = -8,\n  Uint64 = -9,\n  Float16 = -10,\n  Float32 = -11,\n  Float64 = -12,\n  DateDay = -13,\n  DateMillisecond = -14,\n  TimestampSecond = -15,\n  TimestampMillisecond = -16,\n  TimestampMicrosecond = -17,\n  TimestampNanosecond = -18,\n  TimeSecond = -19,\n  TimeMillisecond = -20,\n  TimeMicrosecond = -21,\n  TimeNanosecond = -22,\n  DenseUnion = -23,\n  SparseUnion = -24,\n  IntervalDayTime = -25,\n  IntervalYearMonth = -26\n}\n", "// This code is adapted from ArrowJS https://github.com/apache/arrow\n// under Apache license http://www.apache.org/licenses/LICENSE-2.0\n\nimport {Type} from './enum';\n\nimport Field from './field';\n\nexport {Type} from './enum';\n\nexport type TypedIntArray =\n  | Int8Array\n  | Uint8Array\n  | Int16Array\n  | Uint16Array\n  | Int32Array\n  | Uint32Array\n  | Int32Array\n  | Uint32Array\n  | Uint8ClampedArray;\n\nexport type TypedFloatArray = Float32Array | Float64Array;\n\nexport type TypedArray = TypedIntArray | TypedFloatArray;\n\nexport type AnyArrayType = Array<any> | TypedIntArray | TypedFloatArray;\n\nexport class DataType {\n  static isNull(x: any): boolean {\n    return x && x.typeId === Type.Null;\n  }\n  static isInt(x: any): boolean {\n    return x && x.typeId === Type.Int;\n  }\n  static isFloat(x: any): boolean {\n    return x && x.typeId === Type.Float;\n  }\n  static isBinary(x: any): boolean {\n    return x && x.typeId === Type.Binary;\n  }\n  static isUtf8(x: any): boolean {\n    return x && x.typeId === Type.Utf8;\n  }\n  static isBool(x: any): boolean {\n    return x && x.typeId === Type.Bool;\n  }\n  static isDecimal(x: any): boolean {\n    return x && x.typeId === Type.Decimal;\n  }\n  static isDate(x: any): boolean {\n    return x && x.typeId === Type.Date;\n  }\n  static isTime(x: any): boolean {\n    return x && x.typeId === Type.Time;\n  }\n  static isTimestamp(x: any): boolean {\n    return x && x.typeId === Type.Timestamp;\n  }\n  static isInterval(x: any): boolean {\n    return x && x.typeId === Type.Interval;\n  }\n  static isList(x: any): boolean {\n    return x && x.typeId === Type.List;\n  }\n  static isStruct(x: any): boolean {\n    return x && x.typeId === Type.Struct;\n  }\n  static isUnion(x: any): boolean {\n    return x && x.typeId === Type.Union;\n  }\n  static isFixedSizeBinary(x: any): boolean {\n    return x && x.typeId === Type.FixedSizeBinary;\n  }\n  static isFixedSizeList(x: any): boolean {\n    return x && x.typeId === Type.FixedSizeList;\n  }\n  static isMap(x: any): boolean {\n    return x && x.typeId === Type.Map;\n  }\n  static isDictionary(x: any): boolean {\n    return x && x.typeId === Type.Dictionary;\n  }\n\n  get typeId(): Type {\n    return Type.NONE;\n  }\n\n  // get ArrayType(): AnyArrayType {\n  //   return Int8Array;\n  // }\n\n  // get ArrayType() { return Array; }\n  compareTo(other: DataType): boolean {\n    // TODO\n    return this === other; // comparer.visit(this, other);\n  }\n}\n\n// NULL\n\nexport class Null extends DataType {\n  get typeId(): Type {\n    return Type.Null;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Null';\n  }\n  toString(): string {\n    return 'Null';\n  }\n}\n\n// BOOLEANS\n\nexport class Bool extends DataType {\n  get typeId(): Type {\n    return Type.Bool;\n  }\n  // get ArrayType() {\n  //   return Uint8Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Bool';\n  }\n  toString(): string {\n    return 'Bool';\n  }\n}\n\n// INTS\n\nexport class Int extends DataType {\n  readonly isSigned: boolean;\n  readonly bitWidth: number;\n  constructor(isSigned, bitWidth) {\n    super();\n    this.isSigned = isSigned;\n    this.bitWidth = bitWidth;\n  }\n  get typeId(): Type {\n    return Type.Int;\n  }\n  // get ArrayType() {\n  //   switch (this.bitWidth) {\n  //     case 8:\n  //       return this.isSigned ? Int8Array : Uint8Array;\n  //     case 16:\n  //       return this.isSigned ? Int16Array : Uint16Array;\n  //     case 32:\n  //       return this.isSigned ? Int32Array : Uint32Array;\n  //     case 64:\n  //       return this.isSigned ? Int32Array : Uint32Array;\n  //     default:\n  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  //   }\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Int';\n  }\n  toString(): string {\n    return `${this.isSigned ? 'I' : 'Ui'}nt${this.bitWidth}`;\n  }\n}\n\nexport class Int8 extends Int {\n  constructor() {\n    super(true, 8);\n  }\n}\nexport class Int16 extends Int {\n  constructor() {\n    super(true, 16);\n  }\n}\nexport class Int32 extends Int {\n  constructor() {\n    super(true, 32);\n  }\n}\nexport class Int64 extends Int {\n  constructor() {\n    super(true, 64);\n  }\n}\nexport class Uint8 extends Int {\n  constructor() {\n    super(false, 8);\n  }\n}\nexport class Uint16 extends Int {\n  constructor() {\n    super(false, 16);\n  }\n}\nexport class Uint32 extends Int {\n  constructor() {\n    super(false, 32);\n  }\n}\nexport class Uint64 extends Int {\n  constructor() {\n    super(false, 64);\n  }\n}\n\n// FLOATS\n\nconst Precision = {\n  HALF: 16,\n  SINGLE: 32,\n  DOUBLE: 64\n};\n\nexport class Float extends DataType {\n  readonly precision: number;\n  constructor(precision) {\n    super();\n    this.precision = precision;\n  }\n  get typeId(): Type {\n    return Type.Float;\n  }\n  // get ArrayType() {\n  //   switch (this.precision) {\n  //     case Precision.HALF:\n  //       return Uint16Array;\n  //     case Precision.SINGLE:\n  //       return Float32Array;\n  //     case Precision.DOUBLE:\n  //       return Float64Array;\n  //     default:\n  //       throw new Error(`Unrecognized ${this[Symbol.toStringTag]} type`);\n  //   }\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Float';\n  }\n  toString(): string {\n    return `Float${this.precision}`;\n  }\n}\n\nexport class Float16 extends Float {\n  constructor() {\n    super(Precision.HALF);\n  }\n}\nexport class Float32 extends Float {\n  constructor() {\n    super(Precision.SINGLE);\n  }\n}\nexport class Float64 extends Float {\n  constructor() {\n    super(Precision.DOUBLE);\n  }\n}\n\nexport class Binary extends DataType {\n  constructor() {\n    super();\n  }\n  get typeId() {\n    return Type.Binary;\n  }\n  toString() {\n    return 'Binary';\n  }\n  get [Symbol.toStringTag]() {\n    return 'Binary';\n  }\n}\n\n// STRINGS\n\nexport class Utf8 extends DataType {\n  get typeId(): Type {\n    return Type.Utf8;\n  }\n  // get ArrayType() {\n  //   return Uint8Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Utf8';\n  }\n  toString(): string {\n    return 'Utf8';\n  }\n}\n\n// DATES, TIMES AND INTERVALS\n\nconst DateUnit = {\n  DAY: 0,\n  MILLISECOND: 1\n};\n\nexport class Date extends DataType {\n  readonly unit: number;\n  constructor(unit) {\n    super();\n    this.unit = unit;\n  }\n  get typeId(): Type {\n    return Type.Date;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Date';\n  }\n  toString(): string {\n    return `Date${(this.unit + 1) * 32}<${DateUnit[this.unit]}>`;\n  }\n}\n\nexport class DateDay extends Date {\n  constructor() {\n    super(DateUnit.DAY);\n  }\n}\nexport class DateMillisecond extends Date {\n  constructor() {\n    super(DateUnit.MILLISECOND);\n  }\n}\n\nconst TimeUnit = {\n  SECOND: 1,\n  MILLISECOND: 1e3,\n  MICROSECOND: 1e6,\n  NANOSECOND: 1e9\n};\n\nexport class Time extends DataType {\n  readonly unit: any;\n  readonly bitWidth: number;\n\n  constructor(unit: any, bitWidth: number) {\n    super();\n    this.unit = unit;\n    this.bitWidth = bitWidth;\n  }\n  get typeId(): Type {\n    return Type.Time;\n  }\n  toString(): string {\n    return `Time${this.bitWidth}<${TimeUnit[this.unit]}>`;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Time';\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n}\n\nexport class TimeSecond extends Time {\n  constructor() {\n    super(TimeUnit.SECOND, 32);\n  }\n}\nexport class TimeMillisecond extends Time {\n  constructor() {\n    super(TimeUnit.MILLISECOND, 32);\n  }\n}\n// export class TimeMicrosecond extends Time { constructor() { super(TimeUnit.MICROSECOND, 64); } }\n// export class TimeNanosecond extends Time { constructor() { super(TimeUnit.NANOSECOND, 64); } }\n\nexport class Timestamp extends DataType {\n  readonly unit: any;\n  readonly timezone: any;\n\n  constructor(unit: any, timezone = null) {\n    super();\n    this.unit = unit;\n    this.timezone = timezone;\n  }\n  get typeId(): Type {\n    return Type.Timestamp;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Timestamp';\n  }\n  toString(): string {\n    return `Timestamp<${TimeUnit[this.unit]}${this.timezone ? `, ${this.timezone}` : ''}>`;\n  }\n}\n\nexport class TimestampSecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.SECOND, timezone);\n  }\n}\nexport class TimestampMillisecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.MILLISECOND, timezone);\n  }\n}\nexport class TimestampMicrosecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.MICROSECOND, timezone);\n  }\n}\nexport class TimestampNanosecond extends Timestamp {\n  constructor(timezone = null) {\n    super(TimeUnit.NANOSECOND, timezone);\n  }\n}\n\nconst IntervalUnit = {\n  DAY_TIME: 0,\n  YEAR_MONTH: 1\n};\n\nexport class Interval extends DataType {\n  readonly unit: number;\n  constructor(unit: number) {\n    super();\n    this.unit = unit;\n  }\n  get typeId(): Type {\n    return Type.Interval;\n  }\n  // get ArrayType() {\n  //   return Int32Array;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'Interval';\n  }\n  toString(): string {\n    return `Interval<${IntervalUnit[this.unit]}>`;\n  }\n}\n\nexport class IntervalDayTime extends Interval {\n  constructor() {\n    super(IntervalUnit.DAY_TIME);\n  }\n}\nexport class IntervalYearMonth extends Interval {\n  constructor() {\n    super(IntervalUnit.YEAR_MONTH);\n  }\n}\n\nexport class FixedSizeList extends DataType {\n  readonly listSize: number;\n  readonly children: Field[];\n\n  constructor(listSize: number, child: Field) {\n    super();\n    this.listSize = listSize;\n    this.children = [child];\n  }\n  get typeId(): Type {\n    return Type.FixedSizeList;\n  }\n  get valueType() {\n    return this.children[0].type;\n  }\n  get valueField() {\n    return this.children[0];\n  }\n  // get ArrayType() {\n  //   return this.valueType.ArrayType;\n  // }\n  get [Symbol.toStringTag](): string {\n    return 'FixedSizeList';\n  }\n  toString(): string {\n    return `FixedSizeList[${this.listSize}]<${this.valueType}>`;\n  }\n}\n\nexport class Struct extends DataType {\n  public readonly children: Field[];\n\n  constructor(children: Field[]) {\n    super();\n    this.children = children;\n  }\n\n  public get typeId() {\n    return Type.Struct;\n  }\n  public toString() {\n    return `Struct<{${this.children.map((f) => `${f.name}:${f.type}`).join(', ')}}>`;\n  }\n  get [Symbol.toStringTag](): string {\n    return 'Struct';\n  }\n}\n", "import type {TypedArray} from '../../types';\nimport {\n  DataType,\n  Float32,\n  Float64,\n  Int16,\n  Int32,\n  Int8,\n  Uint16,\n  Uint32,\n  Uint8\n} from '../schema/schema';\n\nexport function getArrowTypeFromTypedArray(array: TypedArray): DataType {\n  switch (array.constructor) {\n    case Int8Array:\n      return new Int8();\n    case Uint8Array:\n      return new Uint8();\n    case Int16Array:\n      return new Int16();\n    case Uint16Array:\n      return new Uint16();\n    case Int32Array:\n      return new Int32();\n    case Uint32Array:\n      return new Uint32();\n    case Float32Array:\n      return new Float32();\n    case Float64Array:\n      return new Float64();\n    default:\n      throw new Error('array type not supported');\n  }\n}\n", "import {MeshAttribute, MeshAttributes} from './mesh-types';\nimport {Schema, Field, FixedSizeList} from '../../lib/schema/schema';\nimport {getArrowTypeFromTypedArray} from '../../lib/arrow/arrow-like-type-utils';\n\n/**\n * Create a schema for mesh attributes data\n * @param attributes\n * @param metadata\n * @returns\n */\nexport function deduceMeshSchema(\n  attributes: MeshAttributes,\n  metadata?: Map<string, string>\n): Schema {\n  const fields = deduceMeshFields(attributes);\n  return new Schema(fields, metadata);\n}\n\n/**\n * Create arrow-like schema field for mesh attribute\n * @param attributeName\n * @param attribute\n * @param optionalMetadata\n * @returns\n */\nexport function deduceMeshField(\n  attributeName: string,\n  attribute: MeshAttribute,\n  optionalMetadata?: Map<string, string>\n): Field {\n  const type = getArrowTypeFromTypedArray(attribute.value);\n  const metadata = optionalMetadata ? optionalMetadata : makeMeshAttributeMetadata(attribute);\n  const field = new Field(\n    attributeName,\n    new FixedSizeList(attribute.size, new Field('value', type)),\n    false,\n    metadata\n  );\n  return field;\n}\n\n/**\n * Create fields array for mesh attributes\n * @param attributes\n * @returns\n */\nfunction deduceMeshFields(attributes: MeshAttributes): Field[] {\n  const fields: Field[] = [];\n  for (const attributeName in attributes) {\n    const attribute: MeshAttribute = attributes[attributeName];\n    fields.push(deduceMeshField(attributeName, attribute));\n  }\n  return fields;\n}\n\n/**\n * Make metadata by mesh attribute properties\n * @param attribute\n * @returns\n */\nexport function makeMeshAttributeMetadata(attribute: MeshAttribute): Map<string, string> {\n  const result = new Map();\n  if ('byteOffset' in attribute) {\n    result.set('byteOffset', attribute.byteOffset!.toString(10));\n  }\n  if ('byteStride' in attribute) {\n    result.set('byteStride', attribute.byteStride!.toString(10));\n  }\n  if ('normalized' in attribute) {\n    result.set('normalized', attribute.normalized!.toString());\n  }\n  return result;\n}\n", "// From https://github.com/rauschma/async-iter-demo/tree/master/src under MIT license\n// http://2ality.com/2016/10/asynchronous-iteration.html\n\nclass ArrayQueue<T> extends Array<T> {\n  enqueue(value: T) {\n    // Add at the end\n    return this.push(value);\n  }\n  dequeue(): T {\n    // Remove first element\n    return this.shift() as T;\n  }\n}\n\nexport default class AsyncQueue<T> {\n  private _values: ArrayQueue<T | Error>;\n  private _settlers: ArrayQueue<{resolve: (value: any) => void; reject: (reason?: any) => void}>;\n  private _closed: boolean;\n\n  constructor() {\n    // enqueues > dequeues\n    this._values = new ArrayQueue<T>();\n    // dequeues > enqueues\n    this._settlers = new ArrayQueue<{\n      resolve: (value: any) => void;\n      reject: (reason?: any) => void;\n    }>();\n    this._closed = false;\n  }\n\n  close(): void {\n    while (this._settlers.length > 0) {\n      this._settlers.dequeue().resolve({done: true});\n    }\n    this._closed = true;\n  }\n\n  [Symbol.asyncIterator](): AsyncIterator<T> {\n    return this;\n  }\n\n  enqueue(value: T | Error): void {\n    if (this._closed) {\n      throw new Error('Closed');\n    }\n\n    if (this._settlers.length > 0) {\n      if (this._values.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      const settler = this._settlers.dequeue();\n      if (value instanceof Error) {\n        settler.reject(value);\n      } else {\n        settler.resolve({value});\n      }\n    } else {\n      this._values.enqueue(value);\n    }\n  }\n\n  /**\n   * @returns a Promise for an IteratorResult\n   */\n  next(): Promise<any> {\n    if (this._values.length > 0) {\n      const value = this._values.dequeue();\n      if (value instanceof Error) {\n        return Promise.reject(value);\n      }\n      return Promise.resolve({value});\n    }\n\n    if (this._closed) {\n      if (this._settlers.length > 0) {\n        throw new Error('Illegal internal state');\n      }\n      return Promise.resolve({done: true});\n    }\n    // Wait for new values to be enqueued\n    return new Promise((resolve, reject) => {\n      this._settlers.enqueue({resolve, reject});\n    });\n  }\n}\n\n/**\n * @returns a Promise for an Array with the elements in `asyncIterable`\n */\nexport async function takeAsync(\n  asyncIterable: AsyncIterable<any>,\n  count = Infinity\n): Promise<any[]> {\n  const result: Array<any> = [];\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  while (result.length < count) {\n    const {value, done} = await iterator.next();\n    if (done) {\n      break;\n    }\n    result.push(value);\n  }\n  return result;\n}\n", "import {deduceMeshField, MeshAttribute} from '@loaders.gl/schema';\nimport {Schema, Field} from '@loaders.gl/schema';\nimport type {DracoAttribute, DracoLoaderData, DracoMetadataEntry} from '../draco-types';\n\n/** Extract an arrow-like schema from a Draco mesh */\nexport function getDracoSchema(\n  attributes: {[attributeName: string]: MeshAttribute},\n  loaderData: DracoLoaderData,\n  indices?: MeshAttribute\n): Schema {\n  const metadataMap = makeMetadata(loaderData.metadata);\n  const fields: Field[] = [];\n  const namedLoaderDataAttributes = transformAttributesLoaderData(loaderData.attributes);\n  for (const attributeName in attributes) {\n    const attribute = attributes[attributeName];\n    const field = getArrowFieldFromAttribute(\n      attributeName,\n      attribute,\n      namedLoaderDataAttributes[attributeName]\n    );\n    fields.push(field);\n  }\n  if (indices) {\n    const indicesField = getArrowFieldFromAttribute('indices', indices);\n    fields.push(indicesField);\n  }\n  return new Schema(fields, metadataMap);\n}\n\nfunction transformAttributesLoaderData(loaderData: {[key: number]: DracoAttribute}): {\n  [attributeName: string]: DracoAttribute;\n} {\n  const result: {[attributeName: string]: DracoAttribute} = {};\n  for (const key in loaderData) {\n    const dracoAttribute = loaderData[key];\n    result[dracoAttribute.name || 'undefined'] = dracoAttribute;\n  }\n  return result;\n}\n\nfunction getArrowFieldFromAttribute(\n  attributeName: string,\n  attribute: MeshAttribute,\n  loaderData?: DracoAttribute\n): Field {\n  const metadataMap = loaderData ? makeMetadata(loaderData.metadata) : undefined;\n  const field = deduceMeshField(attributeName, attribute, metadataMap);\n  return field;\n}\n\nfunction makeMetadata(metadata: {[key: string]: DracoMetadataEntry}): Map<string, string> {\n  const metadataMap = new Map();\n  for (const key in metadata) {\n    metadataMap.set(`${key}.string`, JSON.stringify(metadata[key]));\n  }\n  return metadataMap;\n}\n", "/* eslint-disable camelcase */\n\nimport type {TypedArray, MeshAttribute, MeshGeometry} from '@loaders.gl/schema';\n\n// Draco types (input)\nimport type {\n  Draco3D,\n  Decoder,\n  Mesh,\n  PointCloud,\n  PointAttribute,\n  Metadata,\n  MetadataQuerier,\n  DracoInt32Array,\n  draco_DataType\n} from '../draco3d/draco3d-types';\n\n// Parsed data types (output)\nimport type {\n  DracoMesh,\n  DracoLoaderData,\n  DracoAttribute,\n  DracoMetadataEntry,\n  DracoQuantizationTransform,\n  DracoOctahedronTransform\n} from './draco-types';\n\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\nimport {getDracoSchema} from './utils/get-draco-schema';\n\n/**\n * @param topology - How triangle indices should be generated (mesh only)\n * @param attributeNameEntry\n * @param extraAttributes\n * @param quantizedAttributes\n * @param octahedronAttributes\n */\nexport type DracoParseOptions = {\n  topology?: 'triangle-list' | 'triangle-strip';\n  attributeNameEntry?: string;\n  extraAttributes?: {[uniqueId: string]: number};\n  quantizedAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n  octahedronAttributes?: ('POSITION' | 'NORMAL' | 'COLOR' | 'TEX_COORD' | 'GENERIC')[];\n};\n\n// @ts-ignore\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\n\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nconst INDEX_ITEM_SIZE = 4;\n\nexport default class DracoParser {\n  draco: Draco3D;\n  decoder: Decoder;\n  metadataQuerier: MetadataQuerier;\n\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco: Draco3D) {\n    this.draco = draco;\n    this.decoder = new this.draco.Decoder();\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n  }\n\n  /**\n   * Destroy draco resources\n   */\n  destroy(): void {\n    this.draco.destroy(this.decoder);\n    this.draco.destroy(this.metadataQuerier);\n  }\n\n  /**\n   * NOTE: caller must call `destroyGeometry` on the return value after using it\n   * @param arrayBuffer\n   * @param options\n   */\n  parseSync(arrayBuffer: ArrayBuffer, options: DracoParseOptions = {}): DracoMesh {\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    this._disableAttributeTransforms(options);\n\n    const geometry_type = this.decoder.GetEncodedGeometryType(buffer);\n    const dracoGeometry =\n      geometry_type === this.draco.TRIANGULAR_MESH\n        ? new this.draco.Mesh()\n        : new this.draco.PointCloud();\n\n    try {\n      let dracoStatus;\n      switch (geometry_type) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoStatus = this.decoder.DecodeBufferToMesh(buffer, dracoGeometry as Mesh);\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoStatus = this.decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          break;\n\n        default:\n          throw new Error('DRACO: Unknown geometry type.');\n      }\n\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        throw new Error(message);\n      }\n\n      const loaderData = this._getDracoLoaderData(dracoGeometry, geometry_type, options);\n\n      const geometry = this._getMeshData(dracoGeometry, loaderData, options);\n\n      const boundingBox = getMeshBoundingBox(geometry.attributes);\n\n      const schema = getDracoSchema(geometry.attributes, loaderData, geometry.indices);\n\n      const data: DracoMesh = {\n        loader: 'draco',\n        loaderData,\n        header: {\n          vertexCount: dracoGeometry.num_points(),\n          boundingBox\n        },\n        ...geometry,\n        schema\n      };\n      return data;\n    } finally {\n      this.draco.destroy(buffer);\n      if (dracoGeometry) {\n        this.draco.destroy(dracoGeometry);\n      }\n    }\n  }\n\n  // Draco specific \"loader data\"\n\n  /**\n   * Extract\n   * @param dracoGeometry\n   * @param geometry_type\n   * @param options\n   * @returns\n   */\n  _getDracoLoaderData(\n    dracoGeometry: Mesh | PointCloud,\n    geometry_type,\n    options: DracoParseOptions\n  ): DracoLoaderData {\n    const metadata = this._getTopLevelMetadata(dracoGeometry);\n    const attributes = this._getDracoAttributes(dracoGeometry, options);\n\n    return {\n      geometry_type,\n      num_attributes: dracoGeometry.num_attributes(),\n      num_points: dracoGeometry.num_points(),\n      num_faces: dracoGeometry instanceof this.draco.Mesh ? dracoGeometry.num_faces() : 0,\n      metadata,\n      attributes\n    };\n  }\n\n  /**\n   * Extract all draco provided information and metadata for each attribute\n   * @param dracoGeometry\n   * @param options\n   * @returns\n   */\n  _getDracoAttributes(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: DracoAttribute} {\n    const dracoAttributes: {[unique_id: number]: DracoAttribute} = {};\n\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      // Note: Draco docs do not seem clear on `GetAttribute` ids just being a zero-based index,\n      // but it does seems to work this way\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n\n      const metadata = this._getAttributeMetadata(dracoGeometry, attributeId);\n\n      dracoAttributes[dracoAttribute.unique_id()] = {\n        unique_id: dracoAttribute.unique_id(),\n        attribute_type: dracoAttribute.attribute_type(),\n        data_type: dracoAttribute.data_type(),\n        num_components: dracoAttribute.num_components(),\n\n        byte_offset: dracoAttribute.byte_offset(),\n        byte_stride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        attribute_index: attributeId,\n\n        metadata\n      };\n\n      // Add transformation parameters for any attributes app wants untransformed\n      const quantization = this._getQuantizationTransform(dracoAttribute, options);\n      if (quantization) {\n        dracoAttributes[dracoAttribute.unique_id()].quantization_transform = quantization;\n      }\n\n      const octahedron = this._getOctahedronTransform(dracoAttribute, options);\n      if (octahedron) {\n        dracoAttributes[dracoAttribute.unique_id()].octahedron_transform = octahedron;\n      }\n    }\n\n    return dracoAttributes;\n  }\n\n  /**\n   * Get standard loaders.gl mesh category data\n   * Extracts the geometry from draco\n   * @param dracoGeometry\n   * @param options\n   */\n  _getMeshData(\n    dracoGeometry: Mesh | PointCloud,\n    loaderData: DracoLoaderData,\n    options: DracoParseOptions\n  ): MeshGeometry {\n    const attributes = this._getMeshAttributes(loaderData, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO: No position attribute found.');\n    }\n\n    // For meshes, we need indices to define the faces.\n    if (dracoGeometry instanceof this.draco.Mesh) {\n      switch (options.topology) {\n        case 'triangle-strip':\n          return {\n            topology: 'triangle-strip',\n            mode: 4, // GL.TRIANGLES\n            attributes,\n            indices: {\n              value: this._getTriangleStripIndices(dracoGeometry),\n              size: 1\n            }\n          };\n        case 'triangle-list':\n        default:\n          return {\n            topology: 'triangle-list',\n            mode: 5, // GL.TRIANGLE_STRIP\n            attributes,\n            indices: {\n              value: this._getTriangleListIndices(dracoGeometry),\n              size: 1\n            }\n          };\n      }\n    }\n\n    // PointCloud - must come last as Mesh inherits from PointCloud\n    return {\n      topology: 'point-list',\n      mode: 0, // GL.POINTS\n      attributes\n    };\n  }\n\n  _getMeshAttributes(\n    loaderData: DracoLoaderData,\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[attributeName: string]: MeshAttribute} {\n    const attributes: {[key: string]: MeshAttribute} = {};\n\n    for (const loaderAttribute of Object.values(loaderData.attributes)) {\n      const attributeName = this._deduceAttributeName(loaderAttribute, options);\n      loaderAttribute.name = attributeName;\n      const {value, size} = this._getAttributeValues(dracoGeometry, loaderAttribute);\n      attributes[attributeName] = {\n        value,\n        size,\n        byteOffset: loaderAttribute.byte_offset,\n        byteStride: loaderAttribute.byte_stride,\n        normalized: loaderAttribute.normalized\n      };\n    }\n\n    return attributes;\n  }\n\n  // MESH INDICES EXTRACTION\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleListIndices(dracoGeometry: Mesh) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n    const numIndices = numFaces * 3;\n    const byteLength = numIndices * INDEX_ITEM_SIZE;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      this.decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n      return new Uint32Array(this.draco.HEAPF32.buffer, ptr, numIndices).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param dracoGeometry\n   */\n  _getTriangleStripIndices(dracoGeometry: Mesh) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      /* const numStrips = */ this.decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n      return getUint32Array(dracoArray);\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  /**\n   *\n   * @param dracoGeometry\n   * @param dracoAttribute\n   * @param attributeName\n   */\n  _getAttributeValues(\n    dracoGeometry: Mesh | PointCloud,\n    attribute: DracoAttribute\n  ): {value: TypedArray; size: number} {\n    const TypedArrayCtor = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[attribute.data_type];\n    const numComponents = attribute.num_components;\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n\n    const byteLength = numValues * TypedArrayCtor.BYTES_PER_ELEMENT;\n    const dataType = getDracoDataType(this.draco, TypedArrayCtor);\n\n    let value: TypedArray;\n\n    const ptr = this.draco._malloc(byteLength);\n    try {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attribute.attribute_index);\n      this.decoder.GetAttributeDataArrayForAllPoints(\n        dracoGeometry,\n        dracoAttribute,\n        dataType,\n        byteLength,\n        ptr\n      );\n      value = new TypedArrayCtor(this.draco.HEAPF32.buffer, ptr, numValues).slice();\n    } finally {\n      this.draco._free(ptr);\n    }\n\n    return {value, size: numComponents};\n  }\n\n  // Attribute names\n\n  /** \n   * DRACO does not store attribute names - We need to deduce an attribute name\n   * for each attribute\n  _getAttributeNames(\n    dracoGeometry: Mesh | PointCloud,\n    options: DracoParseOptions\n  ): {[unique_id: number]: string} {\n    const attributeNames: {[unique_id: number]: string} = {};\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);\n      const attributeName = this._deduceAttributeName(dracoAttribute, options);\n      attributeNames[attributeName] = attributeName;\n    }\n    return attributeNames;\n  }\n   */\n\n  /**\n   * Deduce an attribute name.\n   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n   * types\n   * @param attributeData\n   */\n  _deduceAttributeName(attribute: DracoAttribute, options: DracoParseOptions): string {\n    // Deduce name based on application provided map\n    const uniqueId = attribute.unique_id;\n    for (const [attributeName, attributeUniqueId] of Object.entries(\n      options.extraAttributes || {}\n    )) {\n      if (attributeUniqueId === uniqueId) {\n        return attributeName;\n      }\n    }\n\n    // Deduce name based on attribute type\n    const thisAttributeType = attribute.attribute_type;\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeType === thisAttributeType) {\n        // TODO - Return unique names if there multiple attributes per type\n        // (e.g. multiple TEX_COORDS or COLORS)\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    // Look up in metadata\n    // TODO - shouldn't this have priority?\n    const entryName = options.attributeNameEntry || 'name';\n    if (attribute.metadata[entryName]) {\n      return attribute.metadata[entryName].string;\n    }\n\n    // Attribute of \"GENERIC\" type, we need to assign some name\n    return `CUSTOM_ATTRIBUTE_${uniqueId}`;\n  }\n\n  // METADATA EXTRACTION\n\n  /** Get top level metadata */\n  _getTopLevelMetadata(dracoGeometry: Mesh | PointCloud) {\n    const dracoMetadata = this.decoder.GetMetadata(dracoGeometry);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /** Get per attribute metadata */\n  _getAttributeMetadata(dracoGeometry: Mesh | PointCloud, attributeId: number) {\n    const dracoMetadata = this.decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._getDracoMetadata(dracoMetadata);\n  }\n\n  /**\n   * Extract metadata field values\n   * @param dracoMetadata\n   * @returns\n   */\n  _getDracoMetadata(dracoMetadata: Metadata): {[entry: string]: DracoMetadataEntry} {\n    // The not so wonderful world of undocumented Draco APIs :(\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = this._getDracoMetadataField(dracoMetadata, entryName);\n    }\n    return result;\n  }\n\n  /**\n   * Extracts possible values for one metadata entry by name\n   * @param dracoMetadata\n   * @param entryName\n   */\n  _getDracoMetadataField(dracoMetadata: Metadata, entryName: string): DracoMetadataEntry {\n    const dracoArray = new this.draco.DracoInt32Array();\n    try {\n      // Draco metadata fields can hold int32 arrays\n      this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName, dracoArray);\n      const intArray = getInt32Array(dracoArray);\n      return {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray\n      };\n    } finally {\n      this.draco.destroy(dracoArray);\n    }\n  }\n\n  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)\n\n  /** Skip transforms for specific attribute types */\n  _disableAttributeTransforms(options: DracoParseOptions) {\n    const {quantizedAttributes = [], octahedronAttributes = []} = options;\n    const skipAttributes = [...quantizedAttributes, ...octahedronAttributes];\n    for (const dracoAttributeName of skipAttributes) {\n      this.decoder.SkipAttributeTransform(this.draco[dracoAttributeName]);\n    }\n  }\n\n  /**\n   * Extract (and apply?) Position Transform\n   * @todo not used\n   */\n  _getQuantizationTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoQuantizationTransform | null {\n    const {quantizedAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const skip = quantizedAttributes.map((type) => this.decoder[type]).includes(attribute_type);\n    if (skip) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits(),\n            range: transform.range(),\n            min_values: new Float32Array([1, 2, 3]).map((i) => transform.min_value(i))\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  _getOctahedronTransform(\n    dracoAttribute: PointAttribute,\n    options: DracoParseOptions\n  ): DracoOctahedronTransform | null {\n    const {octahedronAttributes = []} = options;\n    const attribute_type = dracoAttribute.attribute_type();\n    const octahedron = octahedronAttributes\n      .map((type) => this.decoder[type])\n      .includes(attribute_type);\n    if (octahedron) {\n      const transform = new this.draco.AttributeQuantizationTransform();\n      try {\n        if (transform.InitFromAttribute(dracoAttribute)) {\n          return {\n            quantization_bits: transform.quantization_bits()\n          };\n        }\n      } finally {\n        this.draco.destroy(transform);\n      }\n    }\n    return null;\n  }\n\n  // HELPERS\n}\n\n/**\n * Get draco specific data type by TypedArray constructor type\n * @param attributeType\n * @returns draco specific data type\n */\nfunction getDracoDataType(draco: Draco3D, attributeType: any): draco_DataType {\n  switch (attributeType) {\n    case Float32Array:\n      return draco.DT_FLOAT32;\n    case Int8Array:\n      return draco.DT_INT8;\n    case Int16Array:\n      return draco.DT_INT16;\n    case Int32Array:\n      return draco.DT_INT32;\n    case Uint8Array:\n      return draco.DT_UINT8;\n    case Uint16Array:\n      return draco.DT_UINT16;\n    case Uint32Array:\n      return draco.DT_UINT32;\n    default:\n      return draco.DT_INVALID;\n  }\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getInt32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n\n/**\n * Copy a Draco int32 array into a JS typed array\n */\nfunction getUint32Array(dracoArray: DracoInt32Array): Int32Array {\n  const numValues = dracoArray.size();\n  const intArray = new Int32Array(numValues);\n  for (let i = 0; i < numValues; i++) {\n    intArray[i] = dracoArray.GetValue(i);\n  }\n  return intArray;\n}\n", "// Dynamic DRACO module loading inspired by THREE.DRACOLoader\n// https://github.com/mrdoob/three.js/blob/398c4f39ebdb8b23eefd4a7a5ec49ec0c96c7462/examples/jsm/loaders/DRACOLoader.js\n// by Don McCurdy / https://www.donmccurdy.com / MIT license\n\nimport {loadLibrary} from '@loaders.gl/worker-utils';\n\nconst DRACO_DECODER_VERSION = '1.5.5';\nconst DRACO_ENCODER_VERSION = '1.4.1';\n\nconst STATIC_DECODER_URL = `https://www.gstatic.com/draco/versioned/decoders/${DRACO_DECODER_VERSION}`;\n\nconst DRACO_JS_DECODER_URL = `${STATIC_DECODER_URL}/draco_decoder.js`;\nconst DRACO_WASM_WRAPPER_URL = `${STATIC_DECODER_URL}/draco_wasm_wrapper.js`;\nconst DRACO_WASM_DECODER_URL = `${STATIC_DECODER_URL}/draco_decoder.wasm`;\n\nconst DRACO_ENCODER_URL = `https://raw.githubusercontent.com/google/draco/${DRACO_ENCODER_VERSION}/javascript/draco_encoder.js`;\n\nlet loadDecoderPromise;\nlet loadEncoderPromise;\n\nexport async function loadDracoDecoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadDecoderPromise =\n      loadDecoderPromise ||\n      modules.draco3d.createDecoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);\n  }\n  return await loadDecoderPromise;\n}\n\nexport async function loadDracoEncoderModule(options) {\n  const modules = options.modules || {};\n\n  // Check if a bundled draco3d library has been supplied by application\n  if (modules.draco3d) {\n    loadEncoderPromise =\n      loadEncoderPromise ||\n      modules.draco3d.createEncoderModule({}).then((draco) => {\n        return {draco};\n      });\n  } else {\n    // If not, dynamically load the WASM script from our CDN\n    loadEncoderPromise = loadEncoderPromise || loadDracoEncoder(options);\n  }\n  return await loadEncoderPromise;\n}\n\n// DRACO DECODER LOADING\n\nasync function loadDracoDecoder(options) {\n  let DracoDecoderModule;\n  let wasmBinary;\n  switch (options.draco && options.draco.decoderType) {\n    case 'js':\n      DracoDecoderModule = await loadLibrary(DRACO_JS_DECODER_URL, 'draco', options);\n      break;\n\n    case 'wasm':\n    default:\n      [DracoDecoderModule, wasmBinary] = await Promise.all([\n        await loadLibrary(DRACO_WASM_WRAPPER_URL, 'draco', options),\n        await loadLibrary(DRACO_WASM_DECODER_URL, 'draco', options)\n      ]);\n  }\n  // Depends on how import happened...\n  // @ts-ignore\n  DracoDecoderModule = DracoDecoderModule || globalThis.DracoDecoderModule;\n  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);\n}\n\nfunction initializeDracoDecoder(DracoDecoderModule, wasmBinary) {\n  const options: {wasmBinary?: any} = {};\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise((resolve) => {\n    DracoDecoderModule({\n      ...options,\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n\n// ENCODER\n\nasync function loadDracoEncoder(options) {\n  let DracoEncoderModule = await loadLibrary(DRACO_ENCODER_URL, 'draco', options);\n  // @ts-ignore\n  DracoEncoderModule = DracoEncoderModule || globalThis.DracoEncoderModule;\n\n  return new Promise((resolve) => {\n    DracoEncoderModule({\n      onModuleLoaded: (draco) => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.\n    });\n  });\n}\n", "import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport type {DracoMesh, DracoLoaderData} from './lib/draco-types';\nimport type {DracoLoaderOptions} from './draco-loader';\nimport {DracoLoader as DracoWorkerLoader} from './draco-loader';\nimport DracoParser from './lib/draco-parser';\nimport {loadDracoDecoderModule} from './lib/draco-module-loader';\nimport {VERSION} from './lib/utils/version';\nimport {isBrowser} from '@loaders.gl/worker-utils';\n\n// Draco data types\n\nexport type {DracoMesh, DracoLoaderData};\n\n// Draco Writer\n\nexport type {DracoWriterOptions} from './draco-writer';\nexport {DracoWriter} from './draco-writer';\n\n/**\n * Browser worker doesn't work because of issue during \"draco_encoder.js\" loading.\n * Refused to execute script from 'https://raw.githubusercontent.com/google/draco/1.4.1/javascript/draco_encoder.js' because its MIME type ('') is not executable.\n */\nexport const DracoWriterWorker = {\n  id: isBrowser ? 'draco-writer' : 'draco-writer-nodejs',\n  name: 'Draco compressed geometry writer',\n  module: 'draco',\n  version: VERSION,\n  worker: true,\n  options: {\n    draco: {},\n    source: null\n  }\n};\n\n// Draco Loader\n\nexport type {DracoLoaderOptions};\nexport {DracoWorkerLoader};\n\n/**\n * Loader for Draco3D compressed geometries\n */\nexport const DracoLoader = {\n  ...DracoWorkerLoader,\n  parse\n};\n\nasync function parse(arrayBuffer: ArrayBuffer, options?: DracoLoaderOptions): Promise<DracoMesh> {\n  const {draco} = await loadDracoDecoderModule(options);\n  const dracoParser = new DracoParser(draco);\n  try {\n    return dracoParser.parseSync(arrayBuffer, options?.draco);\n  } finally {\n    dracoParser.destroy();\n  }\n}\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckDracoLoader: LoaderWithParser = DracoLoader;\n", "// Subset of WebGL constants\n\nexport const GL_PRIMITIVE = {\n  POINTS: 0x0000, // Points. single points.\n  LINES: 0x0001, // Lines. Each vertex connects to the one after it.\n  TRIANGLES: 0x0004 // Triangles. Each set of three vertices creates a separate triangle.\n};\n\n// Primitive modes\nexport const GL_PRIMITIVE_MODE = {\n  POINTS: 0x0000, // Points. single points.\n  LINES: 0x0001, // Lines. Each vertex connects to the one after it.\n  LINE_LOOP: 0x0002, // Lines. Each set of two vertices is treated as a separate line segment.\n  LINE_STRIP: 0x0003, // Lines/ a connected group of line segments from the first vertex to the last\n  TRIANGLES: 0x0004, // Triangles. Each set of three vertices creates a separate triangle.\n  TRIANGLE_STRIP: 0x0005, // Triangles. A connected group of triangles.\n  TRIANGLE_FAN: 0x0006 // Triangles. A connected group of triangles.\n  // Each vertex connects to the previous and the first vertex in the fan.\n};\n\ntype glType = {\n  BYTE: number;\n  UNSIGNED_BYTE: number;\n  SHORT: number;\n  UNSIGNED_SHORT: number;\n  INT: number;\n  UNSIGNED_INT: number;\n  FLOAT: number;\n  DOUBLE: number;\n};\n\nexport const GL_TYPE: glType = {\n  BYTE: 5120,\n  UNSIGNED_BYTE: 5121,\n  SHORT: 5122,\n  UNSIGNED_SHORT: 5123,\n  INT: 5124,\n  UNSIGNED_INT: 5125,\n  FLOAT: 5126,\n  DOUBLE: 5130\n};\n\nexport const GL = {\n  ...GL_PRIMITIVE_MODE,\n  ...GL_TYPE\n};\n", "import type {TypedArray} from '@math.gl/core';\nimport {GL_TYPE as GL} from '../constants';\n\nconst GL_TYPE_TO_ARRAY_TYPE = {\n  [GL.DOUBLE]: Float64Array,\n  [GL.FLOAT]: Float32Array,\n  [GL.UNSIGNED_SHORT]: Uint16Array,\n  [GL.UNSIGNED_INT]: Uint32Array,\n  [GL.UNSIGNED_BYTE]: Uint8Array,\n  [GL.BYTE]: Int8Array,\n  [GL.SHORT]: Int16Array,\n  [GL.INT]: Int32Array\n};\ntype GlTypeMap = {\n  [index: string]: number;\n};\nconst NAME_TO_GL_TYPE: GlTypeMap = {\n  DOUBLE: GL.DOUBLE,\n  FLOAT: GL.FLOAT,\n  UNSIGNED_SHORT: GL.UNSIGNED_SHORT,\n  UNSIGNED_INT: GL.UNSIGNED_INT,\n  UNSIGNED_BYTE: GL.UNSIGNED_BYTE,\n  BYTE: GL.BYTE,\n  SHORT: GL.SHORT,\n  INT: GL.INT\n};\nconst ERR_TYPE_CONVERSION = 'Failed to convert GL type';\n// Converts TYPED ARRAYS to corresponding GL constant\n// Used to auto deduce gl parameter types\nexport default class GLType {\n  // Signature: fromTypedArray(new Uint8Array())\n  // Signature: fromTypedArray(Uint8Array)\n  /**\n   * Returns the size, in bytes, of the corresponding datatype\n   * @param arrayOrType\n   * @returns glType a a string\n   */\n  static fromTypedArray(arrayOrType: TypedArray | Function): string {\n    // If typed array, look up constructor\n    arrayOrType = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;\n    for (const glType in GL_TYPE_TO_ARRAY_TYPE) {\n      const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n      if (ArrayType === arrayOrType) {\n        return glType;\n      }\n    }\n    throw new Error(ERR_TYPE_CONVERSION);\n  }\n  /**\n   * Extracts name for glType from array NAME_TO_GL_TYPE\n   * @param name\n   * @returns glType as a number\n   */\n  static fromName(name: string): number {\n    const glType = NAME_TO_GL_TYPE[name];\n    if (!glType) {\n      throw new Error(ERR_TYPE_CONVERSION);\n    }\n    return glType;\n  }\n  // Converts GL constant to corresponding typed array type\n  // eslint-disable-next-line complexity\n  static getArrayType(glType: number) {\n    switch (glType) {\n      /*eslint-disable*/\n      // @ts-ignore\n      case GL.UNSIGNED_SHORT_5_6_5:\n      // @ts-ignore\n      case GL.UNSIGNED_SHORT_4_4_4_4:\n      // @ts-ignore\n      case GL.UNSIGNED_SHORT_5_5_5_1:\n        /* eslint-enable*/\n        return Uint16Array;\n      default:\n        const ArrayType = GL_TYPE_TO_ARRAY_TYPE[glType];\n        if (!ArrayType) {\n          throw new Error(ERR_TYPE_CONVERSION);\n        }\n        return ArrayType;\n    }\n  }\n  /**\n   * Returns the size in bytes of one element of the provided WebGL type\n   * @param glType\n   * @returns size of glType\n   */\n  static getByteSize(glType: number): number {\n    const ArrayType = GLType.getArrayType(glType);\n    return ArrayType.BYTES_PER_ELEMENT;\n  }\n  /**\n   * Returns `true` if `glType` is a valid WebGL data type.\n   * @param glType\n   * @returns boolean\n   */\n  static validate(glType: number): boolean {\n    return Boolean(GLType.getArrayType(glType));\n  }\n  /**\n   * Creates a typed view of an array of bytes\n   * @param glType The type of typed array (ArrayBuffer view) to create\n   * @param buffer The buffer storage to use for the view.\n   * @param byteOffset The offset, in bytes, to the first element in the view\n   * @param length The number of elements in the view. Defaults to buffer length\n   * @returns A typed array view of the buffer\n   */\n  static createTypedArray(\n    glType: number,\n    buffer: TypedArray,\n    byteOffset: number = 0,\n    length?: number\n  ): TypedArray {\n    if (length === undefined) {\n      length = (buffer.byteLength - byteOffset) / GLType.getByteSize(glType);\n    }\n    const ArrayType = GLType.getArrayType(glType);\n    return new ArrayType(buffer, byteOffset, length);\n  }\n}\n", "/**\n * Throws error message\n * @param condition checks if an attribute equal to condition\n * @param message error message\n */\nexport function assert(condition: any, message?: any): void {\n  if (!condition) {\n    throw new Error(`math.gl assertion failed. ${message}`);\n  }\n}\n", "/**\n * Decode color values\n * @param rgb565\n * @param target\n * @returns target\n */\nexport function decodeRGB565(rgb565: number, target: number[] = [0, 0, 0]): number[] {\n  const r5 = (rgb565 >> 11) & 31;\n  const g6 = (rgb565 >> 5) & 63;\n  const b5 = rgb565 & 31;\n\n  target[0] = r5 << 3;\n  target[1] = g6 << 2;\n  target[2] = b5 << 3;\n\n  return target;\n}\n\n/**\n * Encode color values\n * @param rgb\n * @returns color\n */\nexport function encodeRGB565(rgb: number[]): number {\n  const r5 = Math.floor(rgb[0] / 8) + 4;\n  const g6 = Math.floor(rgb[1] / 4) + 2;\n  const b5 = Math.floor(rgb[2] / 8) + 4;\n  return r5 + (g6 << 5) + (b5 << 11);\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n// Attribute compression and decompression functions.\n\nimport {Vector2, Vector3, clamp, _MathUtils} from '@math.gl/core';\nimport {assert} from '../utils/assert';\n\ntype Vector4 = {\n  x: number;\n  y: number;\n  z: number;\n  w: number;\n};\n\nconst RIGHT_SHIFT = 1.0 / 256.0;\nconst LEFT_SHIFT = 256.0;\n\nconst scratchVector2 = new Vector2();\nconst scratchVector3 = new Vector3();\nconst scratchEncodeVector2 = new Vector2();\nconst octEncodeScratch = new Vector2();\n\nconst uint8ForceArray = new Uint8Array(1);\n\n/**\n * Force a value to Uint8\n *\n * @param value\n * @returns\n */\nfunction forceUint8(value: number): number {\n  uint8ForceArray[0] = value;\n  return uint8ForceArray[0];\n}\n\n/**\n * Converts a SNORM value in the range [0, rangeMaximum] to a scalar in the range [-1.0, 1.0].\n *\n * @param value SNORM value in the range [0, rangeMaximum]\n * @param [rangeMaximum=255] The maximum value in the SNORM range, 255 by default.\n * @returns Scalar in the range [-1.0, 1.0].\n *\n * @see CesiumMath.toSNorm\n */\nfunction fromSNorm(value: number, rangeMaximum = 255): number {\n  return (clamp(value, 0.0, rangeMaximum) / rangeMaximum) * 2.0 - 1.0;\n}\n\n/**\n * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMaximum].\n *\n * @param value The scalar value in the range [-1.0, 1.0]\n * @param [rangeMaximum=255] The maximum value in the mapped range, 255 by default.\n * @returns A SNORM value, where 0 maps to -1.0 and rangeMaximum maps to 1.0.\n *\n * @see CesiumMath.fromSNorm\n */\nfunction toSNorm(value: number, rangeMaximum = 255): number {\n  return Math.round((clamp(value, -1.0, 1.0) * 0.5 + 0.5) * rangeMaximum);\n}\n\n/**\n * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.\n * This is similar to `Math.sign` except that returns 1.0 instead of\n * 0.0 when the input value is 0.0.\n *\n * @param value The value to return the sign of.\n * @returns The sign of value.\n */\nfunction signNotZero(value: number): number {\n  return value < 0.0 ? -1.0 : 1.0;\n}\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-rangeMax] following the 'oct' encoding.\n *\n * Oct encoding is a compact representation of unit length vectors.\n * The 'oct' encoding is described in \"A Survey of Efficient Representations of Independent Unit Vectors\",\n * Cigolle et al 2014: {@link http://jcgt.org/published/0003/02/01/}\n *\n * @param vector The normalized vector to be compressed into 2 component 'oct' encoding.\n * @param result The 2 component oct-encoded unit length vector.\n * @param rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @returns The 2 component oct-encoded unit length vector.\n *\n * @exception vector must be normalized.\n *\n * @see octDecodeInRange\n */\nexport function octEncodeInRange(vector: Vector3, rangeMax: number, result: Vector2): Vector2 {\n  assert(vector);\n  assert(result);\n\n  const vector3 = scratchVector3.from(vector);\n\n  assert(Math.abs(vector3.magnitudeSquared() - 1.0) <= _MathUtils.EPSILON6);\n\n  result.x = vector.x / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n  result.y = vector.y / (Math.abs(vector.x) + Math.abs(vector.y) + Math.abs(vector.z));\n\n  if (vector.z < 0) {\n    const x = result.x;\n    const y = result.y;\n    result.x = (1.0 - Math.abs(y)) * signNotZero(x);\n    result.y = (1.0 - Math.abs(x)) * signNotZero(y);\n  }\n\n  result.x = toSNorm(result.x, rangeMax);\n  result.y = toSNorm(result.y, rangeMax);\n\n  return result;\n}\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding.\n *\n * @param vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @param result The 2 byte oct-encoded unit length vector.\n * @returns he 2 byte oct-encoded unit length vector.\n *\n * @exception vector must be normalized.\n *\n * @see octEncodeInRange\n * @see octDecode\n */\nexport function octEncode(vector: Vector3, result: Vector2): Vector2 {\n  return octEncodeInRange(vector, 255, result);\n}\n\n/**\n * Encodes a normalized vector into 4-byte vector\n * @param vector The normalized vector to be compressed into 4 byte 'oct' encoding.\n * @param result The 4 byte oct-encoded unit length vector.\n * @returns The 4 byte oct-encoded unit length vector.\n *\n * @exception vector must be normalized.\n *\n * @see octEncodeInRange\n * @see octDecodeFromVector4\n */\nexport function octEncodeToVector4(vector: Vector3, result: Vector4): Vector4 {\n  octEncodeInRange(vector, 65535, octEncodeScratch);\n  result.x = forceUint8(octEncodeScratch.x * RIGHT_SHIFT);\n  result.y = forceUint8(octEncodeScratch.x);\n  result.z = forceUint8(octEncodeScratch.y * RIGHT_SHIFT);\n  result.w = forceUint8(octEncodeScratch.y);\n  return result;\n}\n\n/**\n * Decodes a unit-length vector in 'oct' encoding to a normalized 3-component vector.\n *\n * @param x The x component of the oct-encoded unit length vector.\n * @param y The y component of the oct-encoded unit length vector.\n * @param rangeMax The maximum value of the SNORM range. The encoded vector is stored in log2(rangeMax+1) bits.\n * @param result The decoded and normalized vector\n * @returns The decoded and normalized vector.\n *\n * @exception x and y must be unsigned normalized integers between 0 and rangeMax.\n *\n * @see octEncodeInRange\n */\nexport function octDecodeInRange(x: number, y: number, rangeMax: number, result: Vector3): Vector3 {\n  assert(result);\n  if (x < 0 || x > rangeMax || y < 0 || y > rangeMax) {\n    throw new Error(`x and y must be unsigned normalized integers between 0 and ${rangeMax}`);\n  }\n\n  result.x = fromSNorm(x, rangeMax);\n  result.y = fromSNorm(y, rangeMax);\n  result.z = 1.0 - (Math.abs(result.x) + Math.abs(result.y));\n\n  if (result.z < 0.0) {\n    const oldVX = result.x;\n    result.x = (1.0 - Math.abs(result.y)) * signNotZero(oldVX);\n    result.y = (1.0 - Math.abs(oldVX)) * signNotZero(result.y);\n  }\n\n  return result.normalize();\n}\n\n/**\n * Decodes a unit-length vector in 2 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param x The x component of the oct-encoded unit length vector.\n * @param y The y component of the oct-encoded unit length vector.\n * @param result The decoded and normalized vector.\n * @returns he decoded and normalized vector.\n *\n * @exception x and y must be an unsigned normalized integer between 0 and 255.\n *\n * @see octDecodeInRange\n */\nexport function octDecode(x: number, y: number, result: Vector3): Vector3 {\n  return octDecodeInRange(x, y, 255, result);\n}\n\n/**\n * Decodes a unit-length vector in 4 byte 'oct' encoding to a normalized 3-component vector.\n *\n * @param encoded The oct-encoded unit length vector.\n * @param esult The decoded and normalized vector.\n * @returns The decoded and normalized vector.\n *\n * @exception x, y, z, and w must be unsigned normalized integers between 0 and 255.\n *\n * @see octDecodeInRange\n * @see octEncodeToVector4\n */\nexport function octDecodeFromVector4(encoded: Vector4, result: Vector3): Vector3 {\n  assert(encoded);\n  assert(result);\n  const x = encoded.x;\n  const y = encoded.y;\n  const z = encoded.z;\n  const w = encoded.w;\n\n  if (x < 0 || x > 255 || y < 0 || y > 255 || z < 0 || z > 255 || w < 0 || w > 255) {\n    throw new Error('x, y, z, and w must be unsigned normalized integers between 0 and 255');\n  }\n\n  const xOct16 = x * LEFT_SHIFT + y;\n  const yOct16 = z * LEFT_SHIFT + w;\n  return octDecodeInRange(xOct16, yOct16, 65535, result);\n}\n\n/**\n * Packs an oct encoded vector into a single floating-point number.\n *\n * @param encoded The oct encoded vector.\n * @returns The oct encoded vector packed into a single float.\n *\n */\nexport function octPackFloat(encoded: Vector2): number {\n  const vector2 = scratchVector2.from(encoded);\n  return 256.0 * vector2.x + vector2.y;\n}\n\n/**\n * Encodes a normalized vector into 2 SNORM values in the range of [0-255] following the 'oct' encoding and\n * stores those values in a single float-point number.\n *\n * @param vector The normalized vector to be compressed into 2 byte 'oct' encoding.\n * @returns The 2 byte oct-encoded unit length vector.\n *\n * @exception vector must be normalized.\n */\nexport function octEncodeFloat(vector: Vector3): number {\n  octEncode(vector, scratchEncodeVector2);\n  return octPackFloat(scratchEncodeVector2);\n}\n\n/**\n * Decodes a unit-length vector in 'oct' encoding packed in a floating-point number to a normalized 3-component vector.\n *\n * @param value The oct-encoded unit length vector stored as a single floating-point number.\n * @param result The decoded and normalized vector\n * @returns The decoded and normalized vector.\n *\n */\nexport function octDecodeFloat(value: number, result: Vector3): Vector3 {\n  assert(Number.isFinite(value));\n\n  const temp = value / 256.0;\n  const x = Math.floor(temp);\n  const y = (temp - x) * 256.0;\n\n  return octDecode(x, y, result);\n}\n\n/**\n * Encodes three normalized vectors into 6 SNORM values in the range of [0-255] following the 'oct' encoding and\n * packs those into two floating-point numbers.\n *\n * @param v1 A normalized vector to be compressed.\n * @param v2 A normalized vector to be compressed.\n * @param v3 A normalized vector to be compressed.\n * @param result The 'oct' encoded vectors packed into two floating-point numbers.\n * @returns The 'oct' encoded vectors packed into two floating-point numbers.\n *\n */\nexport function octPack(v1: Vector3, v2: Vector3, v3: Vector3, result: Vector2): Vector2 {\n  assert(v1);\n  assert(v2);\n  assert(v3);\n  assert(result);\n\n  const encoded1 = octEncodeFloat(v1);\n  const encoded2 = octEncodeFloat(v2);\n\n  const encoded3 = octEncode(v3, scratchEncodeVector2);\n  result.x = 65536.0 * encoded3.x + encoded1;\n  result.y = 65536.0 * encoded3.y + encoded2;\n  return result;\n}\n\n/**\n * Decodes three unit-length vectors in 'oct' encoding packed into a floating-point number to a normalized 3-component vector.\n *\n * @param packed The three oct-encoded unit length vectors stored as two floating-point number.\n * @param v1 One decoded and normalized vector.\n * @param v2 One decoded and normalized vector.\n * @param v3 One decoded and normalized vector.\n */\nexport function octUnpack(packed: Vector2, v1: Vector3, v2: Vector3, v3: Vector3): void {\n  let temp = packed.x / 65536.0;\n  const x = Math.floor(temp);\n  const encodedFloat1 = (temp - x) * 65536.0;\n\n  temp = packed.y / 65536.0;\n  const y = Math.floor(temp);\n  const encodedFloat2 = (temp - y) * 65536.0;\n\n  octDecodeFloat(encodedFloat1, v1);\n  octDecodeFloat(encodedFloat2, v2);\n  octDecode(x, y, v3);\n}\n\n/**\n * Pack texture coordinates into a single float. The texture coordinates will only preserve 12 bits of precision.\n *\n * @param textureCoordinates The texture coordinates to compress.  Both coordinates must be in the range 0.0-1.0.\n * @returns The packed texture coordinates.\n *\n */\nexport function compressTextureCoordinates(textureCoordinates: Vector2): number {\n  // Move x and y to the range 0-4095;\n  const x = (textureCoordinates.x * 4095.0) | 0;\n  const y = (textureCoordinates.y * 4095.0) | 0;\n  return 4096.0 * x + y;\n}\n\n/**\n * Decompresses texture coordinates that were packed into a single float.\n *\n * @param compressed The compressed texture coordinates.\n * @param result The decompressed texture coordinates.\n * @returns The modified result parameter.\n *\n */\nexport function decompressTextureCoordinates(compressed: number, result: Vector2): Vector2 {\n  const temp = compressed / 4096.0;\n  const xZeroTo4095 = Math.floor(temp);\n  result.x = xZeroTo4095 / 4095.0;\n  result.y = (compressed - xZeroTo4095 * 4096) / 4095;\n  return result;\n}\n\n/**\n * Decodes delta and ZigZag encoded vertices. This modifies the buffers in place.\n *\n * @param uBuffer The buffer view of u values.\n * @param vBuffer The buffer view of v values.\n * @param [heightBuffer] The buffer view of height values.\n *\n * @link https://github.com/AnalyticalGraphicsInc/quantized-mesh|quantized-mesh-1.0 terrain format\n */\nexport function zigZagDeltaDecode(\n  uBuffer: Uint16Array,\n  vBuffer: Uint16Array,\n  heightBuffer?: Uint16Array | number[]\n) {\n  assert(uBuffer);\n  assert(vBuffer);\n  assert(uBuffer.length === vBuffer.length);\n  if (heightBuffer) {\n    assert(uBuffer.length === heightBuffer.length);\n  }\n\n  function zigZagDecode(value: number) {\n    return (value >> 1) ^ -(value & 1);\n  }\n\n  let u = 0;\n  let v = 0;\n  let height = 0;\n\n  for (let i = 0; i < uBuffer.length; ++i) {\n    u += zigZagDecode(uBuffer[i]);\n    v += zigZagDecode(vBuffer[i]);\n\n    uBuffer[i] = u;\n    vBuffer[i] = v;\n\n    if (heightBuffer) {\n      height += zigZagDecode(heightBuffer[i]);\n      heightBuffer[i] = height;\n    }\n  }\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {GL, GLType} from '@loaders.gl/math';\n\n// Reference:\n// https://github.com/AnalyticalGraphicsInc/cesium/blob/1de96d087f0b17575eb1a3f736407b348c765d59/Source/Scene/Cesium3DTileFeatureTable.js\nexport default class Tile3DFeatureTable {\n  json;\n  buffer;\n  featuresLength = 0;\n  _cachedTypedArrays = {};\n\n  constructor(featureTableJson, featureTableBinary) {\n    this.json = featureTableJson;\n    this.buffer = featureTableBinary;\n  }\n\n  getExtension(extensionName) {\n    return this.json.extensions && this.json.extensions[extensionName];\n  }\n\n  hasProperty(propertyName) {\n    return Boolean(this.json[propertyName]);\n  }\n\n  getGlobalProperty(propertyName, componentType = GL.UNSIGNED_INT, componentLength = 1) {\n    const jsonValue = this.json[propertyName];\n\n    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {\n      return this._getTypedArrayFromBinary(\n        propertyName,\n        componentType,\n        componentLength,\n        1,\n        jsonValue.byteOffset\n      );\n    }\n\n    return jsonValue;\n  }\n\n  getPropertyArray(propertyName, componentType, componentLength) {\n    const jsonValue = this.json[propertyName];\n\n    if (jsonValue && Number.isFinite(jsonValue.byteOffset)) {\n      if ('componentType' in jsonValue) {\n        componentType = GLType.fromName(jsonValue.componentType);\n      }\n      return this._getTypedArrayFromBinary(\n        propertyName,\n        componentType,\n        componentLength,\n        this.featuresLength,\n        jsonValue.byteOffset\n      );\n    }\n\n    return this._getTypedArrayFromArray(propertyName, componentType, jsonValue);\n  }\n\n  getProperty(propertyName, componentType, componentLength, featureId, result) {\n    const jsonValue = this.json[propertyName];\n    if (!jsonValue) {\n      return jsonValue;\n    }\n\n    const typedArray = this.getPropertyArray(propertyName, componentType, componentLength);\n\n    if (componentLength === 1) {\n      return typedArray[featureId];\n    }\n\n    for (let i = 0; i < componentLength; ++i) {\n      result[i] = typedArray[componentLength * featureId + i];\n    }\n\n    return result;\n  }\n\n  // HELPERS\n\n  _getTypedArrayFromBinary(propertyName, componentType, componentLength, count, byteOffset) {\n    const cachedTypedArrays = this._cachedTypedArrays;\n    let typedArray = cachedTypedArrays[propertyName];\n    if (!typedArray) {\n      typedArray = GLType.createTypedArray(\n        componentType,\n        this.buffer.buffer,\n        this.buffer.byteOffset + byteOffset,\n        count * componentLength\n      );\n      cachedTypedArrays[propertyName] = typedArray;\n    }\n    return typedArray;\n  }\n\n  _getTypedArrayFromArray(propertyName, componentType, array) {\n    const cachedTypedArrays = this._cachedTypedArrays;\n    let typedArray = cachedTypedArrays[propertyName];\n    if (!typedArray) {\n      typedArray = GLType.createTypedArray(componentType, array);\n      cachedTypedArrays[propertyName] = typedArray;\n    }\n    return typedArray;\n  }\n}\n", "import {GLType} from '@loaders.gl/math'; // '@math.gl/geometry';\nimport {assert} from '@loaders.gl/loader-utils';\n\nconst COMPONENTS_PER_ATTRIBUTE = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\n// TODO - could just return typed array views...\n// prettier-ignore\nconst UNPACKER = {\n  SCALAR: (values, i) => values[i],\n  VEC2: (values, i) => [values[2 * i + 0], values[2 * i + 1]],\n  VEC3: (values, i) => [values[3 * i + 0], values[3 * i + 1], values[3 * i + 2]],\n  VEC4: (values, i) => [values[4 * i + 0], values[4 * i + 1], values[4 * i + 2], values[4 * i + 3]],\n  // TODO: check column major\n  MAT2: (values, i) => [\n    values[4 * i + 0], values[4 * i + 1],\n    values[4 * i + 2], values[4 * i + 3]\n  ],\n  MAT3: (values, i) => [\n    values[9 * i + 0], values[9 * i + 1], values[9 * i + 2],\n    values[9 * i + 3], values[9 * i + 4], values[9 * i + 5],\n    values[9 * i + 6], values[9 * i + 7], values[9 * i + 8]\n  ],\n  MAT4: (values, i) => [\n    values[16 * i + 0], values[16 * i + 1], values[16 * i + 2], values[16 * i + 3],\n    values[16 * i + 4], values[16 * i + 5], values[16 * i + 6], values[16 * i + 7],\n    values[16 * i + 8], values[16 * i + 9], values[16 * i + 10], values[16 * i + 11],\n    values[16 * i + 12], values[16 * i + 13], values[16 * i + 14], values[16 * i + 15]\n  ]\n};\n\nconst PACKER = {\n  SCALAR: (x, values, i) => {\n    values[i] = x;\n  },\n  VEC2: (x, values, i) => {\n    values[2 * i + 0] = x[0];\n    values[2 * i + 1] = x[1];\n  },\n  VEC3: (x, values, i) => {\n    values[3 * i + 0] = x[0];\n    values[3 * i + 1] = x[1];\n    values[3 * i + 2] = x[2];\n  },\n  VEC4: (x, values, i) => {\n    values[4 * i + 0] = x[0];\n    values[4 * i + 1] = x[1];\n    values[4 * i + 2] = x[2];\n    values[4 * i + 3] = x[3];\n  },\n  // TODO: check column major correctness\n  MAT2: (x, values, i) => {\n    values[4 * i + 0] = x[0];\n    values[4 * i + 1] = x[1];\n    values[4 * i + 2] = x[2];\n    values[4 * i + 3] = x[3];\n  },\n  MAT3: (x, values, i) => {\n    values[9 * i + 0] = x[0];\n    values[9 * i + 1] = x[1];\n    values[9 * i + 2] = x[2];\n    values[9 * i + 3] = x[3];\n    values[9 * i + 4] = x[4];\n    values[9 * i + 5] = x[5];\n    values[9 * i + 6] = x[6];\n    values[9 * i + 7] = x[7];\n    values[9 * i + 8] = x[8];\n    values[9 * i + 9] = x[9];\n  },\n  MAT4: (x, values, i) => {\n    values[16 * i + 0] = x[0];\n    values[16 * i + 1] = x[1];\n    values[16 * i + 2] = x[2];\n    values[16 * i + 3] = x[3];\n    values[16 * i + 4] = x[4];\n    values[16 * i + 5] = x[5];\n    values[16 * i + 6] = x[6];\n    values[16 * i + 7] = x[7];\n    values[16 * i + 8] = x[8];\n    values[16 * i + 9] = x[9];\n    values[16 * i + 10] = x[10];\n    values[16 * i + 11] = x[11];\n    values[16 * i + 12] = x[12];\n    values[16 * i + 13] = x[13];\n    values[16 * i + 14] = x[14];\n    values[16 * i + 15] = x[15];\n  }\n};\n\nexport function createTypedArrayFromAccessor(tile3DAccessor, buffer, byteOffset, length) {\n  const {componentType} = tile3DAccessor;\n  assert(tile3DAccessor.componentType);\n  const type = typeof componentType === 'string' ? GLType.fromName(componentType) : componentType;\n  const size = COMPONENTS_PER_ATTRIBUTE[tile3DAccessor.type];\n  const unpacker = UNPACKER[tile3DAccessor.type];\n  const packer = PACKER[tile3DAccessor.type];\n\n  byteOffset += tile3DAccessor.byteOffset;\n  const values = GLType.createTypedArray(type, buffer, byteOffset, size * length);\n\n  return {\n    values,\n    type,\n    size,\n    unpacker,\n    packer\n  };\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n// TODO - Finish hierarchy suypport: this file is only half ported\n/* eslint-disable */\n// @ts-nocheck\nconst defined = (x) => x !== undefined;\n\nexport function initializeHierarchy(batchTable, jsonHeader, binaryBody) {\n  if (!jsonHeader) {\n    return null;\n  }\n\n  let hierarchy = batchTable.getExtension('3DTILES_batch_table_hierarchy');\n\n  const legacyHierarchy = jsonHeader.HIERARCHY;\n  if (legacyHierarchy) {\n    // eslint-disable-next-line\n    console.warn('3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy.');\n    jsonHeader.extensions = jsonHeader.extensions || {};\n    jsonHeader.extensions['3DTILES_batch_table_hierarchy'] = legacyHierarchy;\n    hierarchy = legacyHierarchy;\n  }\n\n  if (!hierarchy) {\n    return null;\n  }\n\n  return initializeHierarchyValues(hierarchy, binaryBody);\n}\n\n// eslint-disable-next-line max-statements\nfunction initializeHierarchyValues(hierarchyJson, binaryBody) {\n  let i;\n  let classId;\n  let binaryAccessor;\n\n  const instancesLength = hierarchyJson.instancesLength;\n  const classes = hierarchyJson.classes;\n  let classIds = hierarchyJson.classIds;\n  let parentCounts = hierarchyJson.parentCounts;\n  let parentIds = hierarchyJson.parentIds;\n  let parentIdsLength = instancesLength;\n\n  if (defined(classIds.byteOffset)) {\n    classIds.componentType = defaultValue(classIds.componentType, GL.UNSIGNED_SHORT);\n    classIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(classIds);\n    classIds = binaryAccessor.createArrayBufferView(\n      binaryBody.buffer,\n      binaryBody.byteOffset + classIds.byteOffset,\n      instancesLength\n    );\n  }\n\n  let parentIndexes;\n  if (defined(parentCounts)) {\n    if (defined(parentCounts.byteOffset)) {\n      parentCounts.componentType = defaultValue(parentCounts.componentType, GL.UNSIGNED_SHORT);\n      parentCounts.type = AttributeType.SCALAR;\n      binaryAccessor = getBinaryAccessor(parentCounts);\n      parentCounts = binaryAccessor.createArrayBufferView(\n        binaryBody.buffer,\n        binaryBody.byteOffset + parentCounts.byteOffset,\n        instancesLength\n      );\n    }\n    parentIndexes = new Uint16Array(instancesLength);\n    parentIdsLength = 0;\n    for (i = 0; i < instancesLength; ++i) {\n      parentIndexes[i] = parentIdsLength;\n      parentIdsLength += parentCounts[i];\n    }\n  }\n\n  if (defined(parentIds) && defined(parentIds.byteOffset)) {\n    parentIds.componentType = defaultValue(parentIds.componentType, GL.UNSIGNED_SHORT);\n    parentIds.type = AttributeType.SCALAR;\n    binaryAccessor = getBinaryAccessor(parentIds);\n    parentIds = binaryAccessor.createArrayBufferView(\n      binaryBody.buffer,\n      binaryBody.byteOffset + parentIds.byteOffset,\n      parentIdsLength\n    );\n  }\n\n  const classesLength = classes.length;\n  for (i = 0; i < classesLength; ++i) {\n    const classInstancesLength = classes[i].length;\n    const properties = classes[i].instances;\n    const binaryProperties = getBinaryProperties(classInstancesLength, properties, binaryBody);\n    classes[i].instances = combine(binaryProperties, properties);\n  }\n\n  const classCounts = new Array(classesLength).fill(0);\n  const classIndexes = new Uint16Array(instancesLength);\n  for (i = 0; i < instancesLength; ++i) {\n    classId = classIds[i];\n    classIndexes[i] = classCounts[classId];\n    ++classCounts[classId];\n  }\n\n  const hierarchy = {\n    classes,\n    classIds,\n    classIndexes,\n    parentCounts,\n    parentIndexes,\n    parentIds\n  };\n\n  validateHierarchy(hierarchy);\n\n  return hierarchy;\n}\n\n// HELPER CODE\n\n// Traverse over the hierarchy and process each instance with the endConditionCallback.\n// When the endConditionCallback returns a value, the traversal stops and that value is returned.\nexport function traverseHierarchy(hierarchy, instanceIndex, endConditionCallback) {\n  if (!hierarchy) {\n    return;\n  }\n\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  if (parentIds) {\n    return endConditionCallback(hierarchy, instanceIndex);\n  }\n  if (parentCounts > 0) {\n    return traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback);\n  }\n  return traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback);\n}\n\n// eslint-disable-next-line max-statements\nfunction traverseHierarchyMultipleParents(hierarchy, instanceIndex, endConditionCallback) {\n  const classIds = hierarchy.classIds;\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  const parentIndexes = hierarchy.parentIndexes;\n  const instancesLength = classIds.length;\n\n  // Ignore instances that have already been visited. This occurs in diamond inheritance situations.\n  // Use a marker value to indicate that an instance has been visited, which increments with each run.\n  // This is more efficient than clearing the visited array every time.\n  const visited = scratchVisited;\n  visited.length = Math.max(visited.length, instancesLength);\n  const visitedMarker = ++marker;\n\n  const stack = scratchStack;\n  stack.length = 0;\n  stack.push(instanceIndex);\n\n  while (stack.length > 0) {\n    instanceIndex = stack.pop();\n    if (visited[instanceIndex] === visitedMarker) {\n      // This instance has already been visited, stop traversal\n      continue;\n    }\n    visited[instanceIndex] = visitedMarker;\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentCount = parentCounts[instanceIndex];\n    const parentIndex = parentIndexes[instanceIndex];\n    for (let i = 0; i < parentCount; ++i) {\n      const parentId = parentIds[parentIndex + i];\n      // Stop the traversal when the instance has no parent (its parentId equals itself)\n      // else add the parent to the stack to continue the traversal.\n      if (parentId !== instanceIndex) {\n        stack.push(parentId);\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction traverseHierarchySingleParent(hierarchy, instanceIndex, endConditionCallback) {\n  let hasParent = true;\n  while (hasParent) {\n    const result = endConditionCallback(hierarchy, instanceIndex);\n    if (defined(result)) {\n      // The end condition was met, stop the traversal and return the result\n      return result;\n    }\n    const parentId = hierarchy.parentIds[instanceIndex];\n    hasParent = parentId !== instanceIndex;\n    instanceIndex = parentId;\n  }\n  throw new Error('traverseHierarchySingleParent');\n}\n\n// DEBUG CODE\n\nfunction validateHierarchy(hierarchy) {\n  const scratchValidateStack = [];\n\n  const classIds = hierarchy.classIds;\n  const instancesLength = classIds.length;\n\n  for (let i = 0; i < instancesLength; ++i) {\n    validateInstance(hierarchy, i, stack);\n  }\n}\n\nfunction validateInstance(hierarchy, instanceIndex, stack) {\n  const parentCounts = hierarchy.parentCounts;\n  const parentIds = hierarchy.parentIds;\n  const parentIndexes = hierarchy.parentIndexes;\n  const classIds = hierarchy.classIds;\n  const instancesLength = classIds.length;\n\n  if (!defined(parentIds)) {\n    // No need to validate if there are no parents\n    return;\n  }\n\n  assert(\n    instanceIndex < instancesLength,\n    `Parent index ${instanceIndex} exceeds the total number of instances: ${instancesLength}`\n  );\n  assert(\n    stack.indexOf(instanceIndex) === -1,\n    'Circular dependency detected in the batch table hierarchy.'\n  );\n\n  stack.push(instanceIndex);\n  const parentCount = defined(parentCounts) ? parentCounts[instanceIndex] : 1;\n  const parentIndex = defined(parentCounts) ? parentIndexes[instanceIndex] : instanceIndex;\n  for (let i = 0; i < parentCount; ++i) {\n    const parentId = parentIds[parentIndex + i];\n    // Stop the traversal when the instance has no parent (its parentId equals itself), else continue the traversal.\n    if (parentId !== instanceIndex) {\n      validateInstance(hierarchy, parentId, stack);\n    }\n  }\n  stack.pop(instanceIndex);\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {assert} from '@loaders.gl/loader-utils';\n\nimport {createTypedArrayFromAccessor} from './helpers/tile-3d-accessor-utils';\nimport {initializeHierarchy, traverseHierarchy} from './tile-3d-batch-table-hierarchy';\n\nfunction defined(x) {\n  return x !== undefined && x !== null;\n}\n\nconst clone = (x, y) => x;\n\n// These top level fields in the batch table json are not properties\nconst IGNORED_PROPERTY_FIELDS = {\n  HIERARCHY: true, // Deprecated HIERARCHY property\n  extensions: true,\n  extras: true\n};\n\n// The size of this array equals the maximum instance count among all loaded tiles, which has the potential to be large.\nexport default class Tile3DBatchTableParser {\n  json;\n  binary;\n  featureCount;\n  _extensions;\n  // Copy all top-level property fields from the json object, ignoring special fields\n  _properties;\n  _binaryProperties;\n  // TODO: hierarchy support is only partially implemented and not tested\n  _hierarchy;\n\n  constructor(json, binary, featureCount, options = {}) {\n    assert(featureCount >= 0);\n    this.json = json || {};\n    this.binary = binary;\n    this.featureCount = featureCount;\n\n    this._extensions = this.json?.extensions || {};\n\n    // Copy all top-level property fields from the json object, ignoring special fields\n    this._properties = {};\n    for (const propertyName in this.json) {\n      if (!IGNORED_PROPERTY_FIELDS[propertyName]) {\n        this._properties[propertyName] = this.json[propertyName];\n      }\n    }\n\n    this._binaryProperties = this._initializeBinaryProperties();\n\n    // TODO: hierarchy support is only partially implemented and not tested\n    if (options['3DTILES_batch_table_hierarchy']) {\n      this._hierarchy = initializeHierarchy(this, this.json, this.binary);\n    }\n  }\n\n  getExtension(extensionName) {\n    return this.json && this.json.extensions && this.json.extensions[extensionName];\n  }\n\n  memorySizeInBytes(): number {\n    return 0;\n  }\n\n  isClass(batchId, className: string): boolean {\n    this._checkBatchId(batchId);\n    assert(typeof className === 'string', className);\n\n    // extension: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      // PERFORMANCE_IDEA : cache results in the ancestor classes\n      //   to speed up this check if this area becomes a hotspot\n      // PERFORMANCE_IDEA : treat class names as integers for faster comparisons\n      const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n        const classId = hierarchy.classIds[instanceIndex];\n        const instanceClass = hierarchy.classes[classId];\n        return instanceClass.name === className;\n      });\n      return defined(result);\n    }\n\n    return false;\n  }\n\n  isExactClass(batchId, className) {\n    assert(typeof className === 'string', className);\n\n    return this.getExactClassName(batchId) === className;\n  }\n\n  getExactClassName(batchId) {\n    this._checkBatchId(batchId);\n\n    // extension: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      const classId = this._hierarchy.classIds[batchId];\n      const instanceClass = this._hierarchy.classes[classId];\n      return instanceClass.name;\n    }\n\n    return undefined;\n  }\n\n  hasProperty(batchId, name) {\n    this._checkBatchId(batchId);\n    assert(typeof name === 'string', name);\n\n    return defined(this._properties[name]) || this._hasPropertyInHierarchy(batchId, name);\n  }\n\n  getPropertyNames(batchId, results) {\n    this._checkBatchId(batchId);\n\n    results = defined(results) ? results : [];\n    results.length = 0;\n\n    const propertyNames = Object.keys(this._properties);\n    results.push(...propertyNames);\n\n    if (this._hierarchy) {\n      this._getPropertyNamesInHierarchy(batchId, results);\n    }\n\n    return results;\n  }\n\n  getProperty(batchId, name) {\n    this._checkBatchId(batchId);\n    assert(typeof name === 'string', name);\n\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n      if (defined(binaryProperty)) {\n        return this._getBinaryProperty(binaryProperty, batchId);\n      }\n    }\n\n    const propertyValues = this._properties[name];\n    if (defined(propertyValues)) {\n      return clone(propertyValues[batchId], true);\n    }\n\n    // EXTENSION: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      const hierarchyProperty = this._getHierarchyProperty(batchId, name);\n      if (defined(hierarchyProperty)) {\n        return hierarchyProperty;\n      }\n    }\n\n    return undefined;\n  }\n\n  setProperty(batchId, name, value) {\n    const featureCount = this.featureCount;\n\n    this._checkBatchId(batchId);\n    assert(typeof name === 'string', name);\n\n    if (this._binaryProperties) {\n      const binaryProperty = this._binaryProperties[name];\n      if (binaryProperty) {\n        this._setBinaryProperty(binaryProperty, batchId, value);\n        return;\n      }\n    }\n\n    // EXTENSION: 3DTILES_batch_table_hierarchy\n    if (this._hierarchy) {\n      if (this._setHierarchyProperty(this, batchId, name, value)) {\n        return;\n      }\n    }\n\n    let propertyValues = this._properties[name];\n    if (!defined(propertyValues)) {\n      // Property does not exist. Create it.\n      this._properties[name] = new Array(featureCount);\n      propertyValues = this._properties[name];\n    }\n\n    propertyValues[batchId] = clone(value, true);\n  }\n\n  // PRIVATE METHODS\n\n  _checkBatchId(batchId) {\n    const valid = batchId >= 0 && batchId < this.featureCount;\n    if (!valid) {\n      throw new Error('batchId not in range [0, featureCount - 1].');\n    }\n  }\n\n  _getBinaryProperty(binaryProperty, index) {\n    return binaryProperty.unpack(binaryProperty.typedArray, index);\n  }\n\n  _setBinaryProperty(binaryProperty, index, value) {\n    binaryProperty.pack(value, binaryProperty.typedArray, index);\n  }\n\n  _initializeBinaryProperties() {\n    let binaryProperties: Record<string, any> | null = null;\n    for (const name in this._properties) {\n      const property = this._properties[name];\n      const binaryProperty = this._initializeBinaryProperty(name, property);\n      // Store any information needed to access the binary data, including the typed array,\n      // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n      if (binaryProperty) {\n        binaryProperties = binaryProperties || {};\n        binaryProperties[name] = binaryProperty;\n      }\n    }\n    return binaryProperties;\n  }\n\n  _initializeBinaryProperty(name, property) {\n    if ('byteOffset' in property) {\n      // This is a binary property\n      const tile3DAccessor = property;\n\n      assert(this.binary, `Property ${name} requires a batch table binary.`);\n      assert(tile3DAccessor.type, `Property ${name} requires a type.`);\n\n      const accessor = createTypedArrayFromAccessor(\n        tile3DAccessor,\n        this.binary.buffer,\n        this.binary.byteOffset | 0,\n        this.featureCount\n      );\n\n      // Store any information needed to access the binary data, including the typed array,\n      // componentCount (e.g. a VEC4 would be 4), and the type used to pack and unpack (e.g. Cartesian4).\n      return {\n        typedArray: accessor.values,\n        componentCount: accessor.size,\n        unpack: accessor.unpacker,\n        pack: accessor.packer\n      };\n    }\n\n    return null;\n  }\n\n  //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy\n\n  _hasPropertyInHierarchy(batchId, name) {\n    if (!this._hierarchy) {\n      return false;\n    }\n\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n      return defined(instances[name]);\n    });\n\n    return defined(result);\n  }\n\n  _getPropertyNamesInHierarchy(batchId, results) {\n    traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instances = hierarchy.classes[classId].instances;\n      for (const name in instances) {\n        if (instances.hasOwnProperty(name)) {\n          if (results.indexOf(name) === -1) {\n            results.push(name);\n          }\n        }\n      }\n    });\n  }\n\n  _getHierarchyProperty(batchId, name) {\n    return traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n      if (defined(propertyValues)) {\n        if (defined(propertyValues.typedArray)) {\n          return this._getBinaryProperty(propertyValues, indexInClass);\n        }\n        return clone(propertyValues[indexInClass], true);\n      }\n      return null;\n    });\n  }\n\n  _setHierarchyProperty(batchTable, batchId, name, value) {\n    const result = traverseHierarchy(this._hierarchy, batchId, (hierarchy, instanceIndex) => {\n      const classId = hierarchy.classIds[instanceIndex];\n      const instanceClass = hierarchy.classes[classId];\n      const indexInClass = hierarchy.classIndexes[instanceIndex];\n      const propertyValues = instanceClass.instances[name];\n      if (defined(propertyValues)) {\n        assert(instanceIndex === batchId, `Inherited property \"${name}\" is read-only.`);\n        if (defined(propertyValues.typedArray)) {\n          this._setBinaryProperty(propertyValues, indexInClass, value);\n        } else {\n          propertyValues[indexInClass] = clone(value, true);\n        }\n        return true;\n      }\n      return false;\n    });\n    return defined(result);\n  }\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nconst SIZEOF_UINT32 = 4;\n\n/* PARSE FIXED HEADER:\nPopulates\n  magic, // identifies type of tile\n  type, // String version of magic\n  version,\n  byteLength\n */\nexport function parse3DTileHeaderSync(tile, arrayBuffer, byteOffset = 0) {\n  const view = new DataView(arrayBuffer);\n\n  tile.magic = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n\n  tile.version = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n\n  tile.byteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n\n  // TODO - move version check into each tile parser?\n  if (tile.version !== 1) {\n    throw new Error(`3D Tile Version ${tile.version} not supported`);\n  }\n\n  return byteOffset; // Indicates where the parsing ended\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {getStringFromArrayBuffer} from './parse-utils';\n\nconst SIZEOF_UINT32 = 4;\nconst DEPRECATION_WARNING = 'b3dm tile in legacy format.';\n\n// eslint-disable-next-line max-statements\nexport function parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset) {\n  const view = new DataView(arrayBuffer);\n  let batchLength;\n\n  tile.header = tile.header || {};\n\n  let featureTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n\n  let featureTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n\n  let batchTableJsonByteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n\n  let batchTableBinaryByteLength = view.getUint32(byteOffset, true);\n  byteOffset += SIZEOF_UINT32;\n\n  // First legacy header format - [batchLength] [batchTableByteLength] ('batchTableJsonByteLength': JSON starts with a quotation mark or the glTF magic)\n  // Second legacy format - [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength] (Second legacy format is similar as first but here we check 'batchTableBinaryByteLength' instead)\n  // Current header format - [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength]\n  // First byte will be 0x22 or 0x67. The minimum uint32 expected is 0x22000000 = 570425344 = 570MB.\n  if (batchTableJsonByteLength >= 570425344) {\n    byteOffset -= SIZEOF_UINT32 * 2;\n    batchLength = featureTableJsonByteLength;\n    batchTableJsonByteLength = featureTableBinaryByteLength;\n    batchTableBinaryByteLength = 0;\n    featureTableJsonByteLength = 0;\n    featureTableBinaryByteLength = 0;\n\n    console.warn(DEPRECATION_WARNING); // eslint-disable-line\n  } else if (batchTableBinaryByteLength >= 570425344) {\n    byteOffset -= SIZEOF_UINT32;\n    batchLength = batchTableJsonByteLength;\n    batchTableJsonByteLength = featureTableJsonByteLength;\n    batchTableBinaryByteLength = featureTableBinaryByteLength;\n    featureTableJsonByteLength = 0;\n    featureTableBinaryByteLength = 0;\n\n    console.warn(DEPRECATION_WARNING); // eslint-disable-line\n  }\n\n  tile.header.featureTableJsonByteLength = featureTableJsonByteLength;\n  tile.header.featureTableBinaryByteLength = featureTableBinaryByteLength;\n  tile.header.batchTableJsonByteLength = batchTableJsonByteLength;\n  tile.header.batchTableBinaryByteLength = batchTableBinaryByteLength;\n  tile.header.batchLength = batchLength;\n\n  return byteOffset;\n}\n\nexport function parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options) {\n  byteOffset = parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options);\n  byteOffset = parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options);\n  return byteOffset;\n}\n\nfunction parse3DTileFeatureTable(tile, arrayBuffer, byteOffset, options) {\n  const {featureTableJsonByteLength, featureTableBinaryByteLength, batchLength} = tile.header;\n\n  tile.featureTableJson = {\n    BATCH_LENGTH: batchLength || 0\n  };\n\n  if (featureTableJsonByteLength > 0) {\n    const featureTableString = getStringFromArrayBuffer(\n      arrayBuffer,\n      byteOffset,\n      featureTableJsonByteLength\n    );\n    tile.featureTableJson = JSON.parse(featureTableString);\n  }\n  byteOffset += featureTableJsonByteLength;\n\n  tile.featureTableBinary = new Uint8Array(arrayBuffer, byteOffset, featureTableBinaryByteLength);\n  byteOffset += featureTableBinaryByteLength;\n\n  /*\n  const featureTable = parseFeatureTable(featureTableJson, featureTableBinary);\n\n  const batchLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n  featureTable.featuresLength = batchLength;\n  */\n\n  return byteOffset;\n}\n\nfunction parse3DTileBatchTable(tile, arrayBuffer, byteOffset, options) {\n  const {batchTableJsonByteLength, batchTableBinaryByteLength} = tile.header;\n\n  if (batchTableJsonByteLength > 0) {\n    const batchTableString = getStringFromArrayBuffer(\n      arrayBuffer,\n      byteOffset,\n      batchTableJsonByteLength\n    );\n    tile.batchTableJson = JSON.parse(batchTableString);\n    byteOffset += batchTableJsonByteLength;\n\n    if (batchTableBinaryByteLength > 0) {\n      // Has a batch table binary\n      tile.batchTableBinary = new Uint8Array(arrayBuffer, byteOffset, batchTableBinaryByteLength);\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      tile.batchTableBinary = new Uint8Array(tile.batchTableBinary);\n\n      byteOffset += batchTableBinaryByteLength;\n    }\n  }\n\n  return byteOffset;\n}\n", "import {decodeRGB565, GL} from '@loaders.gl/math';\n\n/* eslint-disable complexity*/\nexport function normalize3DTileColorAttribute(tile, colors, batchTable?) {\n  // no colors defined\n  if (!colors && (!tile || !tile.batchIds || !batchTable)) {\n    return null;\n  }\n\n  const {batchIds, isRGB565, pointCount} = tile;\n  // Batch table, look up colors in table\n  if (batchIds && batchTable) {\n    const colorArray = new Uint8ClampedArray(pointCount * 3);\n    for (let i = 0; i < pointCount; i++) {\n      const batchId = batchIds[i];\n      // TODO figure out what is `dimensions` used for\n      const dimensions = batchTable.getProperty(batchId, 'dimensions');\n      const color = dimensions.map((d) => d * 255);\n      colorArray[i * 3] = color[0];\n      colorArray[i * 3 + 1] = color[1];\n      colorArray[i * 3 + 2] = color[2];\n    }\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  // RGB565 case, convert to RGB\n  if (isRGB565) {\n    const colorArray = new Uint8ClampedArray(pointCount * 3);\n    for (let i = 0; i < pointCount; i++) {\n      const color = decodeRGB565(colors[i]);\n      colorArray[i * 3] = color[0];\n      colorArray[i * 3 + 1] = color[1];\n      colorArray[i * 3 + 2] = color[2];\n    }\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colorArray,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  // RGB case (tile.isTranslucent)\n  if (colors && colors.length === pointCount * 3) {\n    return {\n      type: GL.UNSIGNED_BYTE,\n      value: colors,\n      size: 3,\n      normalized: true\n    };\n  }\n\n  // DEFAULT: RGBA case\n  return {\n    type: GL.UNSIGNED_BYTE,\n    value: colors,\n    size: 4,\n    normalized: true\n  };\n}\n/* eslint-enable complexity*/\n", "import {Vector3} from '@math.gl/core';\nimport {GL, octDecode} from '@loaders.gl/math';\n\nconst scratchNormal = new Vector3();\n\nexport function normalize3DTileNormalAttribute(tile, normals) {\n  if (!normals) {\n    return null;\n  }\n\n  if (tile.isOctEncoded16P) {\n    const decodedArray = new Float32Array(tile.pointsLength * 3);\n    for (let i = 0; i < tile.pointsLength; i++) {\n      octDecode(normals[i * 2], normals[i * 2 + 1], scratchNormal);\n      // @ts-ignore\n      scratchNormal.toArray(decodedArray, i * 3);\n    }\n\n    return {\n      type: GL.FLOAT,\n      size: 2,\n      value: decodedArray\n    };\n  }\n\n  return {\n    type: GL.FLOAT,\n    size: 2,\n    value: normals\n  };\n}\n", "import {Vector3} from '@math.gl/core';\nimport {GL} from '@loaders.gl/math';\n\n// Prepare attribute for positions\nexport function normalize3DTilePositionAttribute(tile, positions, options) {\n  if (!tile.isQuantized) {\n    return positions;\n  }\n\n  // For quantized posititions, either expand to Float32Array or return custom accessor\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/blob/master/specification/TileFormats/Instanced3DModel/README.md#quantized-positions\n\n  // Optionally decodes quantized positions on GPU, for simpler renderers that don't accept normalized attributes\n  if (options['3d-tiles'] && options['3d-tiles'].decodeQuantizedPositions) {\n    tile.isQuantized = false;\n    return decodeQuantizedPositions(tile, positions);\n  }\n\n  // Default: Use normalized shorts directly, no copying/processing.\n  // NOTE: The \"missing\" offset/scaling operations are automatically added to modelMatrix if `tile.isQuantized === true`\n  return {\n    type: GL.UNSIGNED_SHORT,\n    value: positions,\n    size: 3,\n    normalized: true\n  };\n}\n\n// Pre-scale quantized positions on CPU\nfunction decodeQuantizedPositions(tile, positions) {\n  const scratchPosition = new Vector3();\n  const decodedArray = new Float32Array(tile.pointCount * 3);\n\n  for (let i = 0; i < tile.pointCount; i++) {\n    // POSITION = POSITION_QUANTIZED / 65535.0 * QUANTIZED_VOLUME_SCALE + QUANTIZED_VOLUME_OFFSET\n    scratchPosition\n      .set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2])\n      .scale(1 / tile.quantizedRange)\n      .multiply(tile.quantizedVolumeScale)\n      .add(tile.quantizedVolumeOffset)\n      .toArray(decodedArray, i * 3);\n  }\n\n  return decodedArray;\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {GL} from '@loaders.gl/math';\nimport {Vector3} from '@math.gl/core';\n\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\nimport {parse3DTileHeaderSync} from './helpers/parse-3d-tile-header';\nimport {parse3DTileTablesHeaderSync, parse3DTileTablesSync} from './helpers/parse-3d-tile-tables';\nimport {normalize3DTileColorAttribute} from './helpers/normalize-3d-tile-colors';\nimport {normalize3DTileNormalAttribute} from './helpers/normalize-3d-tile-normals';\nimport {normalize3DTilePositionAttribute} from './helpers/normalize-3d-tile-positions';\n\nexport async function parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n  initializeTile(tile);\n\n  const {featureTable, batchTable} = parsePointCloudTables(tile);\n\n  await parseDraco(tile, featureTable, batchTable, options, context);\n\n  parsePositions(tile, featureTable, options);\n  parseColors(tile, featureTable, batchTable);\n  parseNormals(tile, featureTable);\n\n  return byteOffset;\n}\n\nfunction initializeTile(tile) {\n  // Initialize point cloud tile defaults\n  tile.attributes = {\n    positions: null,\n    colors: null,\n    normals: null,\n    batchIds: null\n  };\n  tile.isQuantized = false;\n  tile.isTranslucent = false;\n  tile.isRGB565 = false;\n  tile.isOctEncoded16P = false;\n}\n\nfunction parsePointCloudTables(tile) {\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n\n  const pointsLength = featureTable.getGlobalProperty('POINTS_LENGTH');\n  if (!Number.isFinite(pointsLength)) {\n    throw new Error('POINTS_LENGTH must be defined');\n  }\n  featureTable.featuresLength = pointsLength;\n\n  tile.featuresLength = pointsLength;\n  tile.pointsLength = pointsLength;\n  tile.pointCount = pointsLength;\n\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n\n  const batchTable = parseBatchIds(tile, featureTable);\n\n  return {featureTable, batchTable};\n}\n\nfunction parsePositions(tile, featureTable, options) {\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      const positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n\n      tile.isQuantized = true;\n      tile.quantizedRange = (1 << 16) - 1;\n\n      tile.quantizedVolumeScale = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_SCALE',\n        GL.FLOAT,\n        3\n      );\n      if (!tile.quantizedVolumeScale) {\n        throw new Error('QUANTIZED_VOLUME_SCALE must be defined for quantized positions.');\n      }\n\n      tile.quantizedVolumeOffset = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_OFFSET',\n        GL.FLOAT,\n        3\n      );\n      if (!tile.quantizedVolumeOffset) {\n        throw new Error('QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.');\n      }\n\n      tile.attributes.positions = normalize3DTilePositionAttribute(tile, positions, options);\n    }\n  }\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n\nfunction parseColors(tile, featureTable, batchTable) {\n  if (!tile.attributes.colors) {\n    let colors = null;\n    if (featureTable.hasProperty('RGBA')) {\n      colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasProperty('RGB565')) {\n      colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n\n    tile.attributes.colors = normalize3DTileColorAttribute(tile, colors, batchTable);\n  }\n\n  if (featureTable.hasProperty('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n}\n\nfunction parseNormals(tile, featureTable) {\n  if (!tile.attributes.normals) {\n    let normals = null;\n    if (featureTable.hasProperty('NORMAL')) {\n      normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('NORMAL_OCT16P')) {\n      normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n\n    tile.attributes.normals = normalize3DTileNormalAttribute(tile, normals);\n  }\n}\n\nfunction parseBatchIds(tile, featureTable) {\n  let batchTable: Tile3DBatchTable | null = null;\n  if (!tile.batchIds && featureTable.hasProperty('BATCH_ID')) {\n    tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n\n    if (tile.batchIds) {\n      const batchFeatureLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n      if (!batchFeatureLength) {\n        throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n      }\n      const {batchTableJson, batchTableBinary} = tile;\n      batchTable = new Tile3DBatchTable(batchTableJson, batchTableBinary, batchFeatureLength);\n    }\n  }\n  return batchTable;\n}\n\n// eslint-disable-next-line complexity\nasync function parseDraco(tile, featureTable, batchTable, options, context) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n  const batchTableDraco =\n    tile.batchTableJson &&\n    tile.batchTableJson.extensions &&\n    tile.batchTableJson.extensions['3DTILES_draco_point_compression'];\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !Number.isFinite(dracoByteOffset) || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = tile.featureTableBinary.slice(dracoByteOffset, dracoByteOffset + dracoByteLength);\n\n    tile.hasPositions = Number.isFinite(dracoFeatureTableProperties.POSITION);\n    tile.hasColors =\n      Number.isFinite(dracoFeatureTableProperties.RGB) ||\n      Number.isFinite(dracoFeatureTableProperties.RGBA);\n    tile.hasNormals = Number.isFinite(dracoFeatureTableProperties.NORMAL);\n    tile.hasBatchIds = Number.isFinite(dracoFeatureTableProperties.BATCH_ID);\n    tile.isTranslucent = Number.isFinite(dracoFeatureTableProperties.RGBA);\n  }\n\n  if (!dracoBuffer) {\n    return true;\n  }\n\n  const dracoData = {\n    buffer: dracoBuffer,\n    properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},\n    featureTableProperties: dracoFeatureTableProperties,\n    batchTableProperties: dracoBatchTableProperties,\n    dequantizeInShader: false\n  };\n\n  return await loadDraco(tile, dracoData, options, context);\n}\n\n// eslint-disable-next-line complexity, max-statements\nexport async function loadDraco(tile, dracoData, options, context) {\n  const {parse} = context;\n  const dracoOptions = {\n    ...options,\n    draco: {\n      ...options.draco,\n      extraAttributes: dracoData.batchTableProperties || {}\n    }\n  };\n\n  // The entire tileset might be included, too expensive to serialize\n  delete dracoOptions['3d-tiles'];\n\n  const data = await parse(dracoData.buffer, DracoLoader, dracoOptions);\n\n  const decodedPositions = data.attributes.POSITION && data.attributes.POSITION.value;\n  const decodedColors = data.attributes.COLOR_0 && data.attributes.COLOR_0.value;\n  const decodedNormals = data.attributes.NORMAL && data.attributes.NORMAL.value;\n  const decodedBatchIds = data.attributes.BATCH_ID && data.attributes.BATCH_ID.value;\n  const isQuantizedDraco = decodedPositions && data.attributes.POSITION.value.quantization;\n  const isOctEncodedDraco = decodedNormals && data.attributes.NORMAL.value.quantization;\n  if (isQuantizedDraco) {\n    // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n    // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n    const quantization = data.POSITION.data.quantization;\n    const range = quantization.range;\n    tile.quantizedVolumeScale = new Vector3(range, range, range);\n    tile.quantizedVolumeOffset = new Vector3(quantization.minValues);\n    tile.quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n    tile.isQuantizedDraco = true;\n  }\n  if (isOctEncodedDraco) {\n    tile.octEncodedRange = (1 << data.NORMAL.data.quantization.quantizationBits) - 1.0;\n    tile.isOctEncodedDraco = true;\n  }\n\n  // Extra batch table attributes\n  const batchTableAttributes = {};\n  if (dracoData.batchTableProperties) {\n    for (const attributeName of Object.keys(dracoData.batchTableProperties)) {\n      if (data.attributes[attributeName] && data.attributes[attributeName].value) {\n        batchTableAttributes[attributeName.toLowerCase()] = data.attributes[attributeName].value;\n      }\n    }\n  }\n\n  tile.attributes = {\n    positions: decodedPositions,\n    colors: normalize3DTileColorAttribute(tile, decodedColors, undefined),\n    normals: decodedNormals,\n    batchIds: decodedBatchIds,\n    ...batchTableAttributes\n  };\n}\n\n// TODO - this is the remaining code from Cesium's parser\n/*\n  const batchTable = new Tile3DBatchTable(tile);\n\n  // parseDracoBuffer(tile, featureTable, batchTable);\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n}\n/*\n\n  if (!tile.attributes.positions) {\n    if (featureTable.hasProperty('POSITION')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION', GL.FLOAT, 3);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      tile.attributes.positions = featureTable.getPropertyArray('POSITION_QUANTIZED', GL.UNSIGNED_SHORT, 3);\n\n\n  if (!tile.colors) {\n    if (featureTable.hasProperty('RGBA')) {\n      tile.colors = featureTable.getPropertyArray('RGBA', GL.UNSIGNED_BYTE, 4);\n      tile.isTranslucent = true;\n    } else if (featureTable.hasProperty('RGB')) {\n      tile.colors = featureTable.getPropertyArray('RGB', GL.UNSIGNED_BYTE, 3);\n    } else if (featureTable.hasPropertry('RGB565')) {\n      tile.colors = featureTable.getPropertyArray('RGB565', GL.UNSIGNED_SHORT, 1);\n      tile.isRGB565 = true;\n    }\n  }\n\n  if (!tile.attributes.normals) {\n    if (featureTable.getPropertry('NORMAL')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL', GL.FLOAT, 3);\n    } else if (featureTable.getProperty('NORMAL_OCT16P')) {\n      tile.attributes.normals = featureTable.getPropertyArray('NORMAL_OCT16P', GL.UNSIGNED_BYTE, 2);\n      tile.isOctEncoded16P = true;\n    }\n  }\n\n  if (!tile.batchIds) {\n    if (featureTable.hasProperty('BATCH_ID')) {\n      tile.batchIds = featureTable.getPropertyArray('BATCH_ID', GL.UNSIGNED_SHORT, 1);\n    }\n  }\n\n  if (!tile.attributes.positions) {\n    throw new Error('Either POSITION or POSITION_QUANTIZED must be defined.');\n  }\n\n  if (featureTable.getPropertry('CONSTANT_RGBA')) {\n    tile.constantRGBA = featureTable.getGlobalProperty('CONSTANT_RGBA', GL.UNSIGNED_BYTE, 4);\n  }\n\n  if (tile.batchIds) {\n    const batchLength = featureTable.getGlobalProperty('BATCH_LENGTH');\n    if (!defined(batchLength)) {\n      throw new Error('Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.');\n    }\n\n    if (defined(batchTableBinary)) {\n      // Copy the batchTableBinary section and let the underlying ArrayBuffer be freed\n      batchTableBinary = new Uint8Array(batchTableBinary);\n    }\n\n    if (defined(pointCloud._batchTableLoaded)) {\n      pointCloud._batchTableLoaded(batchLength, batchTableJson, batchTableBinary);\n    }\n  }\n\n  // If points are not batched and there are per-point properties, use these properties for styling purposes\n  var styleableProperties;\n  if (!hasBatchIds && defined(batchTableBinary)) {\n    tile.styleableProperties = Cesium3DTileBatchTable.getBinaryProperties(\n      pointsLength,\n      batchTableJson,\n      batchTableBinary\n    );\n  }\n\n  tile.draco = draco;\n}\n\n// Separate parsing and decoding of Draco\nexport function parseDracoBuffer(tile, featureTable, batchTable) {\n  let dracoBuffer;\n  let dracoFeatureTableProperties;\n  let dracoBatchTableProperties;\n\n  const batchTableDraco = batchTable.getExtension('3DTILES_draco_point_compression');\n  if (batchTableDraco) {\n    dracoBatchTableProperties = batchTableDraco.properties;\n  }\n\n  const featureTableDraco = featureTable.getExtension('3DTILES_draco_point_compression');\n  if (featureTableDraco) {\n    dracoFeatureTableProperties = featureTableDraco.properties;\n    const dracoByteOffset = featureTableDraco.byteOffset;\n    const dracoByteLength = featureTableDraco.byteLength;\n    if (!dracoFeatureTableProperties || !dracoByteOffset || !dracoByteLength) {\n      throw new Error('Draco properties, byteOffset, and byteLength must be defined');\n    }\n\n    dracoBuffer = arraySlice(\n      featureTableBinary,\n      dracoByteOffset,\n      dracoByteOffset + dracoByteLength\n    );\n    tile.hasPositions = dracoFeatureTableProperties.POSITION;\n    tile.hasColors = dracoFeatureTableProperties.RGB || dracoFeatureTableProperties.RGBA;\n    tile.hasNormals = dracoFeatureTableProperties.NORMAL;\n    tile.hasBatchIds = dracoFeatureTableProperties.BATCH_ID;\n    tile.isTranslucent = dracoFeatureTableProperties.RGBA;\n  }\n\n  if (dracoBuffer) {\n    tile.draco = {\n      buffer: dracoBuffer,\n      properties: {...dracoFeatureTableProperties, ...dracoBatchTableProperties},\n      featureTableProperties: dracoFeatureTableProperties,\n      batchTableProperties: dracoBatchTableProperties,\n      dequantizeInShader: false\n    };\n\n    tile.decodingState = DECODING_STATE.NEEDS_DECODE;\n  }\n}\n\n/*\nfunction decodeDraco(tile, context) {\n  if (tile.decodingState === DECODING_STATE.READY) {\n    return false;\n  }\n  if (tile.decodingState === DECODING_STATE.NEEDS_DECODE) {\n    var parsedContent = tile._parsedContent;\n    var draco = parsedContent.draco;\n    var decodePromise = DracoLoader.decodePointCloud(draco, context);\n    if (defined(decodePromise)) {\n      tile.decodingState = DECODING_STATE.DECODING;\n      decodePromise.then(function(result) {\n        tile.decodingState = DECODING_STATE.READY;\n        var decodedPositions = defined(result.POSITION) ? result.POSITION.array : undefined;\n        var decodedRgb = defined(result.RGB) ? result.RGB.array : undefined;\n        var decodedRgba = defined(result.RGBA) ? result.RGBA.array : undefined;\n        var decodedNormals = defined(result.NORMAL) ? result.NORMAL.array : undefined;\n        var decodedBatchIds = defined(result.BATCH_ID) ? result.BATCH_ID.array : undefined;\n        var isQuantizedDraco = defined(decodedPositions) && defined(result.POSITION.data.quantization);\n        var isOctEncodedDraco = defined(decodedNormals) && defined(result.NORMAL.data.quantization);\n        if (isQuantizedDraco) {\n          // Draco quantization range == quantized volume scale - size in meters of the quantized volume\n          // Internal quantized range is the range of values of the quantized data, e.g. 255 for 8-bit, 1023 for 10-bit, etc\n          var quantization = result.POSITION.data.quantization;\n          var range = quantization.range;\n          tile._quantizedVolumeScale = Cartesian3.fromElements(range, range, range);\n          tile._quantizedVolumeOffset = Cartesian3.unpack(quantization.minValues);\n          tile._quantizedRange = (1 << quantization.quantizationBits) - 1.0;\n          tile._isQuantizedDraco = true;\n        }\n        if (isOctEncodedDraco) {\n          tile._octEncodedRange = (1 << result.NORMAL.data.quantization.quantizationBits) - 1.0;\n          tile._isOctEncodedDraco = true;\n        }\n        var styleableProperties = parsedContent.styleableProperties;\n        var batchTableProperties = draco.batchTableProperties;\n        for (var name in batchTableProperties) {\n          if (batchTableProperties.hasOwnProperty(name)) {\n            var property = result[name];\n            if (!defined(styleableProperties)) {\n              styleableProperties = {};\n            }\n            styleableProperties[name] = {\n              typedArray : property.array,\n              componentCount : property.data.componentsPerAttribute\n            };\n          }\n        }\n        parsedContent.positions = defaultValue(decodedPositions, parsedContent.positions);\n        parsedContent.colors = defaultValue(defaultValue(decodedRgba, decodedRgb), parsedContent.colors);\n        parsedContent.normals = defaultValue(decodedNormals, parsedContent.normals);\n        parsedContent.batchIds = defaultValue(decodedBatchIds, parsedContent.batchIds);\n        parsedContent.styleableProperties = styleableProperties;\n      }).otherwise(function(error) {\n        tile.decodingState = DECODING_STATE.FAILED;\n        tile._readyPromise.reject(error);\n      });\n    }\n  }\n  return true;\n}\n*/\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\n", "// Version constant cannot be imported, it needs to correspond to the build version of **this** module.\n// __VERSION__ is injected by babel-plugin-version-inline\n// TODO: use 'latest' instead of 'beta' when 3.0.0 version is released as 'latest'\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nexport const VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'beta';\n", "// __VERSION__ is injected by babel-plugin-version-inline\n// @ts-ignore TS2304: Cannot find name '__VERSION__'.\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'beta';\n\n// @ts-nocheck\nimport {loadLibrary} from '@loaders.gl/worker-utils';\n\nconst BASIS_CDN_ENCODER_WASM = `https://unpkg.com/@loaders.gl/textures@${VERSION}/dist/libs/basis_encoder.wasm`;\nconst BASIS_CDN_ENCODER_JS = `https://unpkg.com/@loaders.gl/textures@${VERSION}/dist/libs/basis_encoder.js`;\n\nlet loadBasisTranscoderPromise;\n\n/**\n * Loads wasm transcoder module\n * @param options\n * @returns {BasisFile} promise\n */\nexport async function loadBasisTrascoderModule(options) {\n  const modules = options.modules || {};\n  if (modules.basis) {\n    return modules.basis;\n  }\n\n  loadBasisTranscoderPromise = loadBasisTranscoderPromise || loadBasisTrascoder(options);\n  return await loadBasisTranscoderPromise;\n}\n\n/**\n * Loads wasm transcoder module\n * @param options\n * @returns {BasisFile} promise\n */\nasync function loadBasisTrascoder(options) {\n  let BASIS = null;\n  let wasmBinary = null;\n\n  [BASIS, wasmBinary] = await Promise.all([\n    await loadLibrary('basis_transcoder.js', 'textures', options),\n    await loadLibrary('basis_transcoder.wasm', 'textures', options)\n  ]);\n\n  // Depends on how import happened...\n  // @ts-ignore TS2339: Property does not exist on type\n  BASIS = BASIS || globalThis.BASIS;\n  return await initializeBasisTrascoderModule(BASIS, wasmBinary);\n}\n\n/**\n * Initialize wasm transcoder module\n * @param BasisModule - js part of the module\n * @param wasmBinary - wasm part of the module\n * @returns {BasisFile} promise\n */\nfunction initializeBasisTrascoderModule(BasisModule, wasmBinary) {\n  const options: {wasmBinary?} = {};\n\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise((resolve) => {\n    // if you try to return BasisModule the browser crashes!\n    BasisModule(options).then((module) => {\n      const {BasisFile, initializeBasis} = module;\n      initializeBasis();\n      resolve({BasisFile});\n    });\n  });\n}\n\nlet loadBasisEncoderPromise;\n\n/**\n * Loads wasm encoder module\n * @param options\n * @returns {BasisFile, KTX2File} promise\n */\nexport async function loadBasisEncoderModule(options) {\n  const modules = options.modules || {};\n  if (modules.basisEncoder) {\n    return modules.basisEncoder;\n  }\n\n  loadBasisEncoderPromise = loadBasisEncoderPromise || loadBasisEncoder(options);\n  return await loadBasisEncoderPromise;\n}\n\n/**\n * Loads wasm encoder module\n * @param options\n * @returns {BasisFile, KTX2File} promise\n */\nasync function loadBasisEncoder(options) {\n  let BASIS_ENCODER = null;\n  let wasmBinary = null;\n\n  [BASIS_ENCODER, wasmBinary] = await Promise.all([\n    await loadLibrary(BASIS_CDN_ENCODER_JS, 'textures', options),\n    await loadLibrary(BASIS_CDN_ENCODER_WASM, 'textures', options)\n  ]);\n\n  // Depends on how import happened...\n  // @ts-ignore TS2339: Property does not exist on type\n  BASIS_ENCODER = BASIS_ENCODER || globalThis.BASIS;\n  return await initializeBasisEncoderModule(BASIS_ENCODER, wasmBinary);\n}\n\n/**\n * Initialize wasm transcoder module\n * @param BasisEncoderModule - js part of the module\n * @param wasmBinary - wasm part of the module\n * @returns {BasisFile, KTX2File} promise\n */\nfunction initializeBasisEncoderModule(BasisEncoderModule, wasmBinary) {\n  const options: {wasmBinary?} = {};\n\n  if (wasmBinary) {\n    options.wasmBinary = wasmBinary;\n  }\n\n  return new Promise((resolve) => {\n    // if you try to return BasisModule the browser crashes!\n    BasisEncoderModule(options).then((module) => {\n      const {BasisFile, KTX2File, initializeBasis, BasisEncoder} = module;\n      initializeBasis();\n      resolve({BasisFile, KTX2File, BasisEncoder});\n    });\n  });\n}\n", "/* eslint-disable camelcase */\nexport const GL_EXTENSIONS_CONSTANTS = {\n  // WEBGL_compressed_texture_s3tc\n\n  COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83f0,\n  COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83f1,\n  COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83f2,\n  COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83f3,\n\n  // WEBGL_compressed_texture_es3\n\n  COMPRESSED_R11_EAC: 0x9270,\n  COMPRESSED_SIGNED_R11_EAC: 0x9271,\n  COMPRESSED_RG11_EAC: 0x9272,\n  COMPRESSED_SIGNED_RG11_EAC: 0x9273,\n  COMPRESSED_RGB8_ETC2: 0x9274,\n  COMPRESSED_RGBA8_ETC2_EAC: 0x9275,\n  COMPRESSED_SRGB8_ETC2: 0x9276,\n  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9277,\n  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9278,\n  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9279,\n\n  // WEBGL_compressed_texture_pvrtc\n\n  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8c00,\n  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8c02,\n  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8c01,\n  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8c03,\n\n  // WEBGL_compressed_texture_etc1\n\n  COMPRESSED_RGB_ETC1_WEBGL: 0x8d64,\n\n  // WEBGL_compressed_texture_atc\n\n  COMPRESSED_RGB_ATC_WEBGL: 0x8c92,\n  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 0x8c93,\n  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 0x87ee,\n\n  // WEBGL_compressed_texture_astc\n\n  COMPRESSED_RGBA_ASTC_4X4_KHR: 0x93b0,\n  COMPRESSED_RGBA_ASTC_5X4_KHR: 0x93b1,\n  COMPRESSED_RGBA_ASTC_5X5_KHR: 0x93b2,\n  COMPRESSED_RGBA_ASTC_6X5_KHR: 0x93b3,\n  COMPRESSED_RGBA_ASTC_6X6_KHR: 0x93b4,\n  COMPRESSED_RGBA_ASTC_8X5_KHR: 0x93b5,\n  COMPRESSED_RGBA_ASTC_8X6_KHR: 0x93b6,\n  COMPRESSED_RGBA_ASTC_8X8_KHR: 0x93b7,\n  COMPRESSED_RGBA_ASTC_10X5_KHR: 0x93b8,\n  COMPRESSED_RGBA_ASTC_10X6_KHR: 0x93b9,\n  COMPRESSED_RGBA_ASTC_10X8_KHR: 0x93ba,\n  COMPRESSED_RGBA_ASTC_10X10_KHR: 0x93bb,\n  COMPRESSED_RGBA_ASTC_12X10_KHR: 0x93bc,\n  COMPRESSED_RGBA_ASTC_12X12_KHR: 0x93bd,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 0x93d0,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 0x93d1,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 0x93d2,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 0x93d3,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 0x93d4,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 0x93d5,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 0x93d6,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 0x93d7,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 0x93d8,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 0x93d9,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 0x93da,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 0x93db,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 0x93dc,\n  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 0x93dd,\n\n  // EXT_texture_compression_rgtc\n\n  COMPRESSED_RED_RGTC1_EXT: 0x8dbb,\n  COMPRESSED_SIGNED_RED_RGTC1_EXT: 0x8dbc,\n  COMPRESSED_RED_GREEN_RGTC2_EXT: 0x8dbd,\n  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 0x8dbe,\n\n  // WEBGL_compressed_texture_s3tc_srgb\n\n  COMPRESSED_SRGB_S3TC_DXT1_EXT: 0x8c4c,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 0x8c4d,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 0x8c4e,\n  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 0x8c4f\n};\n", "import type {GPUTextureFormat} from '@loaders.gl/schema';\n\nconst BROWSER_PREFIXES = ['', 'WEBKIT_', 'MOZ_'];\n\nconst WEBGL_EXTENSIONS: {[key: string]: GPUTextureFormat} = {\n  /* eslint-disable camelcase */\n  WEBGL_compressed_texture_s3tc: 'dxt',\n  WEBGL_compressed_texture_s3tc_srgb: 'dxt-srgb',\n  WEBGL_compressed_texture_etc1: 'etc1',\n  WEBGL_compressed_texture_etc: 'etc2',\n  WEBGL_compressed_texture_pvrtc: 'pvrtc',\n  WEBGL_compressed_texture_atc: 'atc',\n  WEBGL_compressed_texture_astc: 'astc',\n  EXT_texture_compression_rgtc: 'rgtc'\n  /* eslint-enable camelcase */\n};\n\nlet formats: Set<GPUTextureFormat> | null = null;\n\n/**\n * Returns a list of formats.\n * Creates a temporary WebGLRenderingContext if none is provided.\n *\n * @param gl - Optional context.\n */\nexport function getSupportedGPUTextureFormats(gl?: WebGLRenderingContext): Set<string> {\n  if (!formats) {\n    gl = gl || getWebGLContext() || undefined;\n\n    formats = new Set<GPUTextureFormat>();\n\n    for (const prefix of BROWSER_PREFIXES) {\n      for (const extension in WEBGL_EXTENSIONS) {\n        if (gl && gl.getExtension(`${prefix}${extension}`)) {\n          const gpuTextureFormat = WEBGL_EXTENSIONS[extension];\n          formats.add(gpuTextureFormat);\n        }\n      }\n    }\n  }\n\n  return formats;\n}\n\n/**\n * @returns {WebGLRenderingContext?}\n */\nfunction getWebGLContext() {\n  try {\n    const canvas = document.createElement('canvas');\n    return canvas.getContext('webgl');\n  } catch (error) {\n    return null;\n  }\n}\n", "///////////////////////////////////////////////////\n// Common.\n///////////////////////////////////////////////////\n\n// Injected at compile time, from $npm_package_version.\ndeclare const PACKAGE_VERSION: string;\n\nexport const KTX_WRITER = `KTX-Parse v${PACKAGE_VERSION}`;\n\nexport const NUL = new Uint8Array([0x00]);\n\n\n///////////////////////////////////////////////////\n// KTX2 Header.\n///////////////////////////////////////////////////\n\nexport const KTX2_ID = [\n\t// '´', 'K', 'T', 'X', '2', '0', 'ª', '\\r', '\\n', '\\x1A', '\\n'\n\t0xAB, 0x4B, 0x54, 0x58, 0x20, 0x32, 0x30, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A\n];\n\nexport const HEADER_BYTE_LENGTH = 68; // 13 * 4 + 2 * 8\n\nexport enum KTX2SupercompressionScheme {\n\tNONE = 0,\n\tBASISLZ = 1,\n\tZSTD = 2,\n\tZLIB = 3,\n};\n\n\n///////////////////////////////////////////////////\n// Data Format Descriptor (DFD).\n///////////////////////////////////////////////////\n\nexport enum KTX2DataFormatType {\n    BASICFORMAT = 0x00,\n};\n\nexport const KHR_DF_VENDORID_KHRONOS = 0;\n\nexport const KHR_DF_VERSION = 2;\n\nexport const KHR_DF_BLOCKSIZE = 40;\n\nexport const VK_FORMAT_UNDEFINED = 0;\n\nexport enum KTX2DataFormatModel {\n    UNSPECIFIED = 0,\n\tETC1S = 163,\n\tUASTC = 166,\n};\n\nexport enum KTX2DataFormatPrimaries {\n    UNSPECIFIED = 0,\n    SRGB = 1,\n};\n\nexport enum KTX2DataFormatTransfer {\n    UNSPECIFIED = 0,\n    LINEAR = 1,\n    SRGB = 2,\n    ITU = 3,\n    NTSC = 4,\n    SLOG = 5,\n    SLOG2 = 6,\n};\n\nexport enum KTX2DataFormatFlags {\n    ALPHA_STRAIGHT = 0,\n    ALPHA_PREMULTIPLIED = 1,\n};\n\nexport enum KTX2DataFormatChannelETC1S {\n    RGB = 0,\n    RRR = 3,\n    GGG = 4,\n    AAA = 15,\n};\n\nexport enum KTX2DataFormatChannelUASTC {\n    RGB = 0,\n    RGBA = 3,\n    RRR = 4,\n    RRRG = 5,\n};\n", "import { KHR_DF_BLOCKSIZE, KHR_DF_VENDORID_KHRONOS, KHR_DF_VERSION, KTX2DataFormatFlags, KTX2DataFormatModel, KTX2DataFormatPrimaries, KTX2DataFormatType, KTX2SupercompressionScheme, VK_FORMAT_UNDEFINED } from './constants';\n\n/**\n * Represents an unpacked KTX 2.0 texture container. Data for individual mip levels are stored in\n * the `.levels` array, typically compressed in Basis Universal formats. Additional properties\n * provide metadata required to process, transcode, and upload these textures.\n */\nexport class KTX2Container {\n\t/**\n\t * Specifies the image format using Vulkan VkFormat enum values. When using Basis Universal\n\t * texture formats, `vkFormat` must be VK_FORMAT_UNDEFINED.\n\t */\n\tpublic vkFormat = VK_FORMAT_UNDEFINED;\n\n\t/**\n\t * Size of the data type in bytes used to upload the data to a graphics API. When `vkFormat` is\n\t * VK_FORMAT_UNDEFINED, `typeSize` must be 1.\n\t */\n\tpublic typeSize: number = 1;\n\n\t/** Width of the texture image for level 0, in pixels. */\n\tpublic pixelWidth: number = 0;\n\n\t/** Height of the texture image for level 0, in pixels. */\n\tpublic pixelHeight: number = 0;\n\n\t/** Depth of the texture image for level 0, in pixels (3D textures only). */\n\tpublic pixelDepth: number = 0;\n\n\t/** Number of array elements (array textures only). */\n\tpublic layerCount: number = 0;\n\n\t/**\n\t * Number of cubemap faces. For cubemaps and cubemap arrays, `faceCount` must be 6. For all\n\t * other textures, `faceCount` must be 1. Cubemap faces are stored in +X, -X, +Y, -Y, +Z, -Z\n\t * order.\n\t */\n\tpublic faceCount: number = 1;\n\n\t/** Indicates which supercompression scheme has been applied to mip level images, if any. */\n\tpublic supercompressionScheme = KTX2SupercompressionScheme.NONE;\n\n\t/** Mip levels, ordered largest (original) to smallest (~1px). */\n\tpublic levels: KTX2Level[] = [];\n\n\t/** Data Format Descriptor. */\n\tpublic dataFormatDescriptor: KTX2DataFormatDescriptorBasicFormat[] = [{\n\t\tvendorId: KHR_DF_VENDORID_KHRONOS,\n\t\tdescriptorType: KTX2DataFormatType.BASICFORMAT,\n\t\tversionNumber: KHR_DF_VERSION,\n\t\tdescriptorBlockSize: KHR_DF_BLOCKSIZE,\n\t\tcolorModel: KTX2DataFormatModel.UNSPECIFIED,\n\t\tcolorPrimaries: KTX2DataFormatPrimaries.SRGB,\n\t\ttransferFunction: KTX2DataFormatPrimaries.SRGB,\n\t\tflags: KTX2DataFormatFlags.ALPHA_STRAIGHT,\n\t\ttexelBlockDimension: {x: 4, y: 4, z: 1, w: 1},\n\t\tbytesPlane: [],\n\t\tsamples: [],\n\t}];\n\n\t/** Key/Value Data. */\n\tpublic keyValue: {[key: string]: string | Uint8Array} = {};\n\n\t/** Supercompression Global Data. */\n\tpublic globalData: KTX2GlobalDataBasisLZ | null = null;\n}\n\n\n///////////////////////////////////////////////////\n// Mip Levels.\n///////////////////////////////////////////////////\n\nexport interface KTX2Level {\n\t/** Compressed data of the mip level. */\n\tlevelData: Uint8Array;\n\n\t/**\n\t * Size of the mip level after reflation from supercompression, if applicable. When\n\t * `supercompressionType` is BASISLZ, `uncompressedByteLength` must be 0. When\n\t * `supercompressionType` is `NONE`, `uncompressedByteLength` must match the `levelData` byte\n\t * length.\n\t *\n\t * _**NOTICE:** this implies that for formats such as UASTC, `uncompressedByteLength` may\n\t * indicate size after ZSTD reflation (and of transcoded ASTC data), but does _not_ indicate\n\t * size of decoded RGBA32 pixels._\n\t */\n\tuncompressedByteLength: number;\n};\n\n\n///////////////////////////////////////////////////\n// Data Format Descriptor (DFD).\n///////////////////////////////////////////////////\n\nexport interface KTX2DataFormatDescriptorBasicFormat {\n\tvendorId: number;\n\tdescriptorType: number;\n\tversionNumber: number;\n\tdescriptorBlockSize: number;\n\tcolorModel: number;\n\tcolorPrimaries: number;\n\ttransferFunction: number;\n\tflags: number;\n\ttexelBlockDimension: KTX2BasicFormatTexelBlockDimensions;\n\tbytesPlane: number[];\n\tsamples: KTX2BasicFormatSample[],\n};\n\nexport interface KTX2BasicFormatTexelBlockDimensions {\n\tx: number;\n\ty: number;\n\tz: number;\n\tw: number;\n};\n\nexport interface KTX2BasicFormatSample {\n\tbitOffset: number;\n\tbitLength: number;\n\tchannelID: number;\n\tsamplePosition: number[];\n\tsampleLower: number;\n\tsampleUpper: number;\n};\n\n\n///////////////////////////////////////////////////\n// Supercompression Global Data.\n///////////////////////////////////////////////////\n\nexport interface KTX2GlobalDataBasisLZ {\n\tendpointCount: number;\n\tselectorCount: number;\n\timageDescs: KTX2GlobalDataBasisLZImageDesc[];\n\tendpointsData: Uint8Array;\n\tselectorsData: Uint8Array;\n\ttablesData: Uint8Array;\n\textendedData: Uint8Array;\n};\n\ninterface KTX2GlobalDataBasisLZImageDesc {\n\timageFlags: number;\n\trgbSliceByteOffset: number;\n\trgbSliceByteLength: number;\n\talphaSliceByteOffset: number;\n\talphaSliceByteLength: number;\n};\n", "export class BufferReader {\n\tprivate _dataView: DataView;\n\tprivate _littleEndian: boolean;\n\tpublic _offset: number;\n\n\tconstructor(data: Uint8Array, byteOffset: number, byteLength: number, littleEndian: boolean) {\n\t\tthis._dataView = new DataView(data.buffer, data.byteOffset + byteOffset, byteLength);\n\t\tthis._littleEndian = littleEndian;\n\t\tthis._offset = 0;\n\t}\n\n\t_nextUint8() {\n\t\tconst value = this._dataView.getUint8(this._offset);\n\t\tthis._offset += 1;\n\t\treturn value;\n\t}\n\n\t_nextUint16() {\n\t\tconst value = this._dataView.getUint16(this._offset, this._littleEndian);\n\t\tthis._offset += 2;\n\t\treturn value;\n\t}\n\n\t_nextUint32() {\n\t\tconst value = this._dataView.getUint32(this._offset, this._littleEndian);\n\t\tthis._offset += 4;\n\t\treturn value;\n\t}\n\n\t_nextUint64() {\n\t\tconst left = this._dataView.getUint32(this._offset, this._littleEndian);\n\t\tconst right = this._dataView.getUint32(this._offset + 4, this._littleEndian);\n\t\t// TODO(cleanup): Just test this...\n\t\t// const value = this._littleEndian ? left + (2 ** 32 * right) : (2 ** 32 * left) + right;\n\t\tconst value = left + (2 ** 32 * right);\n\t\tthis._offset += 8;\n\t\treturn value;\n\t}\n\n\t_skip(bytes: number) {\n\t\tthis._offset += bytes;\n\t\treturn this;\n\t}\n\n\t_scan(maxByteLength: number, term: number = 0x00): Uint8Array {\n\t\tconst byteOffset = this._offset;\n\t\tlet byteLength = 0;\n\t\twhile (this._dataView.getUint8(this._offset) !== term && byteLength < maxByteLength) {\n\t\t\tbyteLength++;\n\t\t\tthis._offset++;\n\t\t}\n\n\t\tif (byteLength < maxByteLength) this._offset++;\n\n\t\treturn new Uint8Array(\n\t\t\tthis._dataView.buffer,\n\t\t\tthis._dataView.byteOffset + byteOffset,\n\t\t\tbyteLength\n\t\t);\n\t}\n}\n", "\n/** Encodes text to an ArrayBuffer. */\nexport function encodeText(text: string): Uint8Array {\n\tif (typeof TextEncoder !== 'undefined') {\n\t\treturn new TextEncoder().encode(text);\n\t}\n\treturn Buffer.from(text);\n}\n\n/** Decodes an ArrayBuffer to text. */\nexport function decodeText(buffer: Uint8Array): string {\n\tif (typeof TextDecoder !== 'undefined') {\n\t\treturn new TextDecoder().decode(buffer);\n\t}\n\treturn Buffer.from(buffer).toString('utf8');\n}\n\n/** Concatenates N ArrayBuffers. */\nexport function concat (buffers: (ArrayBuffer | Uint8Array)[]): Uint8Array {\n\tlet totalByteLength = 0;\n\tfor (const buffer of buffers) {\n\t\ttotalByteLength += buffer.byteLength;\n\t}\n\n\tconst result = new Uint8Array(totalByteLength);\n\tlet byteOffset = 0;\n\n\tfor (const buffer of buffers) {\n\t\tresult.set(new Uint8Array(buffer), byteOffset);\n\t\tbyteOffset += buffer.byteLength;\n\t}\n\n\treturn result;\n}", "import { BufferReader } from './buffer-reader';\nimport { KTX2_ID } from './constants';\nimport { KTX2Container, KTX2DataFormatDescriptorBasicFormat } from './container';\nimport { decodeText } from './util';\n\n/**\n * Parses a KTX 2.0 file, returning an unpacked {@link KTX2Container} instance with all associated\n * data. The container's mip levels and other binary data are pointers into the original file, not\n * copies, so the original file should not be overwritten after reading.\n *\n * @param data Bytes of KTX 2.0 file, as Uint8Array or Buffer.\n */\nexport function read(data: Uint8Array): KTX2Container {\n\n\t///////////////////////////////////////////////////\n\t// KTX 2.0 Identifier.\n\t///////////////////////////////////////////////////\n\n\tconst id = new Uint8Array(data.buffer, data.byteOffset, KTX2_ID.length);\n\tif (id[0] !== KTX2_ID[0] || // '´'\n\t\tid[1] !== KTX2_ID[1] || // 'K'\n\t\tid[2] !== KTX2_ID[2] || // 'T'\n\t\tid[3] !== KTX2_ID[3] || // 'X'\n\t\tid[4] !== KTX2_ID[4] || // ' '\n\t\tid[5] !== KTX2_ID[5] || // '2'\n\t\tid[6] !== KTX2_ID[6] || // '0'\n\t\tid[7] !== KTX2_ID[7] || // 'ª'\n\t\tid[8] !== KTX2_ID[8] || // '\\r'\n\t\tid[9] !== KTX2_ID[9] || // '\\n'\n\t\tid[10] !== KTX2_ID[10] || // '\\x1A'\n\t\tid[11] !== KTX2_ID[11] // '\\n'\n\t) {\n\t\tthrow new Error('Missing KTX 2.0 identifier.');\n\t}\n\n\tconst container = new KTX2Container();\n\n\t///////////////////////////////////////////////////\n\t// Header.\n\t///////////////////////////////////////////////////\n\n\tconst headerByteLength = 17 * Uint32Array.BYTES_PER_ELEMENT;\n\tconst headerReader = new BufferReader(data, KTX2_ID.length, headerByteLength, true);\n\n\tcontainer.vkFormat = headerReader._nextUint32();\n\tcontainer.typeSize = headerReader._nextUint32();\n\tcontainer.pixelWidth = headerReader._nextUint32();\n\tcontainer.pixelHeight = headerReader._nextUint32();\n\tcontainer.pixelDepth = headerReader._nextUint32();\n\tcontainer.layerCount = headerReader._nextUint32();\n\tcontainer.faceCount = headerReader._nextUint32();\n\n\tconst levelCount = headerReader._nextUint32();\n\n\tcontainer.supercompressionScheme = headerReader._nextUint32();\n\n\tconst dfdByteOffset = headerReader._nextUint32();\n\tconst dfdByteLength = headerReader._nextUint32();\n\tconst kvdByteOffset = headerReader._nextUint32();\n\tconst kvdByteLength = headerReader._nextUint32();\n\tconst sgdByteOffset = headerReader._nextUint64();\n\tconst sgdByteLength = headerReader._nextUint64();\n\n\t///////////////////////////////////////////////////\n\t// Level Index.\n\t///////////////////////////////////////////////////\n\n\tconst levelByteLength = levelCount * 3 * 8;\n\tconst levelReader = new BufferReader(data, KTX2_ID.length + headerByteLength, levelByteLength, true);\n\n\tfor (let i = 0; i < levelCount; i ++) {\n\t\tcontainer.levels.push({\n\t\t\tlevelData: new Uint8Array(data.buffer, data.byteOffset + levelReader._nextUint64(), levelReader._nextUint64()),\n\t\t\tuncompressedByteLength: levelReader._nextUint64(),\n\t\t});\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Data Format Descriptor (DFD).\n\t///////////////////////////////////////////////////\n\n\tconst dfdReader = new BufferReader(data, dfdByteOffset, dfdByteLength, true);\n\n\tconst dfd: KTX2DataFormatDescriptorBasicFormat = {\n\t\tvendorId: dfdReader._skip(4 /* totalSize */)._nextUint16(),\n\t\tdescriptorType: dfdReader._nextUint16(),\n\t\tversionNumber: dfdReader._nextUint16(),\n\t\tdescriptorBlockSize: dfdReader._nextUint16(),\n\t\tcolorModel: dfdReader._nextUint8(),\n\t\tcolorPrimaries: dfdReader._nextUint8(),\n\t\ttransferFunction: dfdReader._nextUint8(),\n\t\tflags: dfdReader._nextUint8(),\n\t\ttexelBlockDimension: {\n\t\t\tx: dfdReader._nextUint8() + 1,\n\t\t\ty: dfdReader._nextUint8() + 1,\n\t\t\tz: dfdReader._nextUint8() + 1,\n\t\t\tw: dfdReader._nextUint8() + 1,\n\t\t},\n\t\tbytesPlane: [\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t\tdfdReader._nextUint8(),\n\t\t],\n\t\tsamples: [],\n\t};\n\n\tconst sampleStart = 6;\n\tconst sampleWords = 4;\n\tconst numSamples = (dfd.descriptorBlockSize / 4 - sampleStart) / sampleWords;\n\n\tfor (let i = 0; i < numSamples; i ++) {\n\t\tdfd.samples[ i ] = {\n\t\t\tbitOffset: dfdReader._nextUint16(),\n\t\t\tbitLength: dfdReader._nextUint8(),\n\t\t\tchannelID: dfdReader._nextUint8(),\n\t\t\tsamplePosition: [\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t\tdfdReader._nextUint8(),\n\t\t\t],\n\t\t\tsampleLower: dfdReader._nextUint32(),\n\t\t\tsampleUpper: dfdReader._nextUint32(),\n\t\t};\n\t}\n\n\tcontainer.dataFormatDescriptor.length = 0;\n\tcontainer.dataFormatDescriptor.push(dfd);\n\n\n\t///////////////////////////////////////////////////\n\t// Key/Value Data (KVD).\n\t///////////////////////////////////////////////////\n\n\tconst kvdReader = new BufferReader(data, kvdByteOffset, kvdByteLength, true);\n\n\twhile (kvdReader._offset < kvdByteLength) {\n\t\tconst keyValueByteLength = kvdReader._nextUint32();\n\t\tconst keyData = kvdReader._scan(keyValueByteLength);\n\t\tconst key = decodeText(keyData);\n\t\tconst valueData = kvdReader._scan(keyValueByteLength - keyData.byteLength);\n\t\tcontainer.keyValue[key] = key.match(/^ktx/i) ? decodeText(valueData) : valueData;\n\n\t\t// 4-byte alignment.\n\t\tif (keyValueByteLength % 4) kvdReader._skip(4 - (keyValueByteLength % 4));\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Supercompression Global Data (SGD).\n\t///////////////////////////////////////////////////\n\n\tif (sgdByteLength <= 0) return container;\n\n\tconst sgdReader = new BufferReader(data, sgdByteOffset, sgdByteLength, true);\n\n\tconst endpointCount = sgdReader._nextUint16();\n\tconst selectorCount = sgdReader._nextUint16();\n\tconst endpointsByteLength = sgdReader._nextUint32();\n\tconst selectorsByteLength = sgdReader._nextUint32();\n\tconst tablesByteLength = sgdReader._nextUint32();\n\tconst extendedByteLength = sgdReader._nextUint32();\n\n\tconst imageDescs = [];\n\tfor (let i = 0; i < levelCount; i ++) {\n\t\timageDescs.push({\n\t\t\timageFlags: sgdReader._nextUint32(),\n\t\t\trgbSliceByteOffset: sgdReader._nextUint32(),\n\t\t\trgbSliceByteLength: sgdReader._nextUint32(),\n\t\t\talphaSliceByteOffset: sgdReader._nextUint32(),\n\t\t\talphaSliceByteLength: sgdReader._nextUint32(),\n\t\t});\n\t}\n\n\tconst endpointsByteOffset = sgdByteOffset + sgdReader._offset;\n\tconst selectorsByteOffset = endpointsByteOffset + endpointsByteLength;\n\tconst tablesByteOffset = selectorsByteOffset + selectorsByteLength;\n\tconst extendedByteOffset = tablesByteOffset + tablesByteLength;\n\n\tconst endpointsData = new Uint8Array(data.buffer, data.byteOffset + endpointsByteOffset, endpointsByteLength);\n\tconst selectorsData = new Uint8Array(data.buffer, data.byteOffset + selectorsByteOffset, selectorsByteLength);\n\tconst tablesData = new Uint8Array(data.buffer, data.byteOffset + tablesByteOffset, tablesByteLength);\n\tconst extendedData = new Uint8Array(data.buffer, data.byteOffset + extendedByteOffset, extendedByteLength);\n\n\tcontainer.globalData = {\n\t\tendpointCount,\n\t\tselectorCount,\n\t\timageDescs,\n\t\tendpointsData,\n\t\tselectorsData,\n\t\ttablesData,\n\t\textendedData,\n\t};\n\n\treturn container;\n}\n", "import { HEADER_BYTE_LENGTH, KTX2DataFormatType, KTX2_ID, KTX_WRITER, NUL } from './constants';\nimport { KTX2Container } from './container';\nimport { concat, encodeText } from './util';\n\ninterface WriteOptions {keepWriter?: boolean};\nconst DEFAULT_OPTIONS: WriteOptions = {keepWriter: false};\n\n/**\n * Serializes a {@link KTX2Container} instance to a KTX 2.0 file. Mip levels and other binary data\n * are copied into the resulting Uint8Array, so the original container can safely be edited or\n * destroyed after it is serialized.\n *\n * Options:\n * - keepWriter: If true, 'KTXWriter' key/value field is written as provided by the container.\n * \t\tOtherwise, a string for the current ktx-parse version is generated. Default: false.\n *\n * @param container\n * @param options\n */\nexport function write(container: KTX2Container, options: WriteOptions = {}): Uint8Array {\n\toptions = {...DEFAULT_OPTIONS, ...options};\n\n\t///////////////////////////////////////////////////\n\t// Supercompression Global Data (SGD).\n\t///////////////////////////////////////////////////\n\n\tlet sgdBuffer = new ArrayBuffer(0);\n\tif (container.globalData) {\n\t\tconst sgdHeaderBuffer = new ArrayBuffer(20 + container.globalData.imageDescs.length * 5 * 4);\n\t\tconst sgdHeaderView = new DataView(sgdHeaderBuffer);\n\t\tsgdHeaderView.setUint16(0, container.globalData.endpointCount, true);\n\t\tsgdHeaderView.setUint16(2, container.globalData.selectorCount, true);\n\t\tsgdHeaderView.setUint32(4, container.globalData.endpointsData.byteLength, true);\n\t\tsgdHeaderView.setUint32(8, container.globalData.selectorsData.byteLength, true);\n\t\tsgdHeaderView.setUint32(12, container.globalData.tablesData.byteLength, true);\n\t\tsgdHeaderView.setUint32(16, container.globalData.extendedData.byteLength, true);\n\n\t\tfor (let i = 0; i < container.globalData.imageDescs.length; i++) {\n\t\t\tconst imageDesc = container.globalData.imageDescs[i];\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 0, imageDesc.imageFlags, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 4, imageDesc.rgbSliceByteOffset, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 8, imageDesc.rgbSliceByteLength, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 12, imageDesc.alphaSliceByteOffset, true);\n\t\t\tsgdHeaderView.setUint32(20 + i * 5 * 4 + 16, imageDesc.alphaSliceByteLength, true);\n\t\t}\n\n\t\tsgdBuffer = concat([\n\t\t\tsgdHeaderBuffer,\n\t\t\tcontainer.globalData.endpointsData,\n\t\t\tcontainer.globalData.selectorsData,\n\t\t\tcontainer.globalData.tablesData,\n\t\t\tcontainer.globalData.extendedData,\n\t\t]);\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Key/Value Data (KVD).\n\t///////////////////////////////////////////////////\n\n\tconst keyValueData: Uint8Array[] = [];\n\tlet keyValue = container.keyValue;\n\n\tif (!options.keepWriter) {\n\t\tkeyValue = {...container.keyValue, 'KTXwriter': KTX_WRITER};\n\t}\n\n\tfor (const key in keyValue) {\n\t\tconst value = keyValue[key];\n\t\tconst keyData = encodeText(key);\n\t\tconst valueData = typeof value === 'string' ? encodeText(value) : value;\n\t\tconst kvByteLength = keyData.byteLength + 1 + valueData.byteLength + 1;\n\t\tconst kvPadding = kvByteLength % 4 ? (4 - (kvByteLength % 4)) : 0; // align(4)\n\t\tkeyValueData.push(concat([\n\t\t\tnew Uint32Array([kvByteLength]),\n\t\t\tkeyData,\n\t\t\tNUL,\n\t\t\tvalueData,\n\t\t\tNUL,\n\t\t\tnew Uint8Array(kvPadding).fill(0x00), // align(4)\n\t\t]));\n\t}\n\n\tconst kvdBuffer = concat(keyValueData);\n\n\n\t///////////////////////////////////////////////////\n\t// Data Format Descriptor (DFD).\n\t///////////////////////////////////////////////////\n\n\tconst dfdBuffer = new ArrayBuffer(44);\n\tconst dfdView = new DataView(dfdBuffer);\n\n\tif (container.dataFormatDescriptor.length !== 1\n\t\t\t|| container.dataFormatDescriptor[0].descriptorType !== KTX2DataFormatType.BASICFORMAT) {\n\t\tthrow new Error('Only BASICFORMAT Data Format Descriptor output supported.');\n\t}\n\n\tconst dfd = container.dataFormatDescriptor[0];\n\n\tdfdView.setUint32(0, 44, true);\n\tdfdView.setUint16(4, dfd.vendorId, true);\n\tdfdView.setUint16(6, dfd.descriptorType, true);\n\tdfdView.setUint16(8, dfd.versionNumber, true);\n\tdfdView.setUint16(10, dfd.descriptorBlockSize, true);\n\n\tdfdView.setUint8(12, dfd.colorModel);\n\tdfdView.setUint8(13, dfd.colorPrimaries);\n\tdfdView.setUint8(14, dfd.transferFunction);\n\tdfdView.setUint8(15, dfd.flags);\n\n\tdfdView.setUint8(16, dfd.texelBlockDimension.x - 1);\n\tdfdView.setUint8(17, dfd.texelBlockDimension.y - 1);\n\tdfdView.setUint8(18, dfd.texelBlockDimension.z - 1);\n\tdfdView.setUint8(19, dfd.texelBlockDimension.w - 1);\n\n\tfor (let i = 0; i < 8; i++) dfdView.setUint8(20 + i, dfd.bytesPlane[i]);\n\n\tfor (let i = 0; i < dfd.samples.length; i++) {\n\t\tconst sample = dfd.samples[i];\n\t\tconst sampleByteOffset = 28 + i * 16;\n\n\t\tdfdView.setUint16(sampleByteOffset + 0, sample.bitOffset, true);\n\t\tdfdView.setUint8(sampleByteOffset + 2, sample.bitLength);\n\t\tdfdView.setUint8(sampleByteOffset + 3, sample.channelID);\n\n\t\tdfdView.setUint8(sampleByteOffset + 4, sample.samplePosition[0]);\n\t\tdfdView.setUint8(sampleByteOffset + 5, sample.samplePosition[1]);\n\t\tdfdView.setUint8(sampleByteOffset + 6, sample.samplePosition[2]);\n\t\tdfdView.setUint8(sampleByteOffset + 7, sample.samplePosition[3]);\n\n\t\tdfdView.setUint32(sampleByteOffset + 8, sample.sampleLower, true);\n\t\tdfdView.setUint32(sampleByteOffset + 12, sample.sampleUpper, true);\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Data alignment.\n\t///////////////////////////////////////////////////\n\n\tconst dfdByteOffset = KTX2_ID.length + HEADER_BYTE_LENGTH + container.levels.length * 3 * 8;\n\tconst kvdByteOffset = dfdByteOffset + dfdBuffer.byteLength;\n\tlet sgdByteOffset = kvdByteOffset + kvdBuffer.byteLength;\n\tif (sgdByteOffset % 8) sgdByteOffset += 8 - (sgdByteOffset % 8); // align(8)\n\n\n\t///////////////////////////////////////////////////\n\t// Level Index.\n\t///////////////////////////////////////////////////\n\n\tconst levelData: Uint8Array[] = [];\n\tconst levelIndex = new DataView(new ArrayBuffer(container.levels.length * 3 * 8));\n\n\tlet levelDataByteOffset = sgdByteOffset + sgdBuffer.byteLength;\n\tfor (let i = 0; i < container.levels.length; i++) {\n\t\tconst level = container.levels[i];\n\t\tlevelData.push(level.levelData);\n\t\tlevelIndex.setBigUint64(i * 24 + 0, BigInt(levelDataByteOffset), true);\n\t\tlevelIndex.setBigUint64(i * 24 + 8, BigInt(level.levelData.byteLength), true);\n\t\tlevelIndex.setBigUint64(i * 24 + 16, BigInt(level.uncompressedByteLength), true);\n\t\tlevelDataByteOffset += level.levelData.byteLength;\n\t}\n\n\n\t///////////////////////////////////////////////////\n\t// Header.\n\t///////////////////////////////////////////////////\n\n\tconst headerBuffer = new ArrayBuffer(HEADER_BYTE_LENGTH);\n\tconst headerView = new DataView(headerBuffer);\n\theaderView.setUint32(0, container.vkFormat, true);\n\theaderView.setUint32(4, container.typeSize, true);\n\theaderView.setUint32(8, container.pixelWidth, true);\n\theaderView.setUint32(12, container.pixelHeight, true);\n\theaderView.setUint32(16, container.pixelDepth, true);\n\theaderView.setUint32(20, container.layerCount, true);\n\theaderView.setUint32(24, container.faceCount, true);\n\theaderView.setUint32(28, container.levels.length, true);\n\theaderView.setUint32(32, container.supercompressionScheme, true);\n\n\theaderView.setUint32(36, dfdByteOffset, true);\n\theaderView.setUint32(40, dfdBuffer.byteLength, true);\n\theaderView.setUint32(44, kvdByteOffset, true);\n\theaderView.setUint32(48, kvdBuffer.byteLength, true);\n\theaderView.setBigUint64(52, BigInt(sgdByteOffset), true);\n\theaderView.setBigUint64(60, BigInt(sgdBuffer.byteLength), true);\n\n\n\t///////////////////////////////////////////////////\n\t// Compose.\n\t///////////////////////////////////////////////////\n\n\treturn new Uint8Array(concat([\n\t\tnew Uint8Array(KTX2_ID).buffer,\n\t\theaderBuffer,\n\t\tlevelIndex.buffer,\n\t\tdfdBuffer,\n\t\tkvdBuffer,\n\t\tnew ArrayBuffer(sgdByteOffset - (kvdByteOffset + kvdBuffer.byteLength)), // align(8)\n\t\tsgdBuffer,\n\t\t...levelData,\n\t]));\n}\n\n", "import type {TextureLevel} from '@loaders.gl/schema';\n\nexport type CompressedTextureExtractOptions = {\n  mipMapLevels: number;\n  width: number;\n  height: number;\n  sizeFunction: Function;\n  internalFormat: number;\n};\n\n/**\n * Extract mipmap images from compressed texture buffer\n * @param data - binary data of compressed texture or Array of level objects\n * @param options.mipMapLevels - number of mipmap level inside image\n * @param options.width - width of 0 - level\n * @param options.height - height of 0 - level\n * @param options.sizeFunction - format-related function to calculate level size in bytes\n * @param options.internalFormat - WebGL compatible format code\n * @returns Array of the texture levels\n */\nexport function extractMipmapImages(\n  data: Uint8Array | object[],\n  options: CompressedTextureExtractOptions\n): TextureLevel[] {\n  const images = new Array(options.mipMapLevels);\n\n  let levelWidth = options.width;\n  let levelHeight = options.height;\n  let offset = 0;\n\n  for (let i = 0; i < options.mipMapLevels; ++i) {\n    // @ts-expect-error\n    const levelSize = getLevelSize(options, levelWidth, levelHeight, data, i);\n    // @ts-expect-error\n    const levelData = getLevelData(data, i, offset, levelSize);\n\n    images[i] = {\n      compressed: true,\n      format: options.internalFormat,\n      data: levelData,\n      width: levelWidth,\n      height: levelHeight,\n      levelSize\n    };\n\n    levelWidth = Math.max(1, levelWidth >> 1);\n    levelHeight = Math.max(1, levelHeight >> 1);\n\n    offset += levelSize;\n  }\n  return images;\n}\n\nfunction getLevelData(\n  data: Uint8Array,\n  index: number,\n  offset: number,\n  levelSize: number\n): Uint8Array {\n  if (!Array.isArray(data)) {\n    return new Uint8Array(data.buffer, data.byteOffset + offset, levelSize);\n  }\n\n  return data[index].levelData;\n}\n\nfunction getLevelSize(\n  options: CompressedTextureExtractOptions,\n  levelWidth: number,\n  levelHeight: number,\n  data: Uint8Array[] | object[],\n  index: number\n): number {\n  if (!Array.isArray(data)) {\n    return options.sizeFunction(levelWidth, levelHeight);\n  }\n  return options.sizeFunction(data[index]);\n}\n", "import {GL_EXTENSIONS_CONSTANTS} from '../gl-extensions';\n\nconst VULKAN_TO_WEBGL_FORMAT_MAP: Record<number, number> = {\n  131: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,\n  132: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_S3TC_DXT1_EXT,\n  133: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT1_EXT,\n  134: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,\n  135: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  136: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,\n  137: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n  138: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,\n  139: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RED_RGTC1_EXT,\n  140: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RED_RGTC1_EXT,\n  141: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RED_GREEN_RGTC2_EXT,\n  142: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT,\n  147: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_ETC2,\n  148: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ETC2,\n  149: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n  150: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,\n  151: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA8_ETC2_EAC,\n  152: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,\n  153: GL_EXTENSIONS_CONSTANTS.COMPRESSED_R11_EAC,\n  154: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_R11_EAC,\n  155: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RG11_EAC,\n  156: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SIGNED_RG11_EAC,\n  // @ts-ignore\n  157: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4x4_KHR,\n  // @ts-ignore\n  158: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,\n  // @ts-ignore\n  159: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x4_KHR,\n  // @ts-ignore\n  160: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR,\n  // @ts-ignore\n  161: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x5_KHR,\n  // @ts-ignore\n  162: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,\n  // @ts-ignore\n  163: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x5_KHR,\n  // @ts-ignore\n  164: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,\n  // @ts-ignore\n  165: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x6_KHR,\n  // @ts-ignore\n  166: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,\n  // @ts-ignore\n  167: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x5_KHR,\n  // @ts-ignore\n  168: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,\n  // @ts-ignore\n  169: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x6_KHR,\n  // @ts-ignore\n  170: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,\n  // @ts-ignore\n  171: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x8_KHR,\n  // @ts-ignore\n  172: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,\n  // @ts-ignore\n  173: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x5_KHR,\n  // @ts-ignore\n  174: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,\n  // @ts-ignore\n  175: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x6_KHR,\n  // @ts-ignore\n  176: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,\n  // @ts-ignore\n  177: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x8_KHR,\n  // @ts-ignore\n  178: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,\n  // @ts-ignore\n  179: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x10_KHR,\n  // @ts-ignore\n  180: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,\n  // @ts-ignore\n  181: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x10_KHR,\n  // @ts-ignore\n  182: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,\n  // @ts-ignore\n  183: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x12_KHR,\n  // @ts-ignore\n  184: GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR,\n  1000054000: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,\n  1000054001: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,\n  // @ts-ignore\n  1000066000: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4x4_KHR,\n  // @ts-ignore\n  1000066001: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x4_KHR,\n  // @ts-ignore\n  1000066002: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5x5_KHR,\n  // @ts-ignore\n  1000066003: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x5_KHR,\n  // @ts-ignore\n  1000066004: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6x6_KHR,\n  // @ts-ignore\n  1000066005: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x5_KHR,\n  // @ts-ignore\n  1000066006: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x6_KHR,\n  // @ts-ignore\n  1000066007: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8x8_KHR,\n  // @ts-ignore\n  1000066008: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x5_KHR,\n  // @ts-ignore\n  1000066009: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x6_KHR,\n  // @ts-ignore\n  1000066010: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x8_KHR,\n  // @ts-ignore\n  1000066011: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10x10_KHR,\n  // @ts-ignore\n  1000066012: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x10_KHR,\n  // @ts-ignore\n  1000066013: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12x12_KHR\n};\n\n/**\n * Returns WebGl format based on Vulkan format\n * Vulkan to WebGl format mapping provided here http://github.khronos.org/KTX-Specification/#formatMapping\n * Vulkan name to format number mapping provided here: https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkFormat.html\n * @param vkFormat\n * @returns WebGL / OpenGL constant\n */\nexport function mapVkFormatToWebGL(vkFormat: number): number {\n  return VULKAN_TO_WEBGL_FORMAT_MAP[vkFormat];\n}\n", "import type {TextureLevel} from '@loaders.gl/schema';\nimport {read} from 'ktx-parse';\nimport {extractMipmapImages} from '../utils/extract-mipmap-images';\nimport {mapVkFormatToWebGL} from '../utils/ktx-format-helper';\n\nconst KTX2_ID = [\n  // '´', 'K', 'T', 'X', '2', '0', 'ª', '\\r', '\\n', '\\x1A', '\\n'\n  0xab, 0x4b, 0x54, 0x58, 0x20, 0x32, 0x30, 0xbb, 0x0d, 0x0a, 0x1a, 0x0a\n];\n\n// eslint-disable-next-line complexity\nexport function isKTX(data: ArrayBuffer) {\n  // const id = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n  const id = new Uint8Array(data);\n  const notKTX =\n    id.byteLength < KTX2_ID.length ||\n    id[0] !== KTX2_ID[0] || // '´'\n    id[1] !== KTX2_ID[1] || // 'K'\n    id[2] !== KTX2_ID[2] || // 'T'\n    id[3] !== KTX2_ID[3] || // 'X'\n    id[4] !== KTX2_ID[4] || // ' '\n    id[5] !== KTX2_ID[5] || // '2'\n    id[6] !== KTX2_ID[6] || // '0'\n    id[7] !== KTX2_ID[7] || // 'ª'\n    id[8] !== KTX2_ID[8] || // '\\r'\n    id[9] !== KTX2_ID[9] || // '\\n'\n    id[10] !== KTX2_ID[10] || // '\\x1A'\n    id[11] !== KTX2_ID[11]; // '\\n'\n\n  return !notKTX;\n}\n\nexport function parseKTX(arrayBuffer: ArrayBuffer): TextureLevel[] {\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const ktx = read(uint8Array);\n  const mipMapLevels = Math.max(1, ktx.levels.length);\n  const width = ktx.pixelWidth;\n  const height = ktx.pixelHeight;\n  const internalFormat = mapVkFormatToWebGL(ktx.vkFormat);\n\n  return extractMipmapImages(ktx.levels, {\n    mipMapLevels,\n    width,\n    height,\n    sizeFunction: (level: any): number => level.uncompressedByteLength,\n    internalFormat\n  });\n}\n", "/* eslint-disable indent */\nimport type {TextureLevel} from '@loaders.gl/schema';\nimport {loadBasisEncoderModule, loadBasisTrascoderModule} from './basis-module-loader';\nimport {GL_EXTENSIONS_CONSTANTS} from '../gl-extensions';\nimport {getSupportedGPUTextureFormats} from '../utils/texture-formats';\nimport {isKTX} from './parse-ktx';\n\nexport type BasisFormat =\n  | 'etc1'\n  | 'etc2'\n  | 'bc1'\n  | 'bc3'\n  | 'bc4'\n  | 'bc5'\n  | 'bc7-m6-opaque-only'\n  | 'bc7-m5'\n  | 'pvrtc1-4-rgb'\n  | 'pvrtc1-4-rgba'\n  | 'astc-4x4'\n  | 'atc-rgb'\n  | 'atc-rgba-interpolated-alpha'\n  | 'rgba32'\n  | 'rgb565'\n  | 'bgr565'\n  | 'rgba4444';\n\ntype BasisOutputOptions = {\n  basisFormat: number;\n  compressed: boolean;\n  format?: number;\n};\n\nconst OutputFormat: Record<string, BasisOutputOptions> = {\n  etc1: {\n    basisFormat: 0,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL\n  },\n  etc2: {basisFormat: 1, compressed: true},\n  bc1: {\n    basisFormat: 2,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT\n  },\n  bc3: {\n    basisFormat: 3,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT\n  },\n  bc4: {basisFormat: 4, compressed: true},\n  bc5: {basisFormat: 5, compressed: true},\n  'bc7-m6-opaque-only': {basisFormat: 6, compressed: true},\n  'bc7-m5': {basisFormat: 7, compressed: true},\n  'pvrtc1-4-rgb': {\n    basisFormat: 8,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG\n  },\n  'pvrtc1-4-rgba': {\n    basisFormat: 9,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG\n  },\n  'astc-4x4': {\n    basisFormat: 10,\n    compressed: true,\n    format: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR\n  },\n  'atc-rgb': {basisFormat: 11, compressed: true},\n  'atc-rgba-interpolated-alpha': {basisFormat: 12, compressed: true},\n  rgba32: {basisFormat: 13, compressed: false},\n  rgb565: {basisFormat: 14, compressed: false},\n  bgr565: {basisFormat: 15, compressed: false},\n  rgba4444: {basisFormat: 16, compressed: false}\n};\n\n/**\n * parse data with a Binomial Basis_Universal module\n * @param data\n * @param options\n * @returns compressed texture data\n */\nexport default async function parseBasis(data: ArrayBuffer, options): Promise<TextureLevel[][]> {\n  if (options.basis.containerFormat === 'auto') {\n    if (isKTX(data)) {\n      const fileConstructors = await loadBasisEncoderModule(options);\n      return parseKTX2File(fileConstructors.KTX2File, data, options);\n    }\n    const {BasisFile} = await loadBasisTrascoderModule(options);\n    return parseBasisFile(BasisFile, data, options);\n  }\n  switch (options.basis.module) {\n    case 'encoder':\n      const fileConstructors = await loadBasisEncoderModule(options);\n      switch (options.basis.containerFormat) {\n        case 'ktx2':\n          return parseKTX2File(fileConstructors.KTX2File, data, options);\n        case 'basis':\n        default:\n          return parseBasisFile(fileConstructors.BasisFile, data, options);\n      }\n    case 'transcoder':\n    default:\n      const {BasisFile} = await loadBasisTrascoderModule(options);\n      return parseBasisFile(BasisFile, data, options);\n  }\n}\n\n/**\n * Parse *.basis file data\n * @param BasisFile - initialized transcoder module\n * @param data\n * @param options\n * @returns compressed texture data\n */\nfunction parseBasisFile(BasisFile, data, options): TextureLevel[][] {\n  const basisFile = new BasisFile(new Uint8Array(data));\n\n  try {\n    if (!basisFile.startTranscoding()) {\n      throw new Error('Failed to start basis transcoding');\n    }\n\n    const imageCount = basisFile.getNumImages();\n    const images: TextureLevel[][] = [];\n\n    for (let imageIndex = 0; imageIndex < imageCount; imageIndex++) {\n      const levelsCount = basisFile.getNumLevels(imageIndex);\n      const levels: TextureLevel[] = [];\n\n      for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {\n        levels.push(transcodeImage(basisFile, imageIndex, levelIndex, options));\n      }\n\n      images.push(levels);\n    }\n\n    return images;\n  } finally {\n    basisFile.close();\n    basisFile.delete();\n  }\n}\n\n/**\n * Parse the particular level image of a basis file\n * @param basisFile\n * @param imageIndex\n * @param levelIndex\n * @param options\n * @returns compressed texture data\n */\nfunction transcodeImage(basisFile, imageIndex, levelIndex, options): TextureLevel {\n  const width = basisFile.getImageWidth(imageIndex, levelIndex);\n  const height = basisFile.getImageHeight(imageIndex, levelIndex);\n\n  // See https://github.com/BinomialLLC/basis_universal/pull/83\n  const hasAlpha = basisFile.getHasAlpha(/* imageIndex, levelIndex */);\n\n  // Check options for output format etc\n  const {compressed, format, basisFormat} = getBasisOptions(options, hasAlpha);\n\n  const decodedSize = basisFile.getImageTranscodedSizeInBytes(imageIndex, levelIndex, basisFormat);\n  const decodedData = new Uint8Array(decodedSize);\n\n  if (!basisFile.transcodeImage(decodedData, imageIndex, levelIndex, basisFormat, 0, 0)) {\n    throw new Error('failed to start Basis transcoding');\n  }\n\n  return {\n    // standard loaders.gl image category payload\n    width,\n    height,\n    data: decodedData,\n    compressed,\n    format,\n\n    // Additional fields\n    // Add levelSize field.\n    hasAlpha\n  };\n}\n\n/**\n * Parse *.ktx2 file data\n * @param KTX2File\n * @param data\n * @param options\n * @returns compressed texture data\n */\nfunction parseKTX2File(KTX2File, data: ArrayBuffer, options): TextureLevel[][] {\n  const ktx2File = new KTX2File(new Uint8Array(data));\n\n  try {\n    if (!ktx2File.startTranscoding()) {\n      throw new Error('failed to start KTX2 transcoding');\n    }\n    const levelsCount = ktx2File.getLevels();\n    const levels: TextureLevel[] = [];\n\n    for (let levelIndex = 0; levelIndex < levelsCount; levelIndex++) {\n      levels.push(transcodeKTX2Image(ktx2File, levelIndex, options));\n      break; // texture app can only show one level for some reason\n    }\n\n    return [levels];\n  } finally {\n    ktx2File.close();\n    ktx2File.delete();\n  }\n}\n\n/**\n * Parse the particular level image of a ktx2 file\n * @param ktx2File\n * @param levelIndex\n * @param options\n * @returns\n */\nfunction transcodeKTX2Image(ktx2File, levelIndex: number, options): TextureLevel {\n  const {alphaFlag, height, width} = ktx2File.getImageLevelInfo(levelIndex, 0, 0);\n\n  // Check options for output format etc\n  const {compressed, format, basisFormat} = getBasisOptions(options, alphaFlag);\n\n  const decodedSize = ktx2File.getImageTranscodedSizeInBytes(\n    levelIndex,\n    0 /* layerIndex */,\n    0 /* faceIndex */,\n    basisFormat\n  );\n  const decodedData = new Uint8Array(decodedSize);\n\n  if (\n    !ktx2File.transcodeImage(\n      decodedData,\n      levelIndex,\n      0 /* layerIndex */,\n      0 /* faceIndex */,\n      basisFormat,\n      0,\n      -1 /* channel0 */,\n      -1 /* channel1 */\n    )\n  ) {\n    throw new Error('Failed to transcode KTX2 image');\n  }\n\n  return {\n    // standard loaders.gl image category payload\n    width,\n    height,\n    data: decodedData,\n    compressed,\n\n    // Additional fields\n    levelSize: decodedSize,\n    hasAlpha: alphaFlag,\n    format\n  };\n}\n\n/**\n * Get BasisFormat by loader format option\n * @param options\n * @param hasAlpha\n * @returns BasisFormat data\n */\nfunction getBasisOptions(options, hasAlpha: boolean): BasisOutputOptions {\n  let format = options && options.basis && options.basis.format;\n  if (format === 'auto') {\n    format = selectSupportedBasisFormat();\n  }\n  if (typeof format === 'object') {\n    format = hasAlpha ? format.alpha : format.noAlpha;\n  }\n  format = format.toLowerCase();\n  return OutputFormat[format];\n}\n\n/**\n * Select transcode format from the list of supported formats\n * @returns key for OutputFormat map\n */\nexport function selectSupportedBasisFormat():\n  | BasisFormat\n  | {\n      alpha: BasisFormat;\n      noAlpha: BasisFormat;\n    } {\n  const supportedFormats = getSupportedGPUTextureFormats();\n  if (supportedFormats.has('astc')) {\n    return 'astc-4x4';\n  } else if (supportedFormats.has('dxt')) {\n    return {\n      alpha: 'bc3',\n      noAlpha: 'bc1'\n    };\n  } else if (supportedFormats.has('pvrtc')) {\n    return {\n      alpha: 'pvrtc1-4-rgba',\n      noAlpha: 'pvrtc1-4-rgb'\n    };\n  } else if (supportedFormats.has('etc1')) {\n    return 'etc1';\n  } else if (supportedFormats.has('etc2')) {\n    return 'etc2';\n  }\n  return 'rgb565';\n}\n", "import type {Loader, LoaderWithParser} from '@loaders.gl/loader-utils';\nimport {isBrowser} from '@loaders.gl/worker-utils';\nimport {VERSION} from './lib/utils/version';\nimport parseBasis from './lib/parsers/parse-basis';\n\n/**\n * Worker loader for Basis super compressed textures\n */\nexport const BasisWorkerLoader = {\n  name: 'Basis',\n  id: isBrowser ? 'basis' : 'basis-nodejs',\n  module: 'textures',\n  version: VERSION,\n  worker: true,\n  extensions: ['basis', 'ktx2'],\n  mimeTypes: ['application/octet-stream', 'image/ktx2'],\n  tests: ['sB'],\n  binary: true,\n  options: {\n    basis: {\n      format: 'auto', // gl context doesn't exist on a worker thread\n      libraryPath: 'libs/',\n      containerFormat: 'auto', // 'basis' || 'ktx2' || 'auto'\n      module: 'transcoder' // 'transcoder' || 'encoder'\n    }\n  }\n};\n\n/**\n * Loader for Basis super compressed textures\n */\nexport const BasisLoader = {\n  ...BasisWorkerLoader,\n  parse: parseBasis\n};\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckBasisWorkerLoader: Loader = BasisWorkerLoader;\nexport const _TypecheckBasisLoader: LoaderWithParser = BasisLoader;\n", "import type {TextureLevel} from '@loaders.gl/schema';\nimport {assert} from '@loaders.gl/loader-utils';\nimport {GL_EXTENSIONS_CONSTANTS} from '../gl-extensions';\nimport {extractMipmapImages} from '../utils/extract-mipmap-images';\n\nconst DDS_CONSTANTS = {\n  MAGIC_NUMBER: 0x20534444,\n  HEADER_LENGTH: 31,\n  MAGIC_NUMBER_INDEX: 0,\n  HEADER_SIZE_INDEX: 1,\n  HEADER_FLAGS_INDEX: 2,\n  HEADER_HEIGHT_INDEX: 3,\n  HEADER_WIDTH_INDEX: 4,\n  MIPMAPCOUNT_INDEX: 7,\n  HEADER_PF_FLAGS_INDEX: 20,\n  HEADER_PF_FOURCC_INDEX: 21,\n  DDSD_MIPMAPCOUNT: 0x20000,\n  DDPF_FOURCC: 0x4\n};\n\nconst DDS_PIXEL_FORMATS: Record<string, number> = {\n  DXT1: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT,\n  DXT3: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT,\n  DXT5: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT,\n  'ATC ': GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ATC_WEBGL,\n  ATCA: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL,\n  ATCI: GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL\n};\n\nconst getATCLevelSize = getDxt1LevelSize;\nconst getATCALevelSize = getDxtXLevelSize;\nconst getATCILevelSize = getDxtXLevelSize;\n\nconst DDS_SIZE_FUNCTIONS: Record<string, (width: number, height: number) => number> = {\n  DXT1: getDxt1LevelSize,\n  DXT3: getDxtXLevelSize,\n  DXT5: getDxtXLevelSize,\n  'ATC ': getATCLevelSize,\n  ATCA: getATCALevelSize,\n  ATCI: getATCILevelSize\n};\n\n/**\n * Check if data is in \"DDS\" format by its magic number\n * @param data - binary data of compressed texture\n * @returns true - data in \"DDS\" format, else - false\n */\nexport function isDDS(data: ArrayBuffer): boolean {\n  const header = new Uint32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);\n  const magic = header[DDS_CONSTANTS.MAGIC_NUMBER_INDEX];\n  return magic === DDS_CONSTANTS.MAGIC_NUMBER;\n}\n\n/**\n * Parse texture data as \"DDS\" format\n * @param data - binary data of compressed texture\n * @returns Array of the texture levels\n */\nexport function parseDDS(data: ArrayBuffer): TextureLevel[] {\n  const header = new Int32Array(data, 0, DDS_CONSTANTS.HEADER_LENGTH);\n  const pixelFormatNumber = header[DDS_CONSTANTS.HEADER_PF_FOURCC_INDEX];\n  assert(\n    Boolean(header[DDS_CONSTANTS.HEADER_PF_FLAGS_INDEX] & DDS_CONSTANTS.DDPF_FOURCC),\n    'DDS: Unsupported format, must contain a FourCC code'\n  );\n  const fourCC = int32ToFourCC(pixelFormatNumber);\n  const internalFormat = DDS_PIXEL_FORMATS[fourCC];\n  const sizeFunction = DDS_SIZE_FUNCTIONS[fourCC];\n  assert(internalFormat && sizeFunction, `DDS: Unknown pixel format ${pixelFormatNumber}`);\n\n  let mipMapLevels = 1;\n  if (header[DDS_CONSTANTS.HEADER_FLAGS_INDEX] & DDS_CONSTANTS.DDSD_MIPMAPCOUNT) {\n    mipMapLevels = Math.max(1, header[DDS_CONSTANTS.MIPMAPCOUNT_INDEX]);\n  }\n  const width = header[DDS_CONSTANTS.HEADER_WIDTH_INDEX];\n  const height = header[DDS_CONSTANTS.HEADER_HEIGHT_INDEX];\n  const dataOffset = header[DDS_CONSTANTS.HEADER_SIZE_INDEX] + 4;\n  const image = new Uint8Array(data, dataOffset);\n\n  return extractMipmapImages(image, {\n    mipMapLevels,\n    width,\n    height,\n    sizeFunction,\n    internalFormat\n  });\n}\n\n/**\n * DXT1 applicable function to calculate level size\n * @param width - level width\n * @param height - level height\n * @returns level size in bytes\n */\nexport function getDxt1LevelSize(width: number, height: number): number {\n  return ((width + 3) >> 2) * ((height + 3) >> 2) * 8;\n}\n\n/**\n * DXT3 & DXT5 applicable function to calculate level size\n * @param width - level width\n * @param height - level height\n * @returns level size in bytes\n */\nexport function getDxtXLevelSize(width: number, height: number): number {\n  return ((width + 3) >> 2) * ((height + 3) >> 2) * 16;\n}\n\n/**\n * Convert every byte of Int32 value to char\n * @param value - Int32 number\n * @returns string of 4 characters\n */\nfunction int32ToFourCC(value: number): string {\n  return String.fromCharCode(\n    value & 0xff,\n    (value >> 8) & 0xff,\n    (value >> 16) & 0xff,\n    (value >> 24) & 0xff\n  );\n}\n", "/* eslint-disable camelcase */\n// Forked from PicoGL: https://github.com/tsherif/picogl.js/blob/master/examples/utils/utils.js\n// Copyright (c) 2017 Tarek Sherif, The MIT License (MIT)\n\nimport type {TextureLevel} from '@loaders.gl/schema';\nimport {GL_EXTENSIONS_CONSTANTS} from '../gl-extensions';\nimport {extractMipmapImages} from '../utils/extract-mipmap-images';\n\nconst PVR_CONSTANTS: Record<string, number> = {\n  MAGIC_NUMBER: 0x03525650,\n  MAGIC_NUMBER_EXTRA: 0x50565203,\n  HEADER_LENGTH: 13,\n  HEADER_SIZE: 52,\n  MAGIC_NUMBER_INDEX: 0,\n  PIXEL_FORMAT_INDEX: 2,\n  COLOUR_SPACE_INDEX: 4,\n  HEIGHT_INDEX: 6,\n  WIDTH_INDEX: 7,\n  MIPMAPCOUNT_INDEX: 11,\n  METADATA_SIZE_INDEX: 12\n};\n\nconst PVR_PIXEL_FORMATS: Record<number, number[]> = {\n  0: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG],\n  1: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG],\n  2: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG],\n  3: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG],\n  6: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_ETC1_WEBGL],\n  7: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB_S3TC_DXT1_EXT],\n  9: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT3_EXT],\n  11: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_S3TC_DXT5_EXT],\n  22: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_ETC2],\n  23: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA8_ETC2_EAC],\n  24: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2],\n  25: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_R11_EAC],\n  26: [GL_EXTENSIONS_CONSTANTS.COMPRESSED_RG11_EAC],\n  27: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_4X4_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR\n  ],\n  28: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5X4_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR\n  ],\n  29: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_5X5_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR\n  ],\n  30: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6X5_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR\n  ],\n  31: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_6X6_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR\n  ],\n  32: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X5_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR\n  ],\n  33: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X6_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR\n  ],\n  34: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_8X8_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR\n  ],\n  35: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X5_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR\n  ],\n  36: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X6_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR\n  ],\n  37: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X8_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR\n  ],\n  38: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_10X10_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR\n  ],\n  39: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12X10_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR\n  ],\n  40: [\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_RGBA_ASTC_12X12_KHR,\n    GL_EXTENSIONS_CONSTANTS.COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR\n  ]\n};\n\nconst PVR_SIZE_FUNCTIONS: Record<number, (width: number, height: number) => number> = {\n  0: pvrtc2bppSize,\n  1: pvrtc2bppSize,\n  2: pvrtc4bppSize,\n  3: pvrtc4bppSize,\n  6: dxtEtcSmallSize,\n  7: dxtEtcSmallSize,\n  9: dxtEtcAstcBigSize,\n  11: dxtEtcAstcBigSize,\n  22: dxtEtcSmallSize,\n  23: dxtEtcAstcBigSize,\n  24: dxtEtcSmallSize,\n  25: dxtEtcSmallSize,\n  26: dxtEtcAstcBigSize,\n  27: dxtEtcAstcBigSize,\n  28: atc5x4Size,\n  29: atc5x5Size,\n  30: atc6x5Size,\n  31: atc6x6Size,\n  32: atc8x5Size,\n  33: atc8x6Size,\n  34: atc8x8Size,\n  35: atc10x5Size,\n  36: atc10x6Size,\n  37: atc10x8Size,\n  38: atc10x10Size,\n  39: atc12x10Size,\n  40: atc12x12Size\n};\n\n/**\n * Check if data is in \"PVR\" format by its magic number\n * @param data - binary data of compressed texture\n * @returns true - data in \"PVR\" format, else - false\n */\nexport function isPVR(data: ArrayBuffer): boolean {\n  const header = new Uint32Array(data, 0, PVR_CONSTANTS.HEADER_LENGTH);\n  const version = header[PVR_CONSTANTS.MAGIC_NUMBER_INDEX];\n\n  return version === PVR_CONSTANTS.MAGIC_NUMBER || version === PVR_CONSTANTS.MAGIC_NUMBER_EXTRA;\n}\n\n/**\n * Parse texture data as \"PVR\" format\n * @param data - binary data of compressed texture\n * @returns Array of the texture levels\n * @see http://cdn.imgtec.com/sdk-documentation/PVR+File+Format.Specification.pdf\n */\nexport function parsePVR(data: ArrayBuffer): TextureLevel[] {\n  const header = new Uint32Array(data, 0, PVR_CONSTANTS.HEADER_LENGTH);\n\n  const pvrFormat = header[PVR_CONSTANTS.PIXEL_FORMAT_INDEX];\n  const colourSpace = header[PVR_CONSTANTS.COLOUR_SPACE_INDEX];\n  const pixelFormats = PVR_PIXEL_FORMATS[pvrFormat] || [];\n  const internalFormat = pixelFormats.length > 1 && colourSpace ? pixelFormats[1] : pixelFormats[0];\n\n  const sizeFunction = PVR_SIZE_FUNCTIONS[pvrFormat];\n\n  const mipMapLevels = header[PVR_CONSTANTS.MIPMAPCOUNT_INDEX];\n\n  const width = header[PVR_CONSTANTS.WIDTH_INDEX];\n  const height = header[PVR_CONSTANTS.HEIGHT_INDEX];\n\n  const dataOffset = PVR_CONSTANTS.HEADER_SIZE + header[PVR_CONSTANTS.METADATA_SIZE_INDEX];\n\n  const image = new Uint8Array(data, dataOffset);\n\n  return extractMipmapImages(image, {\n    mipMapLevels,\n    width,\n    height,\n    sizeFunction,\n    internalFormat\n  });\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/\nfunction pvrtc2bppSize(width: number, height: number): number {\n  width = Math.max(width, 16);\n  height = Math.max(height, 8);\n\n  return (width * height) / 4;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/\nfunction pvrtc4bppSize(width: number, height: number): number {\n  width = Math.max(width, 8);\n  height = Math.max(height, 8);\n\n  return (width * height) / 2;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/\n// Size for:\n// COMPRESSED_RGB_S3TC_DXT1_EXT\n// COMPRESSED_R11_EAC\n// COMPRESSED_SIGNED_R11_EAC\n// COMPRESSED_RGB8_ETC2\n// COMPRESSED_SRGB8_ETC2\n// COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2\n// COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2\nfunction dxtEtcSmallSize(width: number, height: number): number {\n  return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc/\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\n// Size for:\n// COMPRESSED_RGBA_S3TC_DXT3_EXT\n// COMPRESSED_RGBA_S3TC_DXT5_EXT\n// COMPRESSED_RG11_EAC\n// COMPRESSED_SIGNED_RG11_EAC\n// COMPRESSED_RGBA8_ETC2_EAC\n// COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\n// COMPRESSED_RGBA_ASTC_4x4_KHR\nfunction dxtEtcAstcBigSize(width: number, height: number): number {\n  return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc5x4Size(width: number, height: number): number {\n  return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc5x5Size(width: number, height: number): number {\n  return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc6x5Size(width: number, height: number): number {\n  return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc6x6Size(width: number, height: number): number {\n  return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc8x5Size(width: number, height: number): number {\n  return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc8x6Size(width: number, height: number): number {\n  return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc8x8Size(width: number, height: number): number {\n  return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc10x5Size(width: number, height: number): number {\n  return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc10x6Size(width: number, height: number): number {\n  return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc10x8Size(width: number, height: number): number {\n  return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc10x10Size(width: number, height: number): number {\n  return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc12x10Size(width: number, height: number): number {\n  return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;\n}\n\n// https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_astc/\nfunction atc12x12Size(width: number, height: number): number {\n  return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;\n}\n", "import type {TextureLevel} from '@loaders.gl/schema';\nimport {isKTX, parseKTX} from './parse-ktx';\nimport {isDDS, parseDDS} from './parse-dds';\nimport {isPVR, parsePVR} from './parse-pvr';\n\n/**\n * Deduces format and parses compressed texture loaded in ArrayBuffer\n * @param data - binary data of compressed texture\n * @returns Array of the texture levels\n */\nexport function parseCompressedTexture(data: ArrayBuffer): TextureLevel[] {\n  if (isKTX(data)) {\n    // TODO: remove @ts-ignore when `parseKTX` output is normalized to loaders.gl texture format\n    // @ts-ignore\n    return parseKTX(data);\n  }\n  if (isDDS(data)) {\n    return parseDDS(data);\n  }\n  if (isPVR(data)) {\n    return parsePVR(data);\n  }\n  throw new Error('Texture container format not recognized');\n}\n", "import type {Loader, LoaderWithParser} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport {parseCompressedTexture} from './lib/parsers/parse-compressed-texture';\nimport parseBasis from './lib/parsers/parse-basis';\n\nexport type TextureLoaderOptions = {\n  'compressed-texture'?: {\n    libraryPath?: string;\n    useBasis?: boolean;\n  };\n};\n\nconst DEFAULT_TEXTURE_LOADER_OPTIONS = {\n  'compressed-texture': {\n    libraryPath: 'libs/',\n    useBasis: false\n  }\n};\n\n/**\n * Worker Loader for KTX, DDS, and PVR texture container formats\n */\nexport const CompressedTextureWorkerLoader = {\n  name: 'Texture Containers',\n  id: 'compressed-texture',\n  module: 'textures',\n  version: VERSION,\n  worker: true,\n  extensions: [\n    'ktx',\n    'ktx2',\n    'dds', // WEBGL_compressed_texture_s3tc, WEBGL_compressed_texture_atc\n    'pvr' // WEBGL_compressed_texture_pvrtc\n  ],\n  mimeTypes: [\n    'image/ktx2',\n    'image/ktx',\n    'image/vnd-ms.dds',\n    'image/x-dds',\n    'application/octet-stream'\n  ],\n  binary: true,\n  options: DEFAULT_TEXTURE_LOADER_OPTIONS\n};\n\n/**\n * Loader for KTX, DDS, and PVR texture container formats\n */\nexport const CompressedTextureLoader = {\n  ...CompressedTextureWorkerLoader,\n  parse: async (arrayBuffer, options) => {\n    if (options['compressed-texture'].useBasis) {\n      options.basis = {\n        format: {\n          alpha: 'BC3',\n          noAlpha: 'BC1'\n        },\n        ...options.basis,\n        containerFormat: 'ktx2',\n        module: 'encoder'\n      };\n      return (await parseBasis(arrayBuffer, options))[0];\n    }\n    return parseCompressedTexture(arrayBuffer);\n  }\n};\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckCompressedTextureWorkerLoader: Loader = CompressedTextureWorkerLoader;\nexport const _TypecheckCompressedTextureLoader: LoaderWithParser = CompressedTextureLoader;\n", "// import type {TextureLevel} from '@loaders.gl/schema';\n\ntype NumpyHeader = {descr: string; shape: number[]};\ntype TypedArrayConstructor =\n  | typeof Int8Array\n  | typeof Uint8Array\n  | typeof Int16Array\n  | typeof Uint16Array\n  | typeof Int32Array\n  | typeof Uint32Array\n  | typeof Int32Array\n  | typeof Uint32Array\n  | typeof Float32Array\n  | typeof Float64Array;\n\nfunction systemIsLittleEndian() {\n  const a = new Uint32Array([0x12345678]);\n  const b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n  return !(b[0] === 0x12);\n}\n\nconst LITTLE_ENDIAN_OS = systemIsLittleEndian();\n\n// The basic string format consists of 3 characters:\n// 1. a character describing the byteorder of the data (<: little-endian, >: big-endian, |: not-relevant)\n// 2. a character code giving the basic type of the array\n// 3. an integer providing the number of bytes the type uses.\n// https://numpy.org/doc/stable/reference/arrays.interface.html\n//\n// Here I only include the second and third characters, and check endianness\n// separately\nconst DTYPES: Record<string, TypedArrayConstructor> = {\n  u1: Uint8Array,\n  i1: Int8Array,\n  u2: Uint16Array,\n  i2: Int16Array,\n  u4: Uint32Array,\n  i4: Int32Array,\n  f4: Float32Array,\n  f8: Float64Array\n};\n\nexport function parseNPY(arrayBuffer: ArrayBuffer, options?: unknown) {\n  if (!arrayBuffer) {\n    return null;\n  }\n\n  const view = new DataView(arrayBuffer);\n  const {header, headerEndOffset} = parseHeader(view);\n\n  const numpyType = header.descr;\n  const ArrayType = DTYPES[numpyType.slice(1, 3)];\n  if (!ArrayType) {\n    throw new Error(`Unimplemented type ${numpyType}`);\n  }\n\n  const nArrayElements = header.shape?.reduce((a: number, b: number): number => a * b);\n  const arrayByteLength = nArrayElements * ArrayType.BYTES_PER_ELEMENT;\n\n  if (arrayBuffer.byteLength < headerEndOffset + arrayByteLength) {\n    throw new Error('Buffer overflow');\n  }\n  const data = new ArrayType(arrayBuffer.slice(headerEndOffset, headerEndOffset + arrayByteLength));\n\n  // Swap endianness if needed\n  if ((numpyType[0] === '>' && LITTLE_ENDIAN_OS) || (numpyType[0] === '<' && !LITTLE_ENDIAN_OS)) {\n    throw new Error('Incorrect endianness');\n  }\n\n  return {\n    data,\n    header\n  };\n}\n\n/**\n * Parse NPY header\n *\n * @param  view\n * @return\n */\nfunction parseHeader(view: DataView): {header: NumpyHeader; headerEndOffset: number} {\n  const majorVersion = view.getUint8(6);\n  // const minorVersion = view.getUint8(7);\n\n  let offset = 8;\n  let headerLength: number;\n  if (majorVersion >= 2) {\n    headerLength = view.getUint32(offset, true);\n    offset += 4;\n  } else {\n    headerLength = view.getUint16(offset, true);\n    offset += 2;\n  }\n\n  const encoding = majorVersion <= 2 ? 'latin1' : 'utf-8';\n  const decoder = new TextDecoder(encoding);\n  const headerArray = new Uint8Array(view.buffer, offset, headerLength);\n  const headerText = decoder.decode(headerArray);\n  offset += headerLength;\n\n  const header = JSON.parse(\n    headerText\n      .replace(/'/g, '\"')\n      .replace('False', 'false')\n      .replace('(', '[')\n      .replace(/,*\\),*/g, ']')\n  );\n\n  return {header, headerEndOffset: offset};\n}\n", "import type {Loader, LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport {parseNPY} from './lib/parsers/parse-npy';\n\n// \\x93NUMPY\nconst NPY_MAGIC_NUMBER = new Uint8Array([147, 78, 85, 77, 80, 89]);\n\n/**\n * Worker loader for numpy \"tiles\"\n */\nexport const NPYWorkerLoader = {\n  name: 'NPY',\n  id: 'npy',\n  module: 'textures',\n  version: VERSION,\n  worker: true,\n  extensions: ['npy'],\n  mimeTypes: [],\n  tests: [NPY_MAGIC_NUMBER.buffer],\n  options: {\n    npy: {}\n  }\n};\n\n/**\n * Loader for numpy \"tiles\"\n */\nexport const NPYLoader = {\n  ...NPYWorkerLoader,\n  parseSync: parseNPY,\n  parse: async (arrayBuffer: ArrayBuffer, options?: LoaderOptions) => parseNPY(arrayBuffer, options)\n};\n\n// TYPE TESTS - TODO find a better way than exporting junk\nexport const _TypecheckNPYWorkerLoader: Loader = NPYWorkerLoader;\nexport const _TypecheckNPYLoader: LoaderWithParser = NPYLoader;\n", "// Replacement for the external assert method to reduce bundle size\n// Note: We don't use the second \"message\" argument in calling code,\n// so no need to support it here\nexport function assert(condition: unknown, message?: string): void {\n  if (!condition) {\n    throw new Error(message || 'assert failed: gltf');\n  }\n}\n", "// Resolves a relative url against a baseUrl\n// If url is absolute, return it unchanged\nexport function resolveUrl(url, options) {\n  // TODO: Use better logic to handle all protocols plus not delay on data\n  const absolute = url.startsWith('data:') || url.startsWith('http:') || url.startsWith('https:');\n  if (absolute) {\n    return url;\n  }\n  const baseUrl = options.baseUri || options.uri;\n  if (!baseUrl) {\n    throw new Error(`'baseUri' must be provided to resolve relative url ${url}`);\n  }\n  return baseUrl.substr(0, baseUrl.lastIndexOf('/') + 1) + url;\n}\n", "// TODO - GLTFScenegraph should use these\nimport {assert} from '../utils/assert';\n\n// accepts buffer view index or buffer view object\n// returns a `Uint8Array`\nexport function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {\n  const bufferView = json.bufferViews[bufferViewIndex];\n  assert(bufferView);\n\n  // Get hold of the arrayBuffer\n  const bufferIndex = bufferView.buffer;\n  const binChunk = buffers[bufferIndex];\n  assert(binChunk);\n\n  const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n  return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n}\n\n// accepts accessor index or accessor object\n// returns a `Uint8Array`\nexport function getTypedArrayForImageData(json, buffers, imageIndex) {\n  const image = json.images[imageIndex];\n  const bufferViewIndex = json.bufferViews[image.bufferView];\n  return getTypedArrayForBufferView(json, buffers, bufferViewIndex);\n}\n\n/*\n// accepts accessor index or accessor object\n// returns a typed array with type that matches the types\nexport function getTypedArrayForAccessor(accessor) {\n  accessor = this.getAccessor(accessor);\n  const bufferView = this.getBufferView(accessor.bufferView);\n  const buffer = this.getBuffer(bufferView.buffer);\n  const arrayBuffer = buffer.data;\n\n  // Create a new typed array as a view into the combined buffer\n  const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n  const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n  return new ArrayType(arrayBuffer, byteOffset, length);\n}\n*/\n", "import {assert} from '../utils/assert';\n\nconst TYPES = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'];\n\ntype TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Uint8ArrayConstructor\n  | Int16ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor;\n\nconst ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT: [TypedArrayConstructor, number][] = [\n  [Int8Array, 5120],\n  [Uint8Array, 5121],\n  [Int16Array, 5122],\n  [Uint16Array, 5123],\n  [Uint32Array, 5125],\n  [Float32Array, 5126],\n  [Float64Array, 5130]\n];\nconst ARRAY_TO_COMPONENT_TYPE = new Map<TypedArrayConstructor, number>(\n  ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT\n);\n\nconst ATTRIBUTE_TYPE_TO_COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {\n  5120: 1,\n  5121: 1,\n  5122: 2,\n  5123: 2,\n  5125: 4,\n  5126: 4\n};\n\nconst ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\n\nexport function getAccessorTypeFromSize(size) {\n  const type = TYPES[size - 1];\n  return type || TYPES[0];\n}\n\nexport function getComponentTypeFromArray(typedArray) {\n  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);\n  if (!componentType) {\n    throw new Error('Illegal typed array');\n  }\n  return componentType;\n}\n\nexport function getAccessorArrayTypeAndLength(accessor, bufferView) {\n  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];\n  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];\n  const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];\n  const length = accessor.count * components;\n  const byteLength = accessor.count * components * bytesPerComponent;\n  assert(byteLength >= 0 && byteLength <= bufferView.byteLength);\n  return {ArrayType, length, byteLength};\n}\n", "import type {\n  GLTF,\n  GLTFScene,\n  GLTFNode,\n  GLTFMesh,\n  GLTFSkin,\n  GLTFMaterial,\n  GLTFAccessor,\n  GLTFSampler,\n  GLTFTexture,\n  GLTFImage,\n  GLTFBuffer,\n  GLTFBufferView,\n  GLTFWithBuffers\n} from '../types/gltf-types';\n\nimport {getBinaryImageMetadata} from '@loaders.gl/images';\nimport {padToNBytes, copyToArray} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {\n  getAccessorArrayTypeAndLength,\n  getAccessorTypeFromSize,\n  getComponentTypeFromArray\n} from '../gltf-utils/gltf-utils';\n\nconst DEFAULT_GLTF_JSON: GLTF = {\n  asset: {\n    version: '2.0',\n    generator: 'loaders.gl'\n  },\n  buffers: []\n};\n\ntype Extension = {[key: string]: any};\n/**\n * Class for structured access to GLTF data\n */\nexport default class GLTFScenegraph {\n  // internal\n  gltf: GLTFWithBuffers;\n  sourceBuffers: any[];\n  byteLength: number;\n\n  constructor(gltf?: {json: GLTF; buffers?: any[]}) {\n    // @ts-ignore\n    this.gltf = gltf || {\n      json: {...DEFAULT_GLTF_JSON},\n      buffers: []\n    };\n    this.sourceBuffers = [];\n    this.byteLength = 0;\n\n    // Initialize buffers\n    if (this.gltf.buffers && this.gltf.buffers[0]) {\n      this.byteLength = this.gltf.buffers[0].byteLength;\n      this.sourceBuffers = [this.gltf.buffers[0]];\n    }\n  }\n\n  // Accessors\n\n  get json(): GLTF {\n    return this.gltf.json;\n  }\n\n  getApplicationData(key: string): unknown {\n    // TODO - Data is already unpacked by GLBParser\n    const data = this.json[key];\n    return data;\n  }\n\n  getExtraData(key: string): {[key: string]: unknown} {\n    // TODO - Data is already unpacked by GLBParser\n    const extras = this.json.extras || {};\n    return extras[key];\n  }\n\n  getExtension<T = Extension>(extensionName: string): T | null {\n    const isExtension = this.getUsedExtensions().find((name) => name === extensionName);\n    const extensions = this.json.extensions || {};\n    return isExtension ? extensions[extensionName] || true : null;\n  }\n\n  getRequiredExtension<T = Extension>(extensionName: string): T | null {\n    const isRequired = this.getRequiredExtensions().find((name) => name === extensionName);\n    return isRequired ? this.getExtension(extensionName) : null;\n  }\n\n  getRequiredExtensions(): string[] {\n    return this.json.extensionsRequired || [];\n  }\n\n  getUsedExtensions(): string[] {\n    return this.json.extensionsUsed || [];\n  }\n\n  getRemovedExtensions(): string[] {\n    return (this.json.extensionsRemoved || []) as string[];\n  }\n\n  getObjectExtension<T = Extension>(object: {[key: string]: any}, extensionName: string): T | null {\n    const extensions = object.extensions || {};\n    return extensions[extensionName];\n  }\n\n  getScene(index: number): GLTFScene {\n    return this.getObject('scenes', index) as GLTFScene;\n  }\n\n  getNode(index: number): GLTFNode {\n    return this.getObject('nodes', index) as GLTFNode;\n  }\n\n  getSkin(index: number): GLTFSkin {\n    return this.getObject('skins', index) as GLTFSkin;\n  }\n\n  getMesh(index: number): GLTFMesh {\n    return this.getObject('meshes', index) as GLTFMesh;\n  }\n\n  getMaterial(index: number): GLTFMaterial {\n    return this.getObject('materials', index) as GLTFMaterial;\n  }\n\n  getAccessor(index: number): GLTFAccessor {\n    return this.getObject('accessors', index) as GLTFAccessor;\n  }\n\n  // getCamera(index: number): object | null {\n  //   return null; // TODO: fix thi: object  as null;\n  // }\n\n  getTexture(index: number): GLTFTexture {\n    return this.getObject('textures', index) as GLTFTexture;\n  }\n\n  getSampler(index: number): GLTFSampler {\n    return this.getObject('samplers', index) as GLTFSampler;\n  }\n\n  getImage(index: number): GLTFImage {\n    return this.getObject('images', index) as GLTFImage;\n  }\n\n  getBufferView(index: number | object): GLTFBufferView {\n    return this.getObject('bufferViews', index) as GLTFBufferView;\n  }\n\n  getBuffer(index: number): GLTFBuffer {\n    return this.getObject('buffers', index) as GLTFBuffer;\n  }\n\n  getObject(array: string, index: number | object): object {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && (this.json[array] as {}[])[index];\n    if (!object) {\n      throw new Error(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  /**\n   * Accepts buffer view index or buffer view object\n   * @returns a `Uint8Array`\n   */\n  getTypedArrayForBufferView(bufferView: number | object): Uint8Array {\n    bufferView = this.getBufferView(bufferView);\n    // @ts-ignore\n    const bufferIndex = bufferView.buffer;\n\n    // Get hold of the arrayBuffer\n    // const buffer = this.getBuffer(bufferIndex);\n    const binChunk = this.gltf.buffers[bufferIndex];\n    assert(binChunk);\n\n    // @ts-ignore\n    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;\n    // @ts-ignore\n    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  /** Accepts accessor index or accessor object\n   * @returns a typed array with type that matches the types\n   */\n  getTypedArrayForAccessor(accessor: number | object): any {\n    // @ts-ignore\n    accessor = this.getAccessor(accessor);\n    // @ts-ignore\n    const bufferView = this.getBufferView(accessor.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n\n    // Create a new typed array as a view into the combined buffer\n    const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n    // @ts-ignore\n    const byteOffset = bufferView.byteOffset + accessor.byteOffset;\n    return new ArrayType(arrayBuffer, byteOffset, length);\n  }\n\n  /** accepts accessor index or accessor object\n   * returns a `Uint8Array`\n   */\n  getTypedArrayForImageData(image: number | object): Uint8Array {\n    // @ts-ignore\n    image = this.getAccessor(image);\n    // @ts-ignore\n    const bufferView = this.getBufferView(image.bufferView);\n    const buffer = this.getBuffer(bufferView.buffer);\n    // @ts-ignore\n    const arrayBuffer = buffer.data;\n\n    const byteOffset = bufferView.byteOffset || 0;\n    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n  }\n\n  // MODIFERS\n\n  /**\n   * Add an extra application-defined key to the top-level data structure\n   */\n  addApplicationData(key: string, data: object): GLTFScenegraph {\n    this.json[key] = data;\n    return this;\n  }\n\n  /**\n   * `extras` - Standard GLTF field for storing application specific data\n   */\n  addExtraData(key: string, data: object): GLTFScenegraph {\n    this.json.extras = this.json.extras || {};\n    (this.json.extras as Record<string, unknown>)[key] = data;\n    return this;\n  }\n\n  addObjectExtension(object: object, extensionName: string, data: object): GLTFScenegraph {\n    // @ts-ignore\n    object.extensions = object.extensions || {};\n    // TODO - clobber or merge?\n    // @ts-ignore\n    object.extensions[extensionName] = data;\n    this.registerUsedExtension(extensionName);\n    return this;\n  }\n\n  setObjectExtension(object: object, extensionName: string, data: object): void {\n    // @ts-ignore\n    const extensions = object.extensions || {};\n    extensions[extensionName] = data;\n    // TODO - add to usedExtensions...\n  }\n\n  removeObjectExtension(object: object, extensionName: string): object {\n    // @ts-ignore\n    const extensions = object.extensions || {};\n    const extension = extensions[extensionName];\n    delete extensions[extensionName];\n    return extension;\n  }\n\n  /**\n   * Add to standard GLTF top level extension object, mark as used\n   */\n  addExtension(extensionName: string, extensionData: object = {}): object {\n    assert(extensionData);\n    this.json.extensions = this.json.extensions || {};\n    (this.json.extensions as Record<string, unknown>)[extensionName] = extensionData;\n    this.registerUsedExtension(extensionName);\n    return extensionData;\n  }\n\n  /**\n   * Standard GLTF top level extension object, mark as used and required\n   */\n  addRequiredExtension(extensionName, extensionData: object = {}): object {\n    assert(extensionData);\n    this.addExtension(extensionName, extensionData);\n    this.registerRequiredExtension(extensionName);\n    return extensionData;\n  }\n\n  /**\n   * Add extensionName to list of used extensions\n   */\n  registerUsedExtension(extensionName: string): void {\n    this.json.extensionsUsed = this.json.extensionsUsed || [];\n    if (!this.json.extensionsUsed.find((ext) => ext === extensionName)) {\n      this.json.extensionsUsed.push(extensionName);\n    }\n  }\n\n  /**\n   * Add extensionName to list of required extensions\n   */\n  registerRequiredExtension(extensionName: string): void {\n    this.registerUsedExtension(extensionName);\n    this.json.extensionsRequired = this.json.extensionsRequired || [];\n    if (!this.json.extensionsRequired.find((ext) => ext === extensionName)) {\n      this.json.extensionsRequired.push(extensionName);\n    }\n  }\n\n  /**\n   * Removes an extension from the top-level list\n   */\n  removeExtension(extensionName: string): void {\n    if (!this.getExtension(extensionName)) {\n      return;\n    }\n    if (this.json.extensionsRequired) {\n      this._removeStringFromArray(this.json.extensionsRequired, extensionName);\n    }\n    if (this.json.extensionsUsed) {\n      this._removeStringFromArray(this.json.extensionsUsed, extensionName);\n    }\n    if (this.json.extensions) {\n      delete this.json.extensions[extensionName];\n    }\n    if (!Array.isArray(this.json.extensionsRemoved)) {\n      this.json.extensionsRemoved = [];\n    }\n    const extensionsRemoved = this.json.extensionsRemoved as string[];\n    if (!extensionsRemoved.includes(extensionName)) {\n      extensionsRemoved.push(extensionName);\n    }\n  }\n\n  /**\n   *  Set default scene which is to be displayed at load time\n   */\n  setDefaultScene(sceneIndex: number): void {\n    this.json.scene = sceneIndex;\n  }\n\n  /**\n   * @todo: add more properties for scene initialization:\n   *   name`, `extensions`, `extras`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene\n   */\n  addScene(scene: {nodeIndices: number[]}): number {\n    const {nodeIndices} = scene;\n    this.json.scenes = this.json.scenes || [];\n    this.json.scenes.push({nodes: nodeIndices});\n    return this.json.scenes.length - 1;\n  }\n\n  /**\n   * @todo: add more properties for node initialization:\n   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`\n   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node\n   */\n  addNode(node: {meshIndex: number; matrix?: number[]}): number {\n    const {meshIndex, matrix} = node;\n    this.json.nodes = this.json.nodes || [];\n    const nodeData = {mesh: meshIndex};\n    if (matrix) {\n      // @ts-ignore\n      nodeData.matrix = matrix;\n    }\n    this.json.nodes.push(nodeData);\n    return this.json.nodes.length - 1;\n  }\n\n  /** Adds a mesh to the json part */\n  addMesh(mesh: {attributes: object; indices?: object; material?: number; mode?: number}): number {\n    const {attributes, indices, material, mode = 4} = mesh;\n    const accessors = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: accessors,\n          mode\n        }\n      ]\n    };\n\n    if (indices) {\n      const indicesAccessor = this._addIndices(indices);\n      // @ts-ignore\n      glTFMesh.primitives[0].indices = indicesAccessor;\n    }\n\n    if (Number.isFinite(material)) {\n      // @ts-ignore\n      glTFMesh.primitives[0].material = material;\n    }\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  addPointCloud(attributes: object): number {\n    // @ts-ignore\n    const accessorIndices = this._addAttributes(attributes);\n\n    const glTFMesh = {\n      primitives: [\n        {\n          attributes: accessorIndices,\n          mode: 0 // GL.POINTS\n        }\n      ]\n    };\n\n    this.json.meshes = this.json.meshes || [];\n    this.json.meshes.push(glTFMesh);\n    return this.json.meshes.length - 1;\n  }\n\n  /**\n   * Adds a binary image. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes as glTF image\n   * @param imageData\n   * @param mimeType\n   */\n  addImage(imageData: any, mimeTypeOpt?: string): number {\n    // If image is referencing a bufferView instead of URI, mimeType must be defined:\n    //   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images\n    //   \"a reference to a bufferView; in that case mimeType must be defined.\"\n    const metadata = getBinaryImageMetadata(imageData);\n    const mimeType = mimeTypeOpt || metadata?.mimeType;\n\n    const bufferViewIndex = this.addBufferView(imageData);\n\n    const glTFImage = {\n      bufferView: bufferViewIndex,\n      mimeType\n    };\n\n    this.json.images = this.json.images || [];\n    this.json.images.push(glTFImage);\n    return this.json.images.length - 1;\n  }\n\n  /**\n   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index\n   * @param buffer\n   */\n  addBufferView(buffer: any): number {\n    const byteLength = buffer.byteLength;\n    assert(Number.isFinite(byteLength));\n\n    // Add this buffer to the list of buffers to be written to the body.\n    this.sourceBuffers = this.sourceBuffers || [];\n    this.sourceBuffers.push(buffer);\n\n    const glTFBufferView = {\n      buffer: 0,\n      // Write offset from the start of the binary body\n      byteOffset: this.byteLength,\n      byteLength\n    };\n\n    // We've now added the contents to the body, so update the total length\n    // Every sub-chunk needs to be 4-byte align ed\n    this.byteLength += padToNBytes(byteLength, 4);\n\n    // Add a bufferView indicating start and length of this binary sub-chunk\n    this.json.bufferViews = this.json.bufferViews || [];\n    this.json.bufferViews.push(glTFBufferView);\n    return this.json.bufferViews.length - 1;\n  }\n\n  /**\n   * Adds an accessor to a bufferView\n   * @param bufferViewIndex\n   * @param accessor\n   */\n  addAccessor(bufferViewIndex: number, accessor: object): number {\n    const glTFAccessor = {\n      bufferView: bufferViewIndex,\n      // @ts-ignore\n      type: getAccessorTypeFromSize(accessor.size),\n      // @ts-ignore\n      componentType: accessor.componentType,\n      // @ts-ignore\n      count: accessor.count,\n      // @ts-ignore\n      max: accessor.max,\n      // @ts-ignore\n      min: accessor.min\n    };\n\n    this.json.accessors = this.json.accessors || [];\n    this.json.accessors.push(glTFAccessor);\n    return this.json.accessors.length - 1;\n  }\n\n  /**\n   * Add a binary buffer. Builds glTF \"JSON metadata\" and saves buffer reference\n   * Buffer will be copied into BIN chunk during \"pack\"\n   * Currently encodes buffers as glTF accessors, but this could be optimized\n   * @param sourceBuffer\n   * @param accessor\n   */\n  addBinaryBuffer(sourceBuffer: any, accessor: object = {size: 3}): number {\n    const bufferViewIndex = this.addBufferView(sourceBuffer);\n    // @ts-ignore\n    let minMax = {min: accessor.min, max: accessor.max};\n    if (!minMax.min || !minMax.max) {\n      // @ts-ignore\n      minMax = this._getAccessorMinMax(sourceBuffer, accessor.size);\n    }\n\n    const accessorDefaults = {\n      // @ts-ignore\n      size: accessor.size,\n      componentType: getComponentTypeFromArray(sourceBuffer),\n      // @ts-ignore\n      count: Math.round(sourceBuffer.length / accessor.size),\n      min: minMax.min,\n      max: minMax.max\n    };\n\n    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));\n  }\n\n  /**\n   * Adds a texture to the json part\n   * @todo: add more properties for texture initialization\n   * `sampler`, `name`, `extensions`, `extras`\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\n   */\n  addTexture(texture: {imageIndex: number}): number {\n    const {imageIndex} = texture;\n    const glTFTexture = {\n      source: imageIndex\n    };\n\n    this.json.textures = this.json.textures || [];\n    this.json.textures.push(glTFTexture);\n    return this.json.textures.length - 1;\n  }\n\n  /** Adds a material to the json part */\n  addMaterial(pbrMaterialInfo: Object): number {\n    this.json.materials = this.json.materials || [];\n    this.json.materials.push(pbrMaterialInfo);\n    return this.json.materials.length - 1;\n  }\n\n  /** Pack the binary chunk */\n  createBinaryChunk(): void {\n    // Encoder expects this array undefined or empty\n    this.gltf.buffers = [];\n\n    // Allocate total array\n    const totalByteLength = this.byteLength;\n    const arrayBuffer = new ArrayBuffer(totalByteLength);\n    const targetArray = new Uint8Array(arrayBuffer);\n\n    // Copy each array into\n    let dstByteOffset = 0;\n    for (const sourceBuffer of this.sourceBuffers || []) {\n      dstByteOffset = copyToArray(sourceBuffer, targetArray, dstByteOffset);\n    }\n\n    // Update the glTF BIN CHUNK byte length\n    if (this.json?.buffers?.[0]) {\n      this.json.buffers[0].byteLength = totalByteLength;\n    } else {\n      this.json.buffers = [{byteLength: totalByteLength}];\n    }\n\n    // Save generated arrayBuffer\n    this.gltf.binary = arrayBuffer;\n\n    // Put arrayBuffer to sourceBuffers for possible additional writing data in the chunk\n    this.sourceBuffers = [arrayBuffer];\n  }\n\n  // PRIVATE\n\n  _removeStringFromArray(array, string) {\n    let found = true;\n    while (found) {\n      const index = array.indexOf(string);\n      if (index > -1) {\n        array.splice(index, 1);\n      } else {\n        found = false;\n      }\n    }\n  }\n\n  /**\n   * Add attributes to buffers and create `attributes` object which is part of `mesh`\n   */\n  _addAttributes(attributes = {}) {\n    const result = {};\n    for (const attributeKey in attributes) {\n      const attributeData = attributes[attributeKey];\n      const attrName = this._getGltfAttributeName(attributeKey);\n      const accessor = this.addBinaryBuffer(attributeData.value, attributeData);\n      result[attrName] = accessor;\n    }\n    return result;\n  }\n\n  /**\n   * Add indices to buffers\n   */\n  _addIndices(indices) {\n    return this.addBinaryBuffer(indices, {size: 1});\n  }\n\n  /**\n   * Deduce gltf specific attribue name from input attribute name\n   */\n  _getGltfAttributeName(attributeName) {\n    switch (attributeName.toLowerCase()) {\n      case 'position':\n      case 'positions':\n      case 'vertices':\n        return 'POSITION';\n      case 'normal':\n      case 'normals':\n        return 'NORMAL';\n      case 'color':\n      case 'colors':\n        return 'COLOR_0';\n      case 'texcoord':\n      case 'texcoords':\n        return 'TEXCOORD_0';\n      default:\n        return attributeName;\n    }\n  }\n\n  /**\n   * Calculate `min` and `max` arrays of accessor according to spec:\n   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor\n   */\n  _getAccessorMinMax(buffer, size) {\n    const result = {min: null, max: null};\n    if (buffer.length < size) {\n      return result;\n    }\n    // @ts-ignore\n    result.min = [];\n    // @ts-ignore\n    result.max = [];\n    const initValues = buffer.subarray(0, size);\n    for (const value of initValues) {\n      // @ts-ignore\n      result.min.push(value);\n      // @ts-ignore\n      result.max.push(value);\n    }\n\n    for (let index = size; index < buffer.length; index += size) {\n      for (let componentIndex = 0; componentIndex < size; componentIndex++) {\n        // @ts-ignore\n        result.min[0 + componentIndex] = Math.min(\n          // @ts-ignore\n          result.min[0 + componentIndex],\n          buffer[index + componentIndex]\n        );\n        // @ts-ignore\n        result.max[0 + componentIndex] = Math.max(\n          // @ts-ignore\n          result.max[0 + componentIndex],\n          buffer[index + componentIndex]\n        );\n      }\n    }\n    return result;\n  }\n}\n", "// This file is part of meshoptimizer library and is distributed under the terms of MIT License.\n// Copyright (C) 2016-2021, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)\n\n/* eslint-disable camelcase */\nconst isWebAssemblySupported = typeof WebAssembly !== 'object';\n\n// Built with clang version 11.0.0 (https://github.com/llvm/llvm-project.git 0160ad802e899c2922bc9b29564080c22eb0908c)\n// Built from meshoptimizer 0.16\nconst wasm_base =\n  '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';\nconst wasm_simd =\n  'B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB';\n\n// Uses bulk-memory and simd extensions\nconst detector = new Uint8Array([\n  0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2,\n  12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11\n]);\n\n// Used to unpack wasm\nconst wasmpack = new Uint8Array([\n  32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113,\n  127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101,\n  130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167\n]);\n\nconst FILTERS = {\n  // legacy index-based enums for glTF\n  0: '',\n  1: 'meshopt_decodeFilterOct',\n  2: 'meshopt_decodeFilterQuat',\n  3: 'meshopt_decodeFilterExp',\n  // string-based enums for glTF\n  NONE: '',\n  OCTAHEDRAL: 'meshopt_decodeFilterOct',\n  QUATERNION: 'meshopt_decodeFilterQuat',\n  EXPONENTIAL: 'meshopt_decodeFilterExp'\n};\n\nconst DECODERS = {\n  // legacy index-based enums for glTF\n  0: 'meshopt_decodeVertexBuffer',\n  1: 'meshopt_decodeIndexBuffer',\n  2: 'meshopt_decodeIndexSequence',\n  // string-based enums for glTF\n  ATTRIBUTES: 'meshopt_decodeVertexBuffer',\n  TRIANGLES: 'meshopt_decodeIndexBuffer',\n  INDICES: 'meshopt_decodeIndexSequence'\n};\n\nexport function isMeshoptSupported(): boolean {\n  return isWebAssemblySupported;\n}\n\nexport async function meshoptDecodeVertexBuffer(\n  target: Uint8Array,\n  count: number,\n  size: number,\n  source: Uint8Array,\n  filter: string | number = 'NONE'\n): Promise<void> {\n  const instance = await loadWasmInstance();\n  decode(\n    instance,\n    instance.exports.meshopt_decodeVertexBuffer,\n    target,\n    count,\n    size,\n    source,\n    instance.exports[FILTERS[filter]]\n  );\n}\n\nexport async function meshoptDecodeIndexBuffer(\n  target: Uint8Array,\n  count: number,\n  size: number,\n  source: Uint8Array\n): Promise<void> {\n  const instance = await loadWasmInstance();\n  decode(instance, instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);\n}\n\nexport async function meshoptDecodeIndexSequence(\n  target: Uint8Array,\n  count: number,\n  size: number,\n  source: Uint8Array\n): Promise<void> {\n  const instance = await loadWasmInstance();\n  decode(instance, instance.exports.meshopt_decodeIndexSequence, target, count, size, source);\n}\n\n// eslint-disable-next-line max-params\nexport async function meshoptDecodeGltfBuffer(\n  target: Uint8Array,\n  count: number,\n  size: number,\n  source: Uint8Array,\n  mode: string,\n  filter: string | number = 'NONE'\n): Promise<void> {\n  const instance = await loadWasmInstance();\n  decode(\n    instance,\n    instance.exports[DECODERS[mode]],\n    target,\n    count,\n    size,\n    source,\n    instance.exports[FILTERS[filter || 'NONE']]\n  );\n}\n\nlet wasmPromise: Promise<WebAssembly.Instance>;\n\nasync function loadWasmInstance(): Promise<WebAssembly.Instance> {\n  // eslint-disable-next-line\n  if (!wasmPromise) {\n    wasmPromise = loadWasmModule();\n  }\n  return wasmPromise;\n}\n\nasync function loadWasmModule(): Promise<WebAssembly.Instance> {\n  let wasm = wasm_base;\n  if (WebAssembly.validate(detector)) {\n    wasm = wasm_simd;\n\n    // eslint-disable-next-line no-console\n    console.log('Warning: meshopt_decoder is using experimental SIMD support');\n  }\n\n  const result = await WebAssembly.instantiate(unpack(wasm), {});\n  await (result.instance.exports as any).__wasm_call_ctors();\n  return result.instance;\n}\n\nfunction unpack(data) {\n  const result = new Uint8Array(data.length);\n  for (let i = 0; i < data.length; ++i) {\n    const ch = data.charCodeAt(i);\n    result[i] = ch > 96 ? ch - 71 : ch > 64 ? ch - 65 : ch > 47 ? ch + 4 : ch > 46 ? 63 : 62;\n  }\n  let write = 0;\n  for (let i = 0; i < data.length; ++i) {\n    result[write++] = result[i] < 60 ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];\n  }\n  return result.buffer.slice(0, write);\n}\n\n// eslint-disable-next-line max-params\nfunction decode(instance, fun, target, count, size, source, filter?) {\n  const sbrk = instance.exports.sbrk;\n  const count4 = (count + 3) & ~3; // pad for SIMD filter\n  const tp = sbrk(count4 * size);\n  const sp = sbrk(source.length);\n  const heap = new Uint8Array(instance.exports.memory.buffer);\n  heap.set(source, sp);\n  const res = fun(tp, count, size, sp, source.length);\n  if (res === 0 && filter) {\n    filter(tp, count4, size);\n  }\n  target.set(heap.subarray(tp, tp + count * size));\n  sbrk(tp - sbrk(0));\n  if (res !== 0) {\n    throw new Error(`Malformed buffer data: ${res}`);\n  }\n}\n", "/* eslint-disable camelcase */\nimport type {GLTF, GLTFBufferView, GLTF_EXT_meshopt_compression} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\nimport {meshoptDecodeGltfBuffer} from '../../meshopt/meshopt-decoder';\n\n// @ts-ignore\n// eslint-disable-next-line\nconst DEFAULT_MESHOPT_OPTIONS = {\n  byteOffset: 0,\n  filter: 'NONE'\n};\n\n/** Extension name */\nconst EXT_MESHOPT_COMPRESSION = 'EXT_meshopt_compression';\n\nexport const name = EXT_MESHOPT_COMPRESSION;\n\nexport async function decode(gltfData: {json: GLTF}, options: GLTFLoaderOptions) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n\n  const promises: Promise<any>[] = [];\n  for (const bufferViewIndex of gltfData.json.bufferViews || []) {\n    promises.push(decodeMeshoptBufferView(scenegraph, bufferViewIndex));\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extension\n  scenegraph.removeExtension(EXT_MESHOPT_COMPRESSION);\n}\n\n/** Decode one meshopt buffer view */\nasync function decodeMeshoptBufferView(\n  scenegraph: GLTFScenegraph,\n  bufferView: GLTFBufferView\n): Promise<ArrayBuffer | null> {\n  const meshoptExtension = scenegraph.getObjectExtension<GLTF_EXT_meshopt_compression>(\n    bufferView,\n    EXT_MESHOPT_COMPRESSION\n  );\n  if (meshoptExtension) {\n    const {\n      byteOffset = 0,\n      byteLength = 0,\n      byteStride,\n      count,\n      mode,\n      filter = 'NONE',\n      buffer: bufferIndex\n    } = meshoptExtension;\n    const buffer = scenegraph.gltf.buffers[bufferIndex];\n\n    const source = new Uint8Array(buffer.arrayBuffer, buffer.byteOffset + byteOffset, byteLength);\n    const result = new Uint8Array(\n      scenegraph.gltf.buffers[bufferView.buffer].arrayBuffer,\n      bufferView.byteOffset,\n      bufferView.byteLength\n    );\n    await meshoptDecodeGltfBuffer(result, count, byteStride, source, mode, filter);\n    return result;\n  }\n\n  return null;\n}\n", "// GLTF EXTENSION: EXT_TEXTURE_WEBP\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_TEXTURE_WEBP\n/* eslint-disable camelcase */\n\nimport type {GLTF, GLTF_EXT_texture_webp} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\nimport {_isImageFormatSupported} from '@loaders.gl/images';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\n\nconst EXT_TEXTURE_WEBP = 'EXT_texture_webp';\n\n/** Extension name */\nexport const name = EXT_TEXTURE_WEBP;\n\n/**\n * Replaces a texture source reference with the extension texture\n * Done in preprocess() to prevent load of default image\n */\nexport function preprocess(gltfData: {json: GLTF}, options: GLTFLoaderOptions): void {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  if (!_isImageFormatSupported('image/webp')) {\n    if (scenegraph.getRequiredExtensions().includes(EXT_TEXTURE_WEBP)) {\n      throw new Error(`gltf: Required extension ${EXT_TEXTURE_WEBP} not supported by browser`);\n    }\n    return;\n  }\n\n  const {json} = scenegraph;\n\n  for (const texture of json.textures || []) {\n    const extension = scenegraph.getObjectExtension<GLTF_EXT_texture_webp>(\n      texture,\n      EXT_TEXTURE_WEBP\n    );\n    if (extension) {\n      // TODO - if multiple texture extensions are present which one wins?\n      texture.source = extension.source;\n    }\n    scenegraph.removeObjectExtension(texture, EXT_TEXTURE_WEBP);\n  }\n\n  // Remove the top-level extension\n  scenegraph.removeExtension(EXT_TEXTURE_WEBP);\n}\n", "// GLTF EXTENSION: KHR_texture_basisu\n// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_basisu\n/* eslint-disable camelcase */\n\nimport type {GLTF, GLTF_KHR_texture_basisu} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\n\nconst KHR_TEXTURE_BASISU = 'KHR_texture_basisu';\n\n/** Extension name */\nexport const name = KHR_TEXTURE_BASISU;\n\n/**\n * Replaces a texture source reference with the extension texture\n * Done in preprocess() to prevent load of default image\n */\nexport function preprocess(gltfData: {json: GLTF}, options: GLTFLoaderOptions): void {\n  const scene = new GLTFScenegraph(gltfData);\n  const {json} = scene;\n\n  for (const texture of json.textures || []) {\n    const extension = scene.getObjectExtension<GLTF_KHR_texture_basisu>(\n      texture,\n      KHR_TEXTURE_BASISU\n    );\n    if (extension) {\n      // TODO - if multiple texture extensions are present which one wins?\n      texture.source = extension.source;\n    }\n    scene.removeObjectExtension(texture, KHR_TEXTURE_BASISU);\n  }\n\n  // Remove the top-level extension\n  scene.removeExtension(KHR_TEXTURE_BASISU);\n}\n", "// import type {TypedArray} from '../types/loader-utils';\nimport type {GLTFAccessor} from '../types/gltf-types';\n// TODO - remove\nimport {getAccessorTypeFromSize, getComponentTypeFromArray} from './gltf-utils';\n\n// Returns a fresh attributes object with glTF-standardized attributes names\n// Attributes that cannot be identified will not be included\n// Removes `indices` if present, as it should be stored separately from the attributes\nexport function getGLTFAccessors(attributes): {[key: string]: GLTFAccessor} {\n  const accessors = {};\n  for (const name in attributes) {\n    const attribute = attributes[name];\n    if (name !== 'indices') {\n      const glTFAccessor = getGLTFAccessor(attribute);\n      accessors[name] = glTFAccessor;\n    }\n  }\n  return accessors;\n}\n\n// Fix up a single accessor.\n// Input: typed array or a partial accessor object\n// Return: accessor object\nexport function getGLTFAccessor(attribute) {\n  const {buffer, size, count} = getAccessorData(attribute);\n\n  const glTFAccessor: GLTFAccessor = {\n    // glTF Accessor values\n    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)\n    // bufferView: null,\n    // TODO: Deprecate `value` in favor of bufferView?\n    // @ts-ignore\n    value: buffer,\n    size, // Decoded `type` (e.g. SCALAR)\n\n    byteOffset: 0,\n    count,\n    type: getAccessorTypeFromSize(size),\n    componentType: getComponentTypeFromArray(buffer)\n  };\n\n  return glTFAccessor;\n}\n\n// export function getGLTFAttribute(data, gltfAttributeName): GLTFAccessor {\n//   return data.attributes[data.glTFAttributeMap[gltfAttributeName]];\n// }\n\nfunction getAccessorData(attribute) {\n  let buffer = attribute;\n  let size = 1;\n  let count = 0;\n\n  if (attribute && attribute.value) {\n    buffer = attribute.value;\n    size = attribute.size || 1;\n  }\n\n  if (buffer) {\n    if (!ArrayBuffer.isView(buffer)) {\n      buffer = toTypedArray(buffer, Float32Array);\n    }\n    count = buffer.length / size;\n  }\n\n  return {buffer, size, count};\n}\n\n// Convert non-typed arrays to arrays of specified format\nfunction toTypedArray(array, ArrayType, convertTypedArrays = false) {\n  if (!array) {\n    return null;\n  }\n  if (Array.isArray(array)) {\n    return new ArrayType(array);\n  }\n  if (convertTypedArrays && !(array instanceof ArrayType)) {\n    return new ArrayType(array);\n  }\n  return array;\n}\n", "// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n/* eslint-disable camelcase */\n\n/* eslint-disable camelcase */\nimport type {\n  GLTF,\n  GLTFAccessor,\n  GLTFMeshPrimitive,\n  GLTF_KHR_draco_mesh_compression\n} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {DracoLoaderOptions, DracoMesh} from '@loaders.gl/draco';\nimport {sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {default as Scenegraph} from '../api/gltf-scenegraph';\nimport {getGLTFAccessors, getGLTFAccessor} from '../gltf-utils/gltf-attribute-utils';\n\nconst KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';\n\n/** Extension name */\nexport const name = KHR_DRACO_MESH_COMPRESSION;\n\nexport function preprocess(\n  gltfData: {json: GLTF},\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): void {\n  const scenegraph = new Scenegraph(gltfData);\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      // TODO - Remove fallback accessors to make sure we don't load unnecessary buffers\n    }\n  }\n}\n\nexport async function decode(\n  gltfData: {json: GLTF},\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  if (!options?.gltf?.decompressMeshes) {\n    return;\n  }\n\n  const scenegraph = new Scenegraph(gltfData);\n  const promises: Promise<void>[] = [];\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(scenegraph, primitive, options, context));\n    }\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extension\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\n\nexport function encode(gltfData, options: GLTFLoaderOptions = {}): void {\n  const scenegraph = new Scenegraph(gltfData);\n\n  for (const mesh of scenegraph.json.meshes || []) {\n    // eslint-disable-next-line camelcase\n    // @ts-ignore\n    compressMesh(mesh, options);\n    // NOTE: Only add the extension if something was actually compressed\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n\n// DECODE\n\n// Unpacks one mesh primitive and removes the extension from the primitive\n// DracoDecoder needs to be imported and registered by app\n// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete\n\n// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\n\nasync function decompressPrimitive(\n  scenegraph: Scenegraph,\n  primitive: GLTFMeshPrimitive,\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n): Promise<void> {\n  const dracoExtension = scenegraph.getObjectExtension<GLTF_KHR_draco_mesh_compression>(\n    primitive,\n    KHR_DRACO_MESH_COMPRESSION\n  );\n  if (!dracoExtension) {\n    return;\n  }\n\n  const buffer = scenegraph.getTypedArrayForBufferView(dracoExtension.bufferView);\n  // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer\n  // TODO - remove when `parse` is fixed to handle `byteOffset`s\n  const bufferCopy = sliceArrayBuffer(buffer.buffer, buffer.byteOffset); // , buffer.byteLength);\n\n  const {parse} = context;\n  const dracoOptions: DracoLoaderOptions = {...options};\n\n  // TODO - remove hack: The entire tileset might be included, too expensive to serialize\n  delete dracoOptions['3d-tiles'];\n  const decodedData = (await parse(bufferCopy, DracoLoader, dracoOptions, context)) as DracoMesh;\n\n  const decodedAttributes: {[key: string]: GLTFAccessor} = getGLTFAccessors(decodedData.attributes);\n\n  // Restore min/max values\n  for (const [attributeName, decodedAttribute] of Object.entries(decodedAttributes)) {\n    if (attributeName in primitive.attributes) {\n      const accessorIndex: number = primitive.attributes[attributeName];\n      const accessor = scenegraph.getAccessor(accessorIndex);\n      if (accessor?.min && accessor?.max) {\n        decodedAttribute.min = accessor.min;\n        decodedAttribute.max = accessor.max;\n      }\n    }\n  }\n\n  // @ts-ignore\n  primitive.attributes = decodedAttributes;\n  if (decodedData.indices) {\n    // @ts-ignore\n    primitive.indices = getGLTFAccessor(decodedData.indices);\n  }\n\n  // Extension has been processed, delete it\n  // delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n  checkPrimitive(primitive);\n}\n\n// ENCODE\n\n// eslint-disable-next-line max-len\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\nfunction compressMesh(attributes, indices, mode: number = 4, options, context: LoaderContext) {\n  if (!options.DracoWriter) {\n    throw new Error('options.gltf.DracoWriter not provided');\n  }\n\n  // TODO - use DracoWriter using encode w/ registered DracoWriter...\n  const compressedData = options.DracoWriter.encodeSync({attributes});\n\n  // Draco compression may change the order and number of vertices in a mesh.\n  // To satisfy the requirement that accessors properties be correct for both\n  // compressed and uncompressed data, generators should create uncompressed\n  // attributes and indices using data that has been decompressed from the Draco buffer,\n  // rather than the original source data.\n  // @ts-ignore TODO this needs to be fixed\n  const decodedData = context?.parseSync?.({attributes});\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  const bufferViewIndex = options.addBufferView(compressedData);\n\n  const glTFMesh = {\n    primitives: [\n      {\n        attributes: fauxAccessors, // TODO - verify with spec\n        mode, // GL.POINTS\n        extensions: {\n          [KHR_DRACO_MESH_COMPRESSION]: {\n            bufferView: bufferViewIndex,\n            attributes: fauxAccessors // TODO - verify with spec\n          }\n        }\n      }\n    ]\n  };\n\n  return glTFMesh;\n}\n\n// UTILS\n\nfunction checkPrimitive(primitive: GLTFMeshPrimitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('glTF: Empty primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}\n", "export const COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nexport const BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\n// ENUM LOOKUP\n\nexport function getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nexport function getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nexport function getGLEnumFromSamplerParameter(parameter) {\n  const GL_TEXTURE_MAG_FILTER = 0x2800;\n  const GL_TEXTURE_MIN_FILTER = 0x2801;\n  const GL_TEXTURE_WRAP_S = 0x2802;\n  const GL_TEXTURE_WRAP_T = 0x2803;\n\n  const PARAMETER_MAP = {\n    magFilter: GL_TEXTURE_MAG_FILTER,\n    minFilter: GL_TEXTURE_MIN_FILTER,\n    wrapS: GL_TEXTURE_WRAP_S,\n    wrapT: GL_TEXTURE_WRAP_T\n  };\n\n  return PARAMETER_MAP[parameter];\n}\n", "/**\n * https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_texture_transform/README.md\n */\n\nimport {Vector3, Matrix3} from '@math.gl/core';\nimport type {GLTFMeshPrimitive, GLTFWithBuffers} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport {getAccessorArrayTypeAndLength} from '../gltf-utils/gltf-utils';\nimport {BYTES, COMPONENTS} from '../gltf-utils/gltf-constants';\nimport {\n  Accessor,\n  BufferView,\n  MaterialNormalTextureInfo,\n  MaterialOcclusionTextureInfo,\n  TextureInfo as GLTFTextureInfo\n} from '../types/gltf-json-schema';\nimport GLTFScenegraph from '../api/gltf-scenegraph';\n\n/** Extension name */\nconst EXT_MESHOPT_TRANSFORM = 'KHR_texture_transform';\n\nexport const name = EXT_MESHOPT_TRANSFORM;\n\nconst scratchVector = new Vector3();\nconst scratchRotationMatrix = new Matrix3();\nconst scratchScaleMatrix = new Matrix3();\n\n/** Extension textureInfo https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates */\ntype TextureInfo = {\n  /** The offset of the UV coordinate origin as a factor of the texture dimensions. */\n  offset?: [number, number];\n  /** Rotate the UVs by this many radians counter-clockwise around the origin. This is equivalent to a similar rotation of the image clockwise. */\n  rotation?: number;\n  /** The scale factor applied to the components of the UV coordinates. */\n  scale?: [number, number];\n  /** Overrides the textureInfo texCoord value if supplied, and if this extension is supported. */\n  texCoord?: number;\n};\n/** Intersection of all GLTF textures */\ntype CompoundGLTFTextureInfo = GLTFTextureInfo &\n  MaterialNormalTextureInfo &\n  MaterialOcclusionTextureInfo;\n/** Parameters for TEXCOORD transformation */\ntype TransformParameters = {\n  /** Original texCoord value https://www.khronos.org/registry/glTF/specs/2.0/glTF-2.0.html#_textureinfo_texcoord */\n  originalTexCoord: number;\n  /** New texCoord value from extension https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates */\n  texCoord: number;\n  /** Transformation matrix */\n  matrix: Matrix3;\n};\n\n/**\n * The extension entry to process the transformation\n * @param gltfData gltf buffers and json\n * @param options GLTFLoader options\n */\nexport async function decode(gltfData: GLTFWithBuffers, options: GLTFLoaderOptions) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const extension = gltfScenegraph.getExtension(EXT_MESHOPT_TRANSFORM);\n  if (!extension) {\n    return;\n  }\n  const materials = gltfData.json.materials || [];\n  for (let i = 0; i < materials.length; i++) {\n    transformTexCoords(i, gltfData);\n  }\n}\n\n/**\n * Transform TEXCOORD by material\n * @param materialIndex processing material index\n * @param gltfData gltf buffers and json\n */\nfunction transformTexCoords(materialIndex: number, gltfData: GLTFWithBuffers): void {\n  // Save processed texCoords in order no to process the same twice\n  const processedTexCoords: [number, number][] = [];\n  const material = gltfData.json.materials?.[materialIndex];\n  const baseColorTexture = material?.pbrMetallicRoughness?.baseColorTexture;\n  if (baseColorTexture) {\n    transformPrimitives(gltfData, materialIndex, baseColorTexture, processedTexCoords);\n  }\n  const emisiveTexture = material?.emissiveTexture;\n  if (emisiveTexture) {\n    transformPrimitives(gltfData, materialIndex, emisiveTexture, processedTexCoords);\n  }\n  const normalTexture = material?.normalTexture;\n  if (normalTexture) {\n    transformPrimitives(gltfData, materialIndex, normalTexture, processedTexCoords);\n  }\n  const occlusionTexture = material?.occlusionTexture;\n  if (occlusionTexture) {\n    transformPrimitives(gltfData, materialIndex, occlusionTexture, processedTexCoords);\n  }\n  const metallicRoughnessTexture = material?.pbrMetallicRoughness?.metallicRoughnessTexture;\n  if (metallicRoughnessTexture) {\n    transformPrimitives(gltfData, materialIndex, metallicRoughnessTexture, processedTexCoords);\n  }\n}\n\n/**\n * Transform primitives of the particular material\n * @param gltfData gltf data\n * @param materialIndex primitives with this material will be transformed\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n */\nfunction transformPrimitives(\n  gltfData: GLTFWithBuffers,\n  materialIndex: number,\n  texture: CompoundGLTFTextureInfo,\n  processedTexCoords: [number, number][]\n) {\n  const transformParameters = getTransformParameters(texture, processedTexCoords);\n  if (!transformParameters) {\n    return;\n  }\n  const meshes = gltfData.json.meshes || [];\n  for (const mesh of meshes) {\n    for (const primitive of mesh.primitives) {\n      const material = primitive.material;\n      if (Number.isFinite(material) && materialIndex === material) {\n        transformPrimitive(gltfData, primitive, transformParameters);\n      }\n    }\n  }\n}\n\n/**\n * Get parameters for TEXCOORD transformation\n * @param texture texture object\n * @param processedTexCoords storage to save already processed texCoords\n * @returns texCoord couple and transformation matrix\n */\nfunction getTransformParameters(\n  texture: CompoundGLTFTextureInfo,\n  processedTexCoords: [number, number][]\n): TransformParameters | null {\n  const textureInfo = texture.extensions?.[EXT_MESHOPT_TRANSFORM];\n  const {texCoord: originalTexCoord = 0} = texture;\n  // If texCoord is not set in the extension, original attribute data will be replaced\n  const {texCoord = originalTexCoord} = textureInfo;\n  // Make sure that couple [originalTexCoord, extensionTexCoord] is not processed twice\n  const isProcessed =\n    processedTexCoords.findIndex(\n      ([original, newTexCoord]) => original === originalTexCoord && newTexCoord === texCoord\n    ) !== -1;\n  if (!isProcessed) {\n    const matrix = makeTransformationMatrix(textureInfo);\n    if (originalTexCoord !== texCoord) {\n      texture.texCoord = texCoord;\n    }\n    processedTexCoords.push([originalTexCoord, texCoord]);\n    return {originalTexCoord, texCoord, matrix};\n  }\n  return null;\n}\n\n/**\n * Transform `TEXCOORD_0` attribute in the primitive\n * @param gltfData gltf data\n * @param primitive primitive object\n * @param transformParameters texCoord couple and transformation matrix\n */\nfunction transformPrimitive(\n  gltfData: GLTFWithBuffers,\n  primitive: GLTFMeshPrimitive,\n  transformParameters: TransformParameters\n) {\n  const {originalTexCoord, texCoord, matrix} = transformParameters;\n  const texCoordAccessor = primitive.attributes[`TEXCOORD_${originalTexCoord}`];\n  if (Number.isFinite(texCoordAccessor)) {\n    // Get accessor of the `TEXCOORD_0` attribute\n    const accessor = gltfData.json.accessors?.[texCoordAccessor];\n    if (accessor && accessor.bufferView) {\n      // Get `bufferView` of the `accessor`\n      const bufferView = gltfData.json.bufferViews?.[accessor.bufferView];\n      if (bufferView) {\n        // Get `arrayBuffer` the `bufferView` look at\n        const {arrayBuffer, byteOffset: bufferByteOffset} = gltfData.buffers[bufferView.buffer];\n        // Resulting byteOffset is sum of the buffer, accessor and bufferView byte offsets\n        const byteOffset =\n          (bufferByteOffset || 0) + (accessor.byteOffset || 0) + (bufferView.byteOffset || 0);\n        // Deduce TypedArray type and its length from `accessor` and `bufferView` data\n        const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);\n        // Number of bytes each component occupies\n        const bytes = BYTES[accessor.componentType];\n        // Number of components. For the `TEXCOORD_0` with `VEC2` type, it must return 2\n        const components = COMPONENTS[accessor.type];\n        // Multiplier to calculate the address of the `TEXCOORD_0` element in the arrayBuffer\n        const elementAddressScale = bufferView.byteStride || bytes * components;\n        // Data transform to Float32Array\n        const result = new Float32Array(length);\n        for (let i = 0; i < accessor.count; i++) {\n          // Take [u, v] couple from the arrayBuffer\n          const uv = new ArrayType(arrayBuffer, byteOffset + i * elementAddressScale, 2);\n          // Set and transform Vector3 per https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#overview\n          scratchVector.set(uv[0], uv[1], 1);\n          scratchVector.transformByMatrix3(matrix);\n          // Save result in Float32Array\n          result.set([scratchVector[0], scratchVector[1]], i * components);\n        }\n        // If texCoord the same, replace gltf structural data\n        if (originalTexCoord === texCoord) {\n          updateGltf(accessor, bufferView, gltfData.buffers, result);\n        } else {\n          // If texCoord change, create new attribute\n          createAttribute(texCoord, accessor, primitive, gltfData, result);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Update GLTF structural objects with new data as we create new `Float32Array` for `TEXCOORD_0`.\n * @param accessor accessor to change\n * @param bufferView bufferView to change\n * @param buffers binary buffers\n * @param newTexcoordArray typed array with data after transformation\n */\nfunction updateGltf(\n  accessor: Accessor,\n  bufferView: BufferView,\n  buffers: {arrayBuffer: ArrayBuffer; byteOffset: number; byteLength: number}[],\n  newTexCoordArray: Float32Array\n): void {\n  accessor.componentType = 5126;\n  buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  bufferView.buffer = buffers.length - 1;\n  bufferView.byteLength = newTexCoordArray.buffer.byteLength;\n  bufferView.byteOffset = 0;\n  delete bufferView.byteStride;\n}\n\n/**\n *\n * @param newTexCoord new `texCoord` value\n * @param originalAccessor original accessor object, that store data before transformation\n * @param primitive primitive object\n * @param gltfData gltf data\n * @param newTexCoordArray typed array with data after transformation\n * @returns\n */\nfunction createAttribute(\n  newTexCoord: number,\n  originalAccessor: Accessor,\n  primitive: GLTFMeshPrimitive,\n  gltfData: GLTFWithBuffers,\n  newTexCoordArray: Float32Array\n) {\n  gltfData.buffers.push({\n    arrayBuffer: newTexCoordArray.buffer,\n    byteOffset: 0,\n    byteLength: newTexCoordArray.buffer.byteLength\n  });\n  const bufferViews = gltfData.json.bufferViews;\n  if (!bufferViews) {\n    return;\n  }\n  bufferViews.push({\n    buffer: gltfData.buffers.length - 1,\n    byteLength: newTexCoordArray.buffer.byteLength,\n    byteOffset: 0\n  });\n  const accessors = gltfData.json.accessors;\n  if (!accessors) {\n    return;\n  }\n  accessors.push({\n    bufferView: bufferViews?.length - 1,\n    byteOffset: 0,\n    componentType: 5126,\n    count: originalAccessor.count,\n    type: 'VEC2'\n  });\n  primitive.attributes[`TEXCOORD_${newTexCoord}`] = accessors.length - 1;\n}\n\n/**\n * Construct transformation matrix from the extension data (transition, rotation, scale)\n * @param extensionData extension data\n * @returns transformation matrix\n */\nfunction makeTransformationMatrix(extensionData: TextureInfo): Matrix3 {\n  const {offset = [0, 0], rotation = 0, scale = [1, 1]} = extensionData;\n  const translationMatirx = new Matrix3().set(1, 0, 0, 0, 1, 0, offset[0], offset[1], 1);\n  const rotationMatirx = scratchRotationMatrix.set(\n    Math.cos(rotation),\n    Math.sin(rotation),\n    0,\n    -Math.sin(rotation),\n    Math.cos(rotation),\n    0,\n    0,\n    0,\n    1\n  );\n  const scaleMatrix = scratchScaleMatrix.set(scale[0], 0, 0, 0, scale[1], 0, 0, 0, 1);\n  return translationMatirx.multiplyRight(rotationMatirx).multiplyRight(scaleMatrix);\n}\n", "// GLTF EXTENSION: KHR_lights_punctual\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n\nimport type {GLTF} from '../../types/gltf-types';\n\nimport {assert} from '../../utils/assert';\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\n\nconst KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';\n\nexport const name = KHR_LIGHTS_PUNCTUAL;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Move the light array out of the extension and remove the extension\n  const extension = gltfScenegraph.getExtension(KHR_LIGHTS_PUNCTUAL);\n  if (extension) {\n    // @ts-ignore\n    gltfScenegraph.json.lights = extension.lights;\n    gltfScenegraph.removeExtension(KHR_LIGHTS_PUNCTUAL);\n  }\n\n  // Any nodes that have the extension, add lights field pointing to light object\n  // and remove the extension\n  for (const node of json.nodes || []) {\n    const nodeExtension = gltfScenegraph.getObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n    if (nodeExtension) {\n      // @ts-ignore\n      node.light = nodeExtension.light;\n    }\n    gltfScenegraph.removeObjectExtension(node, KHR_LIGHTS_PUNCTUAL);\n  }\n}\n\n// Move the light ar ray out of the extension and remove the extension\nexport async function encode(gltfData): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // @ts-ignore\n  if (json.lights) {\n    const extension = gltfScenegraph.addExtension(KHR_LIGHTS_PUNCTUAL);\n    // @ts-ignore\n    assert(!extension.lights);\n    // @ts-ignore\n    extension.lights = json.lights;\n    // @ts-ignore\n    delete json.lights;\n  }\n\n  // Any nodes that have lights field pointing to light object\n  // add the extension\n  // @ts-ignore\n  if (gltfScenegraph.json.lights) {\n    // @ts-ignore\n    for (const light of gltfScenegraph.json.lights) {\n      const node = light.node;\n      gltfScenegraph.addObjectExtension(node, KHR_LIGHTS_PUNCTUAL, light);\n    }\n    // @ts-ignore\n    delete gltfScenegraph.json.lights;\n  }\n}\n", "// GLTF EXTENSION: KHR_materials_unlit\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n\nimport type {GLTF} from '../../types/gltf-types';\n\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\n\nconst KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';\n\nexport const name = KHR_MATERIALS_UNLIT;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Any nodes that have the extension, add lights field pointing to light object\n  // and remove the extension\n  for (const material of json.materials || []) {\n    const extension = material.extensions && material.extensions.KHR_materials_unlit;\n    if (extension) {\n      // @ts-ignore TODO\n      material.unlit = true;\n    }\n    gltfScenegraph.removeObjectExtension(material, KHR_MATERIALS_UNLIT);\n  }\n\n  // Remove the top-level extension\n  gltfScenegraph.removeExtension(KHR_MATERIALS_UNLIT);\n}\n\nexport function encode(gltfData) {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Any nodes that have lights field pointing to light object\n  // add the extension\n  // @ts-ignore\n  if (gltfScenegraph.materials) {\n    for (const material of json.materials || []) {\n      // @ts-ignore\n      if (material.unlit) {\n        // @ts-ignore\n        delete material.unlit;\n        gltfScenegraph.addObjectExtension(material, KHR_MATERIALS_UNLIT, {});\n        gltfScenegraph.addExtension(KHR_MATERIALS_UNLIT);\n      }\n    }\n  }\n}\n", "// GLTF EXTENSION: KHR_techniques_webgl\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl\n\nimport type {GLTF} from '../../types/gltf-types';\n\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\n\nconst KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';\n\nexport const name = KHR_TECHNIQUES_WEBGL;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  const extension = gltfScenegraph.getExtension(KHR_TECHNIQUES_WEBGL);\n  if (extension) {\n    const techniques = resolveTechniques(extension, gltfScenegraph);\n\n    for (const material of json.materials || []) {\n      const materialExtension = gltfScenegraph.getObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n      if (materialExtension) {\n        // @ts-ignore TODO\n        material.technique = Object.assign(\n          {},\n          materialExtension,\n          // @ts-ignore\n          techniques[materialExtension.technique]\n        );\n        // @ts-ignore TODO\n        material.technique.values = resolveValues(material.technique, gltfScenegraph);\n      }\n      gltfScenegraph.removeObjectExtension(material, KHR_TECHNIQUES_WEBGL);\n    }\n\n    // Remove the top-level extension\n    gltfScenegraph.removeExtension(KHR_TECHNIQUES_WEBGL);\n  }\n}\n// eslint-disable-next-line\nexport async function encode(gltfData, options): Promise<void> {\n  // TODO\n}\n\nfunction resolveTechniques(\n  techniquesExtension: {[key: string]: any},\n  // programs: {[key: string]: any}[],\n  // shaders: {[key: string]: any}[],\n  // techniques: {[key: string]: any}[]\n  gltfScenegraph\n) {\n  const {programs = [], shaders = [], techniques = []} = techniquesExtension;\n  const textDecoder = new TextDecoder();\n\n  shaders.forEach((shader) => {\n    if (Number.isFinite(shader.bufferView)) {\n      shader.code = textDecoder.decode(\n        gltfScenegraph.getTypedArrayForBufferView(shader.bufferView)\n      );\n    } else {\n      // TODO: handle URI shader\n      throw new Error('KHR_techniques_webgl: no shader code');\n    }\n  });\n\n  programs.forEach((program) => {\n    program.fragmentShader = shaders[program.fragmentShader];\n    program.vertexShader = shaders[program.vertexShader];\n  });\n\n  techniques.forEach((technique) => {\n    technique.program = programs[technique.program];\n  });\n\n  return techniques;\n}\n\nfunction resolveValues(technique, gltfScenegraph) {\n  const values = Object.assign({}, technique.values);\n\n  // merge values from uniforms\n  Object.keys(technique.uniforms || {}).forEach((uniform) => {\n    if (technique.uniforms[uniform].value && !(uniform in values)) {\n      values[uniform] = technique.uniforms[uniform].value;\n    }\n  });\n\n  // resolve textures\n  Object.keys(values).forEach((uniform) => {\n    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {\n      // Assume this is a texture\n      // TODO: find if there are any other types that can be referenced\n      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);\n    }\n  });\n\n  return values;\n}\n", "/* eslint-disable camelcase */\nimport type {GLTF} from '../../types/gltf-types';\n\nimport GLTFScenegraph from '../../api/gltf-scenegraph';\nimport {\n  ClassProperty,\n  EXT_feature_metadata_class_object,\n  EXT_feature_metadata_feature_table,\n  FeatureTableProperty,\n  GLTF_EXT_feature_metadata\n} from '../../types/gltf-json-schema';\n\n/** Extension name */\nconst EXT_FEATURE_METADATA = 'EXT_feature_metadata';\n\nexport const name = EXT_FEATURE_METADATA;\n\nexport async function decode(gltfData: {json: GLTF}): Promise<void> {\n  const scenegraph = new GLTFScenegraph(gltfData);\n  decodeExtFeatureMetadata(scenegraph);\n}\n\n/**\n * Decodes feature metadata from extension\n * @param scenegraph\n */\nfunction decodeExtFeatureMetadata(scenegraph: GLTFScenegraph): void {\n  const extension: GLTF_EXT_feature_metadata | null = scenegraph.getExtension(EXT_FEATURE_METADATA);\n  const schemaClasses = extension?.schema?.classes;\n  const featureTables = extension?.featureTables;\n  const featureTextures = extension?.featureTextures;\n\n  if (featureTextures) {\n    /*\n     * TODO add support for featureTextures\n     * Spec - https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata#feature-textures\n     */\n    // eslint-disable-next-line no-console\n    console.warn('featureTextures is not yet supported in the \"EXT_feature_metadata\" extension.');\n  }\n\n  if (schemaClasses && featureTables) {\n    for (const schemaName in schemaClasses) {\n      const schemaClass = schemaClasses[schemaName];\n      const featureTable = findFeatureTableByName(featureTables, schemaName);\n\n      if (featureTable) {\n        handleFeatureTableProperties(scenegraph, featureTable, schemaClass);\n      }\n    }\n  }\n}\n\n/**\n * Navigate throw all properies in feature table and gets properties data.\n * @param scenegraph\n * @param featureTable\n * @param schemaClass\n */\nfunction handleFeatureTableProperties(\n  scenegraph: GLTFScenegraph,\n  featureTable: EXT_feature_metadata_feature_table,\n  schemaClass: EXT_feature_metadata_class_object\n): void {\n  for (const propertyName in schemaClass.properties) {\n    const schemaProperty = schemaClass.properties[propertyName];\n    const featureTableProperty = featureTable?.properties?.[propertyName];\n    const numberOfFeatures = featureTable.count;\n\n    if (featureTableProperty) {\n      const data = getPropertyDataFromBinarySource(\n        scenegraph,\n        schemaProperty,\n        numberOfFeatures,\n        featureTableProperty\n      );\n      featureTableProperty.data = data;\n    }\n  }\n}\n\n/**\n * Decode properties from binary sourse based on property type.\n * @param scenegraph\n * @param schemaProperty\n * @param numberOfFeatures\n * @param featureTableProperty\n */\nfunction getPropertyDataFromBinarySource(\n  scenegraph: GLTFScenegraph,\n  schemaProperty: ClassProperty,\n  numberOfFeatures: number,\n  featureTableProperty: FeatureTableProperty\n): Uint8Array | string[] {\n  const bufferView = featureTableProperty.bufferView;\n  // TODO think maybe we shouldn't get data only in Uint8Array format.\n  let data: Uint8Array | string[] = scenegraph.getTypedArrayForBufferView(bufferView);\n\n  switch (schemaProperty.type) {\n    case 'STRING': {\n      // stringOffsetBufferView should be available for string type.\n      const stringOffsetBufferView = featureTableProperty.stringOffsetBufferView!;\n      const offsetsData = scenegraph.getTypedArrayForBufferView(stringOffsetBufferView);\n      data = getStringAttributes(data, offsetsData, numberOfFeatures);\n      break;\n    }\n    default:\n  }\n\n  return data;\n}\n\n/**\n * Find the feature table by class name.\n * @param featureTables\n * @param schemaClassName\n */\nfunction findFeatureTableByName(\n  featureTables: {[key: string]: EXT_feature_metadata_feature_table},\n  schemaClassName: string\n): EXT_feature_metadata_feature_table | null {\n  for (const featureTableName in featureTables) {\n    const featureTable = featureTables[featureTableName];\n\n    if (featureTable.class === schemaClassName) {\n      return featureTable;\n    }\n  }\n\n  return null;\n}\n\n/**\n * Getting string attributes from binary data.\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata#strings\n * @param data\n * @param offsetsData\n * @param stringsCount\n */\nfunction getStringAttributes(\n  data: Uint8Array,\n  offsetsData: Uint8Array,\n  stringsCount: number\n): string[] {\n  const stringsArray: string[] = [];\n  const textDecoder = new TextDecoder('utf8');\n\n  let stringOffset = 0;\n  const bytesPerStringSize = 4;\n\n  for (let index = 0; index < stringsCount; index++) {\n    // TODO check if it is multiplication on bytesPerStringSize is valid operation?\n    const stringByteSize =\n      offsetsData[(index + 1) * bytesPerStringSize] - offsetsData[index * bytesPerStringSize];\n    const stringData = data.subarray(stringOffset, stringByteSize + stringOffset);\n    const stringAttribute = textDecoder.decode(stringData);\n\n    stringsArray.push(stringAttribute);\n    stringOffset += stringByteSize;\n  }\n\n  return stringsArray;\n}\n", "/* eslint-disable camelcase */\nimport {GLTF} from '../types/gltf-types';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\n\n// GLTF 1.0 extensions (decode only)\n// import * as KHR_binary_gltf from './KHR_draco_mesh_compression';\n\n// GLTF 2.0 Khronos extensions (decode/encode)\nimport * as EXT_meshopt_compression from '../extensions/EXT_meshopt_compression';\nimport * as EXT_texture_webp from '../extensions/EXT_texture_webp';\nimport * as KHR_texture_basisu from '../extensions/KHR_texture_basisu';\nimport * as KHR_draco_mesh_compression from '../extensions/KHR_draco_mesh_compression';\nimport * as KHR_texture_transform from '../extensions/KHR_texture_transform';\n\n// Deprecated. These should be handled by rendering library (e.g. luma.gl), not the loader.\nimport * as KHR_lights_punctual from '../extensions/deprecated/KHR_lights_punctual';\nimport * as KHR_materials_unlit from '../extensions/deprecated/KHR_materials_unlit';\nimport * as KHR_techniques_webgl from '../extensions/deprecated/KHR_techniques_webgl';\nimport * as EXT_feature_metadata from '../extensions/deprecated/EXT_feature_metadata';\n\n// Vendor extensions\n\ntype GLTFExtensionPlugin = {\n  name: string;\n  preprocess?: (gltfData: {json: GLTF}, options: GLTFLoaderOptions, context) => void;\n  decode?: (\n    gltfData: {\n      json: GLTF;\n      buffers: {arrayBuffer: ArrayBuffer; byteOffset: number; byteLength: number}[];\n    },\n    options: GLTFLoaderOptions,\n    context\n  ) => Promise<void>;\n  encode?: (gltfData: {json: GLTF}, options: GLTFLoaderOptions) => void;\n};\n\n/**\n * List of extensions processed by the GLTFLoader\n * Note that may extensions can only be handled on the rendering stage and are left out here\n * These are just extensions that can be handled fully or partially during loading.\n */\nexport const EXTENSIONS: GLTFExtensionPlugin[] = [\n  // 1.0\n  // KHR_binary_gltf is handled separately - must be processed before other parsing starts\n  // KHR_binary_gltf,\n\n  // 2.0\n  EXT_meshopt_compression,\n  EXT_texture_webp,\n  // Basisu should come after webp, we want basisu to be preferred if both are provided\n  KHR_texture_basisu,\n  KHR_draco_mesh_compression,\n  KHR_lights_punctual,\n  KHR_materials_unlit,\n  KHR_techniques_webgl,\n  KHR_texture_transform,\n  EXT_feature_metadata\n];\n\n/** Call before any resource loading starts */\nexport function preprocessExtensions(gltf, options: GLTFLoaderOptions = {}, context?) {\n  const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));\n  for (const extension of extensions) {\n    extension.preprocess?.(gltf, options, context);\n  }\n}\n\n/** Call after resource loading */\nexport async function decodeExtensions(gltf, options: GLTFLoaderOptions = {}, context?) {\n  const extensions = EXTENSIONS.filter((extension) => useExtension(extension.name, options));\n  for (const extension of extensions) {\n    // Note: We decode async extensions sequentially, this might not be necessary\n    // Currently we only have Draco, but when we add Basis we may revisit\n    await extension.decode?.(gltf, options, context);\n  }\n}\n\nfunction useExtension(extensionName: string, options: GLTFLoaderOptions) {\n  const excludes = options?.gltf?.excludeExtensions || {};\n  const exclude = extensionName in excludes && !excludes[extensionName];\n  return !exclude;\n}\n", "// GLTF 1.0 EXTENSION: KHR_binary_glTF\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n/* eslint-disable camelcase */\n\nimport type {GLTF, GLTF_KHR_binary_glTF} from '../types/gltf-types';\n\nimport GLTFScenegraph from '../api/gltf-scenegraph';\n\nconst KHR_BINARY_GLTF = 'KHR_binary_glTF';\n\n/** Extension name */\nexport const name = KHR_BINARY_GLTF;\n\nexport function preprocess(gltfData: {json: GLTF}): void {\n  const gltfScenegraph = new GLTFScenegraph(gltfData);\n  const {json} = gltfScenegraph;\n\n  // Note: json.buffers.binary_glTF also needs to be replaced\n  // This is currently done during gltf normalization\n\n  // Image and shader nodes can have the extension\n  // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/image.KHR_binary_glTF.schema.json\n  for (const image of json.images || []) {\n    const extension = gltfScenegraph.getObjectExtension<GLTF_KHR_binary_glTF>(\n      image,\n      KHR_BINARY_GLTF\n    );\n    // The data in the extension is valid as glTF 2.0 data inside the object, so just copy it in\n    if (extension) {\n      Object.assign(image, extension);\n    }\n    gltfScenegraph.removeObjectExtension(image, KHR_BINARY_GLTF);\n  }\n\n  // TODO shaders - At least traverse and throw error if used?\n  // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/shader.KHR_binary_glTF.schema.json\n\n  // glTF v1 one files have a partially formed URI field that is not expected in (and causes problems in) 2.0\n  if (json.buffers && json.buffers[0]) {\n    delete json.buffers[0].uri;\n  }\n\n  // Remove the top-level extension as it has now been processed\n  gltfScenegraph.removeExtension(KHR_BINARY_GLTF);\n}\n\n// KHR_binary_gltf is a 1.0 extension that is supported natively by 2.0\n// export function encode() {\n//   throw new Error(KHR_BINARY_GLTF);\n// }\n", "/* eslint-disable camelcase */\nimport * as KHR_binary_glTF from '../extensions/KHR_binary_gltf';\n\n// Binary format changes (mainly implemented by GLBLoader)\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\n\n// JSON format changes:\n// https://github.com/khronosgroup/gltf/issues/605\n\n// - [x] Top-level JSON objects are arrays now\n// - [ ] Removed indirection from animation: sampler now refers directly to accessors, #712\n// - [ ] material.parameter.value and technique.parameter.value must be an array, #690\n// - [ ] Node can have only one mesh #821\n// - [ ] Added reqs on JSON encoding\n// - [ ] Added reqs on binary data alignment #802 (comment)\n\n// Additions:\n// - [ ] Added accessor.normalized, #691, #706\n// - [ ] Added glExtensionsUsed property and 5125 (UNSIGNED_INT) accessor.componentType value, #619\n// - [ ] Added extensionsRequired property, #720, #721\n// - [ ] Added \"STEP\" as valid animation.sampler.interpolation value, #712\n\n// Removals:\n// - [x] Removed buffer.type, #786, #629\n// - [ ] Removed revision number from profile.version, #709\n// - [ ] Removed technique.functions.scissor and removed 3089 (SCISSOR_TEST) as a valid value for technique.states.enable, #681\n// - [ ] Techniques, programs, and shaders were moved out to KHR_technique_webgl extension.\n\n// Other edits:\n// - [x] asset is now required, #642\n// - [ ] buffer.byteLength and bufferView.byteLength are now required, #560.\n// - [ ] accessor.min and accessor.max are now required, #593, and clarified that the JSON value and binary data must be the same, #628.\n// - [ ] Clarified animation.sampler and animation.channel restrictions, #712\n// - [ ] skin.inverseBindMatrices is now optional, #461.\n// - [ ] Attribute parameters can't have a value defined in the technique or parameter, #563 (comment).\n// - [ ] Only TEXCOORD and COLOR attribute semantics can be written in the form [semantic]_[set_index], #563 (comment).\n// - [ ] TEXCOORD and COLOR attribute semantics must be written in the form [semantic]_[set_index], e.g., just TEXCOORD should be TEXCOORD_0, and just COLOR should be COLOR_0, #649\n// - [ ] camera.perspective.aspectRatio and camera.perspective.yfov must now be > 0, not >= 0, #563 (comment).\n// - [ ] Application-specific parameter semantics must start with an underscore, e.g., _TEMPERATURE and _SIMULATION_TIME, #563 (comment).\n// - [ ] Properties in technique.parameters must be defined in technique.uniforms or technique.attributes,\n\n// #563 (comment).\n// - [ ] technique.parameter.count can only be defined when the semantic is JOINTMATRIX or an application-specific semantic is used. It can never be defined for attribute parameters; only uniforms, d2f6945\n// - [ ] technique.parameter.semantic is required when the parameter is an attribute, 28e113d\n// - [ ] Mesh-only models are allowed, e.g., without materials, #642\n// - [ ] Skeleton hierarchies (nodes containing jointName) must be separated from non-skeleton hierarchies., #647\n// - [ ] technique.states.functions.blendColor and technique.states.functions.depthRange parameters now must match WebGL function min/max, #707\n\nconst GLTF_ARRAYS = {\n  accessors: 'accessor',\n  animations: 'animation',\n  buffers: 'buffer',\n  bufferViews: 'bufferView',\n  images: 'image',\n  materials: 'material',\n  meshes: 'mesh',\n  nodes: 'node',\n  samplers: 'sampler',\n  scenes: 'scene',\n  skins: 'skin',\n  textures: 'texture'\n};\n\nconst GLTF_KEYS = {\n  accessor: 'accessors',\n  animations: 'animation',\n  buffer: 'buffers',\n  bufferView: 'bufferViews',\n  image: 'images',\n  material: 'materials',\n  mesh: 'meshes',\n  node: 'nodes',\n  sampler: 'samplers',\n  scene: 'scenes',\n  skin: 'skins',\n  texture: 'textures'\n};\n\n/**\n * Converts (normalizes) glTF v1 to v2\n */\nclass GLTFV1Normalizer {\n  idToIndexMap = {\n    animations: {},\n    accessors: {},\n    buffers: {},\n    bufferViews: {},\n    images: {},\n    materials: {},\n    meshes: {},\n    nodes: {},\n    samplers: {},\n    scenes: {},\n    skins: {},\n    textures: {}\n  };\n\n  json;\n\n  // constructor() {}\n\n  /**\n   * Convert (normalize) glTF < 2.0 to glTF 2.0\n   * @param gltf - object with json and binChunks\n   * @param options\n   * @param options normalize Whether to actually normalize\n   */\n  normalize(gltf, options) {\n    this.json = gltf.json;\n    const json = gltf.json;\n\n    // Check version\n    switch (json.asset && json.asset.version) {\n      // We are converting to v2 format. Return if there is nothing to do\n      case '2.0':\n        return;\n\n      // This class is written to convert 1.0\n      case undefined:\n      case '1.0':\n        break;\n\n      default:\n        // eslint-disable-next-line no-undef, no-console\n        console.warn(`glTF: Unknown version ${json.asset.version}`);\n        return;\n    }\n\n    if (!options.normalize) {\n      // We are still missing a few conversion tricks, remove once addressed\n      throw new Error('glTF v1 is not supported.');\n    }\n\n    // eslint-disable-next-line no-undef, no-console\n    console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');\n\n    this._addAsset(json);\n\n    // In glTF2 top-level fields are Arrays not Object maps\n    this._convertTopLevelObjectsToArrays(json);\n\n    // Extract bufferView indices for images\n    // (this extension needs to be invoked early in the normalization process)\n    // TODO can this be handled by standard extension processing instead of called explicitly?\n    KHR_binary_glTF.preprocess(gltf);\n\n    // Convert object references from ids to indices\n    this._convertObjectIdsToArrayIndices(json);\n\n    this._updateObjects(json);\n\n    this._updateMaterial(json);\n  }\n\n  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639\n  _addAsset(json) {\n    json.asset = json.asset || {};\n    // We are normalizing to glTF v2, so change version to \"2.0\"\n    json.asset.version = '2.0';\n    json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';\n  }\n\n  _convertTopLevelObjectsToArrays(json) {\n    // TODO check that all arrays are covered\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertTopLevelObjectToArray(json, arrayName);\n    }\n  }\n\n  /** Convert one top level object to array */\n  _convertTopLevelObjectToArray(json, mapName) {\n    const objectMap = json[mapName];\n    if (!objectMap || Array.isArray(objectMap)) {\n      return;\n    }\n\n    // Rewrite the top-level field as an array\n    json[mapName] = [];\n    // Copy the map key into object.id\n    for (const id in objectMap) {\n      const object = objectMap[id];\n      object.id = object.id || id; // Mutates the loaded object\n      const index = json[mapName].length;\n      json[mapName].push(object);\n      this.idToIndexMap[mapName][id] = index;\n    }\n  }\n\n  /** Go through all objects in all top-level arrays and replace ids with indices */\n  _convertObjectIdsToArrayIndices(json) {\n    for (const arrayName in GLTF_ARRAYS) {\n      this._convertIdsToIndices(json, arrayName);\n    }\n    if ('scene' in json) {\n      json.scene = this._convertIdToIndex(json.scene, 'scene');\n    }\n\n    // Convert any index references that are not using array names\n\n    // texture.source (image)\n    for (const texture of json.textures) {\n      this._convertTextureIds(texture);\n    }\n    for (const mesh of json.meshes) {\n      this._convertMeshIds(mesh);\n    }\n    for (const node of json.nodes) {\n      this._convertNodeIds(node);\n    }\n    for (const node of json.scenes) {\n      this._convertSceneIds(node);\n    }\n  }\n\n  _convertTextureIds(texture) {\n    if (texture.source) {\n      texture.source = this._convertIdToIndex(texture.source, 'image');\n    }\n  }\n\n  _convertMeshIds(mesh) {\n    for (const primitive of mesh.primitives) {\n      const {attributes, indices, material} = primitive;\n      for (const attributeName in attributes) {\n        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');\n      }\n      if (indices) {\n        primitive.indices = this._convertIdToIndex(indices, 'accessor');\n      }\n      if (material) {\n        primitive.material = this._convertIdToIndex(material, 'material');\n      }\n    }\n  }\n\n  _convertNodeIds(node) {\n    if (node.children) {\n      node.children = node.children.map((child) => this._convertIdToIndex(child, 'node'));\n    }\n    if (node.meshes) {\n      node.meshes = node.meshes.map((mesh) => this._convertIdToIndex(mesh, 'mesh'));\n    }\n  }\n\n  _convertSceneIds(scene) {\n    if (scene.nodes) {\n      scene.nodes = scene.nodes.map((node) => this._convertIdToIndex(node, 'node'));\n    }\n  }\n\n  /** Go through all objects in a top-level array and replace ids with indices */\n  _convertIdsToIndices(json, topLevelArrayName) {\n    if (!json[topLevelArrayName]) {\n      console.warn(`gltf v1: json doesn't contain attribute ${topLevelArrayName}`); // eslint-disable-line no-console, no-undef\n      json[topLevelArrayName] = [];\n    }\n    for (const object of json[topLevelArrayName]) {\n      for (const key in object) {\n        const id = object[key];\n        const index = this._convertIdToIndex(id, key);\n        object[key] = index;\n      }\n    }\n  }\n\n  _convertIdToIndex(id, key) {\n    const arrayName = GLTF_KEYS[key];\n    if (arrayName in this.idToIndexMap) {\n      const index = this.idToIndexMap[arrayName][id];\n      if (!Number.isFinite(index)) {\n        throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);\n      }\n      return index;\n    }\n    return id;\n  }\n\n  /**\n   *\n   * @param {*} json\n   */\n  _updateObjects(json) {\n    for (const buffer of this.json.buffers) {\n      // - [x] Removed buffer.type, #786, #629\n      delete buffer.type;\n    }\n  }\n\n  /**\n   * Update material (set pbrMetallicRoughness)\n   * @param {*} json\n   */\n  _updateMaterial(json) {\n    for (const material of json.materials) {\n      material.pbrMetallicRoughness = {\n        baseColorFactor: [1, 1, 1, 1],\n        metallicFactor: 1,\n        roughnessFactor: 1\n      };\n\n      const textureId =\n        material.values?.tex || material.values?.texture2d_0 || material.values?.diffuseTex;\n      const textureIndex = json.textures.findIndex((texture) => texture.id === textureId);\n      if (textureIndex !== -1) {\n        material.pbrMetallicRoughness.baseColorTexture = {index: textureIndex};\n      }\n    }\n  }\n}\n\nexport function normalizeGLTFV1(gltf, options = {}) {\n  return new GLTFV1Normalizer().normalize(gltf, options);\n}\n", "import {assert} from '../utils/assert';\nimport {getAccessorArrayTypeAndLength} from '../gltf-utils/gltf-utils';\nimport {BufferView} from '../types/gltf-json-schema';\nimport {BufferView as BufferViewPostprocessed} from '../types/gltf-postprocessed-schema';\n\n// This is a post processor for loaded glTF files\n// The goal is to make the loaded data easier to use in WebGL applications\n//\n// Functions:\n// * Resolve indexed arrays structure of glTF into a linked tree.\n// * Translate stringified enum keys and values into WebGL constants.\n// * Load images (optional)\n\n// ENUM LOOKUP\n\nconst COMPONENTS = {\n  SCALAR: 1,\n  VEC2: 2,\n  VEC3: 3,\n  VEC4: 4,\n  MAT2: 4,\n  MAT3: 9,\n  MAT4: 16\n};\n\nconst BYTES = {\n  5120: 1, // BYTE\n  5121: 1, // UNSIGNED_BYTE\n  5122: 2, // SHORT\n  5123: 2, // UNSIGNED_SHORT\n  5125: 4, // UNSIGNED_INT\n  5126: 4 // FLOAT\n};\n\nconst GL_SAMPLER = {\n  // Sampler parameters\n  TEXTURE_MAG_FILTER: 0x2800,\n  TEXTURE_MIN_FILTER: 0x2801,\n  TEXTURE_WRAP_S: 0x2802,\n  TEXTURE_WRAP_T: 0x2803,\n\n  // Sampler default values\n  REPEAT: 0x2901,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_LINEAR: 0x2702\n};\n\nconst SAMPLER_PARAMETER_GLTF_TO_GL = {\n  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,\n  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,\n  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,\n  wrapT: GL_SAMPLER.TEXTURE_WRAP_T\n};\n\n// When undefined, a sampler with repeat wrapping and auto filtering should be used.\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture\nconst DEFAULT_SAMPLER = {\n  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,\n  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,\n  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,\n  [GL_SAMPLER.TEXTURE_WRAP_T]: GL_SAMPLER.REPEAT\n};\n\nfunction getBytesFromComponentType(componentType) {\n  return BYTES[componentType];\n}\n\nfunction getSizeFromAccessorType(type) {\n  return COMPONENTS[type];\n}\n\nclass GLTFPostProcessor {\n  baseUri: string = '';\n  json: Record<string, any> = {};\n  buffers: [] = [];\n  images: [] = [];\n\n  postProcess(gltf, options = {}) {\n    const {json, buffers = [], images = [], baseUri = ''} = gltf;\n    assert(json);\n\n    this.baseUri = baseUri;\n    this.json = json;\n    this.buffers = buffers;\n    this.images = images;\n\n    this._resolveTree(this.json, options);\n\n    return this.json;\n  }\n\n  // Convert indexed glTF structure into tree structure\n  // cross-link index resolution, enum lookup, convenience calculations\n  // eslint-disable-next-line complexity\n  _resolveTree(json, options = {}) {\n    if (json.bufferViews) {\n      json.bufferViews = json.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));\n    }\n    if (json.images) {\n      json.images = json.images.map((image, i) => this._resolveImage(image, i));\n    }\n    if (json.samplers) {\n      json.samplers = json.samplers.map((sampler, i) => this._resolveSampler(sampler, i));\n    }\n    if (json.textures) {\n      json.textures = json.textures.map((texture, i) => this._resolveTexture(texture, i));\n    }\n    if (json.accessors) {\n      json.accessors = json.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));\n    }\n    if (json.materials) {\n      json.materials = json.materials.map((material, i) => this._resolveMaterial(material, i));\n    }\n    if (json.meshes) {\n      json.meshes = json.meshes.map((mesh, i) => this._resolveMesh(mesh, i));\n    }\n    if (json.nodes) {\n      json.nodes = json.nodes.map((node, i) => this._resolveNode(node, i));\n    }\n    if (json.skins) {\n      json.skins = json.skins.map((skin, i) => this._resolveSkin(skin, i));\n    }\n    if (json.scenes) {\n      json.scenes = json.scenes.map((scene, i) => this._resolveScene(scene, i));\n    }\n    if (json.scene !== undefined) {\n      json.scene = json.scenes[this.json.scene];\n    }\n  }\n\n  getScene(index) {\n    return this._get('scenes', index);\n  }\n\n  getNode(index) {\n    return this._get('nodes', index);\n  }\n\n  getSkin(index) {\n    return this._get('skins', index);\n  }\n\n  getMesh(index) {\n    return this._get('meshes', index);\n  }\n\n  getMaterial(index) {\n    return this._get('materials', index);\n  }\n\n  getAccessor(index) {\n    return this._get('accessors', index);\n  }\n\n  getCamera(index) {\n    return null; // TODO: fix this\n  }\n\n  getTexture(index) {\n    return this._get('textures', index);\n  }\n\n  getSampler(index) {\n    return this._get('samplers', index);\n  }\n\n  getImage(index) {\n    return this._get('images', index);\n  }\n\n  getBufferView(index) {\n    return this._get('bufferViews', index);\n  }\n\n  getBuffer(index) {\n    return this._get('buffers', index);\n  }\n\n  _get(array, index) {\n    // check if already resolved\n    if (typeof index === 'object') {\n      return index;\n    }\n    const object = this.json[array] && this.json[array][index];\n    if (!object) {\n      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line\n    }\n    return object;\n  }\n\n  // PARSING HELPERS\n\n  _resolveScene(scene, index) {\n    // scene = {...scene};\n    scene.id = scene.id || `scene-${index}`;\n    scene.nodes = (scene.nodes || []).map((node) => this.getNode(node));\n    return scene;\n  }\n\n  _resolveNode(node, index) {\n    // node = {...node};\n    node.id = node.id || `node-${index}`;\n    if (node.children) {\n      node.children = node.children.map((child) => this.getNode(child));\n    }\n    if (node.mesh !== undefined) {\n      node.mesh = this.getMesh(node.mesh);\n    } else if (node.meshes !== undefined && node.meshes.length) {\n      node.mesh = node.meshes.reduce(\n        (accum, meshIndex) => {\n          const mesh = this.getMesh(meshIndex);\n          accum.id = mesh.id;\n          accum.primitives = accum.primitives.concat(mesh.primitives);\n          return accum;\n        },\n        {primitives: []}\n      );\n    }\n    if (node.camera !== undefined) {\n      node.camera = this.getCamera(node.camera);\n    }\n    if (node.skin !== undefined) {\n      node.skin = this.getSkin(node.skin);\n    }\n    return node;\n  }\n\n  _resolveSkin(skin, index) {\n    // skin = {...skin};\n    skin.id = skin.id || `skin-${index}`;\n    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);\n    return skin;\n  }\n\n  _resolveMesh(mesh, index) {\n    // mesh = {...mesh};\n    mesh.id = mesh.id || `mesh-${index}`;\n    if (mesh.primitives) {\n      mesh.primitives = mesh.primitives.map((primitive) => {\n        primitive = {...primitive};\n        const attributes = primitive.attributes;\n        primitive.attributes = {};\n        for (const attribute in attributes) {\n          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);\n        }\n        if (primitive.indices !== undefined) {\n          primitive.indices = this.getAccessor(primitive.indices);\n        }\n        if (primitive.material !== undefined) {\n          primitive.material = this.getMaterial(primitive.material);\n        }\n        return primitive;\n      });\n    }\n    return mesh;\n  }\n\n  _resolveMaterial(material, index) {\n    // material = {...material};\n    material.id = material.id || `material-${index}`;\n    if (material.normalTexture) {\n      material.normalTexture = {...material.normalTexture};\n      material.normalTexture.texture = this.getTexture(material.normalTexture.index);\n    }\n    if (material.occlusionTexture) {\n      material.occlustionTexture = {...material.occlustionTexture};\n      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);\n    }\n    if (material.emissiveTexture) {\n      material.emmisiveTexture = {...material.emmisiveTexture};\n      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);\n    }\n    if (!material.emissiveFactor) {\n      material.emissiveFactor = material.emmisiveTexture ? [1, 1, 1] : [0, 0, 0];\n    }\n\n    if (material.pbrMetallicRoughness) {\n      material.pbrMetallicRoughness = {...material.pbrMetallicRoughness};\n      const mr = material.pbrMetallicRoughness;\n      if (mr.baseColorTexture) {\n        mr.baseColorTexture = {...mr.baseColorTexture};\n        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);\n      }\n      if (mr.metallicRoughnessTexture) {\n        mr.metallicRoughnessTexture = {...mr.metallicRoughnessTexture};\n        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);\n      }\n    }\n    return material;\n  }\n\n  _resolveAccessor(accessor, index) {\n    // accessor = {...accessor};\n    accessor.id = accessor.id || `accessor-${index}`;\n    if (accessor.bufferView !== undefined) {\n      // Draco encoded meshes don't have bufferView\n      accessor.bufferView = this.getBufferView(accessor.bufferView);\n    }\n\n    // Look up enums\n    accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);\n    accessor.components = getSizeFromAccessorType(accessor.type);\n    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;\n\n    // Create TypedArray for the accessor\n    // Note: The canonical way to instantiate is to ignore this array and create\n    // WebGLBuffer's using the bufferViews.\n    if (accessor.bufferView) {\n      const buffer = accessor.bufferView.buffer;\n      const {ArrayType, byteLength} = getAccessorArrayTypeAndLength(accessor, accessor.bufferView);\n      const byteOffset =\n        (accessor.bufferView.byteOffset || 0) + (accessor.byteOffset || 0) + buffer.byteOffset;\n      let cutBuffer = buffer.arrayBuffer.slice(byteOffset, byteOffset + byteLength);\n      if (accessor.bufferView.byteStride) {\n        cutBuffer = this._getValueFromInterleavedBuffer(\n          buffer,\n          byteOffset,\n          accessor.bufferView.byteStride,\n          accessor.bytesPerElement,\n          accessor.count\n        );\n      }\n      accessor.value = new ArrayType(cutBuffer);\n    }\n\n    return accessor;\n  }\n\n  /**\n   * Take values of particular accessor from interleaved buffer\n   * various parts of the buffer\n   * @param buffer\n   * @param byteOffset\n   * @param byteStride\n   * @param bytesPerElement\n   * @param count\n   * @returns\n   */\n  _getValueFromInterleavedBuffer(buffer, byteOffset, byteStride, bytesPerElement, count) {\n    const result = new Uint8Array(count * bytesPerElement);\n    for (let i = 0; i < count; i++) {\n      const elementOffset = byteOffset + i * byteStride;\n      result.set(\n        new Uint8Array(buffer.arrayBuffer.slice(elementOffset, elementOffset + bytesPerElement)),\n        i * bytesPerElement\n      );\n    }\n    return result.buffer;\n  }\n\n  _resolveTexture(texture, index) {\n    // texture = {...texture};\n    texture.id = texture.id || `texture-${index}`;\n    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;\n    texture.source = this.getImage(texture.source);\n    return texture;\n  }\n\n  _resolveSampler(sampler, index) {\n    // sampler = {...sampler};\n    sampler.id = sampler.id || `sampler-${index}`;\n    // Map textual parameters to GL parameter values\n    sampler.parameters = {};\n    for (const key in sampler) {\n      const glEnum = this._enumSamplerParameter(key);\n      if (glEnum !== undefined) {\n        sampler.parameters[glEnum] = sampler[key];\n      }\n    }\n    return sampler;\n  }\n\n  _enumSamplerParameter(key) {\n    return SAMPLER_PARAMETER_GLTF_TO_GL[key];\n  }\n\n  _resolveImage(image, index) {\n    // image = {...image};\n    image.id = image.id || `image-${index}`;\n    if (image.bufferView !== undefined) {\n      image.bufferView = this.getBufferView(image.bufferView);\n    }\n\n    // Check if image has been preloaded by the GLTFLoader\n    // If so, link it into the JSON and drop the URI\n    const preloadedImage = this.images[index];\n    if (preloadedImage) {\n      image.image = preloadedImage;\n    }\n\n    return image;\n  }\n\n  _resolveBufferView(bufferView: BufferView, index: number): BufferViewPostprocessed {\n    // bufferView = {...bufferView};\n    const bufferIndex = bufferView.buffer;\n    const result: BufferViewPostprocessed = {\n      id: `bufferView-${index}`,\n      ...bufferView,\n      buffer: this.buffers[bufferIndex]\n    };\n\n    // @ts-expect-error\n    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;\n    // @ts-expect-error\n    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;\n\n    if ('byteOffset' in bufferView) {\n      byteOffset += bufferView.byteOffset;\n    }\n\n    result.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);\n    return result;\n  }\n\n  _resolveCamera(camera, index) {\n    camera.id = camera.id || `camera-${index}`;\n    // TODO - create 4x4 matrices\n    if (camera.perspective) {\n      // camera.matrix = createPerspectiveMatrix(camera.perspective);\n    }\n    if (camera.orthographic) {\n      // camera.matrix = createOrthographicMatrix(camera.orthographic);\n    }\n    return camera;\n  }\n}\n\nexport function postProcessGLTF(gltf, options?) {\n  return new GLTFPostProcessor().postProcess(gltf, options);\n}\n", "/* eslint-disable camelcase, max-statements */\n// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification\n// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF\nimport type {GLB} from '../types/glb-types';\nimport {padToNBytes, assert} from '@loaders.gl/loader-utils';\n\nexport type GLBParseOptions = {\n  magic?: number;\n  strict?: boolean;\n};\n\nconst MAGIC_glTF = 0x676c5446; // glTF in Big-Endian ASCII\n\nconst GLB_FILE_HEADER_SIZE = 12;\nconst GLB_CHUNK_HEADER_SIZE = 8;\n\nconst GLB_CHUNK_TYPE_JSON = 0x4e4f534a;\nconst GLB_CHUNK_TYPE_BIN = 0x004e4942;\nconst GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0; // DEPRECATED - Backward compatibility for old xviz files\nconst GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1; // DEPRECATED - Backward compatibility for old xviz files\n\nconst GLB_V1_CONTENT_FORMAT_JSON = 0x0;\n\nconst LE = true; // Binary GLTF is little endian.\n\nfunction getMagicString(dataView, byteOffset = 0) {\n  return `\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\\\n${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;\n}\n\n// Check if a data view is a GLB\nexport function isGLB(\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number = 0,\n  options: GLBParseOptions = {}\n): boolean {\n  const dataView = new DataView(arrayBuffer);\n  // Check that GLB Header starts with the magic number\n  const {magic = MAGIC_glTF} = options;\n  const magic1 = dataView.getUint32(byteOffset, false);\n  return magic1 === magic || magic1 === MAGIC_glTF;\n}\n\nexport default function parseGLBSync(\n  glb: GLB,\n  arrayBuffer: ArrayBuffer,\n  byteOffset: number = 0,\n  options: GLBParseOptions = {}\n) {\n  // Check that GLB Header starts with the magic number\n  const dataView = new DataView(arrayBuffer);\n\n  // Compare format with GLBLoader documentation\n  const type = getMagicString(dataView, byteOffset + 0);\n  const version = dataView.getUint32(byteOffset + 4, LE); // Version 2 of binary glTF container format\n  const byteLength = dataView.getUint32(byteOffset + 8, LE); // Total byte length of binary file\n\n  Object.assign(glb, {\n    // Put less important stuff in a header, to avoid clutter\n    header: {\n      byteOffset, // Byte offset into the initial arrayBuffer\n      byteLength,\n      hasBinChunk: false\n    },\n\n    type,\n    version,\n\n    json: {},\n    binChunks: []\n  } as GLB);\n\n  byteOffset += GLB_FILE_HEADER_SIZE;\n\n  switch (glb.version) {\n    case 1:\n      // eslint-disable-next-line\n      return parseGLBV1(glb, dataView, byteOffset);\n    case 2:\n      // eslint-disable-next-line\n      return parseGLBV2(glb, dataView, byteOffset, (options = {}));\n    default:\n      throw new Error(`Invalid GLB version ${glb.version}. Only supports v1 and v2.`);\n  }\n}\n\nfunction parseGLBV1(glb: GLB, dataView: DataView, byteOffset: number): number {\n  // Sanity: ensure file is big enough to hold at least the headers\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  // Explanation of GLB structure:\n  // https://cloud.githubusercontent.com/assets/3479527/22600725/36b87122-ea55-11e6-9d40-6fd42819fcab.png\n  const contentLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk\n  const contentFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32\n  byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n  // GLB v1 only supports a single chunk type\n  assert(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);\n\n  parseJSONChunk(glb, dataView, byteOffset, contentLength);\n  // No need to call the function padToBytes() from parseJSONChunk()\n  byteOffset += contentLength;\n  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength);\n\n  return byteOffset;\n}\n\nfunction parseGLBV2(\n  glb: GLB,\n  dataView: DataView,\n  byteOffset: number,\n  options: GLBParseOptions\n): number {\n  // Sanity: ensure file is big enough to hold at least the first chunk header\n  assert(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);\n\n  parseGLBChunksSync(glb, dataView, byteOffset, options);\n\n  return byteOffset + glb.header.byteLength;\n}\n\nfunction parseGLBChunksSync(\n  glb: GLB,\n  dataView: DataView,\n  byteOffset: number,\n  options: GLBParseOptions\n) {\n  // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n  // Iterate as long as there is space left for another chunk header\n  while (byteOffset + 8 <= glb.header.byteLength) {\n    const chunkLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk\n    const chunkFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32\n    byteOffset += GLB_CHUNK_HEADER_SIZE;\n\n    // Per spec we must iterate over chunks, ignoring all except JSON and BIN\n    switch (chunkFormat) {\n      case GLB_CHUNK_TYPE_JSON:\n        parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n      case GLB_CHUNK_TYPE_BIN:\n        parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        break;\n\n      // Backward compatibility for very old xviz files\n      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseJSONChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:\n        if (!options.strict) {\n          parseBINChunk(glb, dataView, byteOffset, chunkLength);\n        }\n        break;\n\n      default:\n        // Ignore, per spec\n        // console.warn(`Unknown GLB chunk type`); // eslint-disable-line\n        break;\n    }\n\n    byteOffset += padToNBytes(chunkLength, 4);\n  }\n\n  return byteOffset;\n}\n\n// Parse a GLB JSON chunk\nfunction parseJSONChunk(glb: GLB, dataView: DataView, byteOffset: number, chunkLength: number) {\n  // 1. Create a \"view\" of the binary encoded JSON data inside the GLB\n  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);\n\n  // 2. Decode the JSON binary array into clear text\n  const textDecoder = new TextDecoder('utf8');\n  const jsonText = textDecoder.decode(jsonChunk);\n\n  // 3. Parse the JSON text into a JavaScript data structure\n  glb.json = JSON.parse(jsonText);\n\n  return padToNBytes(chunkLength, 4);\n}\n\n// Parse a GLB BIN chunk\nfunction parseBINChunk(glb: GLB, dataView, byteOffset, chunkLength) {\n  // Note: BIN chunk can be optional\n  glb.header.hasBinChunk = true;\n  glb.binChunks.push({\n    byteOffset,\n    byteLength: chunkLength,\n    arrayBuffer: dataView.buffer\n    // TODO - copy, or create typed array view?\n  });\n\n  return padToNBytes(chunkLength, 4);\n}\n", "/* eslint-disable camelcase, max-statements, no-restricted-globals */\nimport type {LoaderContext} from '@loaders.gl/loader-utils';\nimport {BasisLoader, selectSupportedBasisFormat} from '@loaders.gl/textures';\nimport type {GLTFLoaderOptions} from '../../gltf-loader';\nimport type {GLB} from '../types/glb-types';\nimport type {GLTFWithBuffers} from '../types/gltf-types';\n\nimport {ImageLoader} from '@loaders.gl/images';\nimport {parseJSON, sliceArrayBuffer} from '@loaders.gl/loader-utils';\nimport {assert} from '../utils/assert';\nimport {resolveUrl} from '../gltf-utils/resolve-url';\nimport {getTypedArrayForBufferView} from '../gltf-utils/get-typed-array';\nimport {preprocessExtensions, decodeExtensions} from '../api/gltf-extensions';\nimport {normalizeGLTFV1} from '../api/normalize-gltf-v1';\nimport {postProcessGLTF} from '../api/post-process-gltf';\nimport parseGLBSync, {isGLB} from './parse-glb';\n\nexport type GLTFParseOptions = {\n  normalize?: boolean;\n  loadImages?: boolean;\n  loadBuffers?: boolean;\n  decompressMeshes?: boolean;\n  postProcess?: boolean;\n  excludeExtensions?: string[];\n};\n\n// export type GLTFOptions = {\n//   gltf?: GLTFParseOptions;\n// };\n\nexport function isGLTF(arrayBuffer, options?): boolean {\n  const byteOffset = 0;\n  return isGLB(arrayBuffer, byteOffset, options);\n}\n\nexport async function parseGLTF(\n  gltf: GLTFWithBuffers,\n  arrayBufferOrString,\n  byteOffset = 0,\n  options: GLTFLoaderOptions,\n  context: LoaderContext\n) {\n  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);\n\n  normalizeGLTFV1(gltf, {normalize: options?.gltf?.normalize});\n\n  preprocessExtensions(gltf, options, context);\n\n  const promises: Promise<any>[] = [];\n\n  // Load linked buffers asynchronously and decodes base64 buffers in parallel\n  if (options?.gltf?.loadBuffers && gltf.json.buffers) {\n    await loadBuffers(gltf, options, context);\n  }\n\n  if (options?.gltf?.loadImages) {\n    const promise = loadImages(gltf, options, context);\n    promises.push(promise);\n  }\n\n  const promise = decodeExtensions(gltf, options, context);\n  promises.push(promise);\n\n  // Parallelize image loading and buffer loading/extension decoding\n  await Promise.all(promises);\n\n  // Post processing resolves indices to objects, buffers\n  return options?.gltf?.postProcess ? postProcessGLTF(gltf, options) : gltf;\n}\n\n// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)\nfunction parseGLTFContainerSync(gltf, data, byteOffset, options) {\n  // Initialize gltf container\n  if (options.uri) {\n    gltf.baseUri = options.uri;\n  }\n\n  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string\n  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(data);\n  }\n\n  if (typeof data === 'string') {\n    // If string, try to parse as JSON\n    gltf.json = parseJSON(data);\n  } else if (data instanceof ArrayBuffer) {\n    // If still ArrayBuffer, parse as GLB container\n    const glb: GLB = {} as GLB;\n    byteOffset = parseGLBSync(glb, data, byteOffset, options.glb);\n\n    assert(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);\n\n    gltf._glb = glb;\n    gltf.json = glb.json;\n  } else {\n    assert(false, 'GLTF: must be ArrayBuffer or string');\n  }\n\n  // Populate buffers\n  // Create an external buffers array to hold binary data\n  const buffers = gltf.json.buffers || [];\n  gltf.buffers = new Array(buffers.length).fill(null);\n\n  // Populates JSON and some bin chunk info\n  if (gltf._glb && gltf._glb.header.hasBinChunk) {\n    const {binChunks} = gltf._glb;\n    gltf.buffers[0] = {\n      arrayBuffer: binChunks[0].arrayBuffer,\n      byteOffset: binChunks[0].byteOffset,\n      byteLength: binChunks[0].byteLength\n    };\n\n    // TODO - this modifies JSON and is a post processing thing\n    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;\n    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;\n  }\n\n  // Populate images\n  const images = gltf.json.images || [];\n  gltf.images = new Array(images.length).fill({});\n}\n\n/** Asynchronously fetch and parse buffers, store in buffers array outside of json\n * TODO - traverse gltf and determine which buffers are actually needed\n */\nasync function loadBuffers(gltf: GLTFWithBuffers, options, context: LoaderContext) {\n  // TODO\n  const buffers = gltf.json.buffers || [];\n  for (let i = 0; i < buffers.length; ++i) {\n    const buffer = buffers[i];\n    if (buffer.uri) {\n      const {fetch} = context;\n      assert(fetch);\n\n      const uri = resolveUrl(buffer.uri, options);\n      const response = await context?.fetch?.(uri);\n      const arrayBuffer = await response?.arrayBuffer?.();\n\n      gltf.buffers[i] = {\n        arrayBuffer,\n        byteOffset: 0,\n        byteLength: arrayBuffer.byteLength\n      };\n\n      delete buffer.uri;\n    } else if (gltf.buffers[i] === null) {\n      gltf.buffers[i] = {\n        arrayBuffer: new ArrayBuffer(buffer.byteLength),\n        byteOffset: 0,\n        byteLength: buffer.byteLength\n      };\n    }\n  }\n}\n\n/**\n * Loads all images\n * TODO - traverse gltf and determine which images are actually needed\n * @param gltf\n * @param options\n * @param context\n * @returns\n */\nasync function loadImages(gltf: GLTFWithBuffers, options, context: LoaderContext) {\n  const imageIndices = getReferencesImageIndices(gltf);\n\n  const images = gltf.json.images || [];\n\n  const promises: Promise<any>[] = [];\n  for (const imageIndex of imageIndices) {\n    promises.push(loadImage(gltf, images[imageIndex], imageIndex, options, context));\n  }\n\n  return await Promise.all(promises);\n}\n\n/** Make sure we only load images that are actually referenced by textures */\nfunction getReferencesImageIndices(gltf: GLTFWithBuffers): number[] {\n  const imageIndices = new Set<number>();\n\n  const textures = gltf.json.textures || [];\n  for (const texture of textures) {\n    if (texture.source !== undefined) {\n      imageIndices.add(texture.source);\n    }\n  }\n\n  return Array.from(imageIndices).sort();\n}\n\n/** Asynchronously fetches and parses one image, store in images array outside of json */\nasync function loadImage(\n  gltf: GLTFWithBuffers,\n  image,\n  index: number,\n  options,\n  context: LoaderContext\n) {\n  const {fetch, parse} = context;\n\n  let arrayBuffer;\n\n  if (image.uri && !image.hasOwnProperty('bufferView')) {\n    const uri = resolveUrl(image.uri, options);\n    const response = await fetch(uri);\n    arrayBuffer = await response.arrayBuffer();\n    image.bufferView = {\n      data: arrayBuffer\n    };\n  }\n\n  if (Number.isFinite(image.bufferView)) {\n    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);\n    arrayBuffer = sliceArrayBuffer(array.buffer, array.byteOffset, array.byteLength);\n  }\n\n  assert(arrayBuffer, 'glTF image has no data');\n\n  // Call `parse`\n  let parsedImage = await parse(\n    arrayBuffer,\n    [ImageLoader, BasisLoader],\n    {mimeType: image.mimeType, basis: options.basis || {format: selectSupportedBasisFormat()}},\n    context\n  );\n\n  if (parsedImage && parsedImage[0]) {\n    parsedImage = {\n      compressed: true,\n      mipmaps: false,\n      width: parsedImage[0].width,\n      height: parsedImage[0].height,\n      data: parsedImage[0]\n    };\n  }\n  // TODO making sure ImageLoader is overridable by using array of loaders\n  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);\n\n  // Store the loaded image\n  gltf.images = gltf.images || [];\n  gltf.images[index] = parsedImage;\n}\n", "import type {LoaderWithParser, LoaderOptions} from '@loaders.gl/loader-utils';\nimport type {DracoLoaderOptions} from '@loaders.gl/draco';\nimport {VERSION} from './lib/utils/version';\nimport type {ImageLoaderOptions} from '@loaders.gl/images';\nimport type {TextureLoaderOptions} from '@loaders.gl/textures';\nimport type {GLTFParseOptions} from './lib/parsers/parse-gltf';\nimport type {GLTFWithBuffers} from './lib/types/gltf-types';\nimport {parseGLTF} from './lib/parsers/parse-gltf';\nimport {GLBLoaderOptions} from './glb-loader';\n\n/**\n * GLTF loader options\n */\nexport type GLTFLoaderOptions = LoaderOptions &\n  ImageLoaderOptions &\n  TextureLoaderOptions &\n  GLBLoaderOptions &\n  DracoLoaderOptions & {\n    gltf?: GLTFParseOptions;\n  };\n\n/**\n * GLTF loader\n */\nexport const GLTFLoader: LoaderWithParser = {\n  name: 'glTF',\n  id: 'gltf',\n  module: 'gltf',\n  version: VERSION,\n  extensions: ['gltf', 'glb'],\n  mimeTypes: ['model/gltf+json', 'model/gltf-binary'],\n\n  text: true,\n  binary: true,\n  tests: ['glTF'],\n  parse,\n\n  options: {\n    gltf: {\n      normalize: true, // Normalize glTF v1 to glTF v2 format (not yet stable)\n      loadBuffers: true, // Fetch any linked .BIN buffers, decode base64\n      loadImages: true, // Create image objects\n      decompressMeshes: true, // Decompress Draco encoded meshes\n      postProcess: true // Postprocess glTF and return json structure directly\n    },\n\n    // common?\n    log: console // eslint-disable-line\n  },\n  deprecatedOptions: {\n    fetchImages: 'gltf.loadImages',\n    createImages: 'gltf.loadImages',\n    decompress: 'gltf.decompressMeshes',\n    postProcess: 'gltf.postProcess',\n    gltf: {\n      decompress: 'gltf.decompressMeshes'\n    }\n  }\n};\n\nexport async function parse(arrayBuffer, options: GLTFLoaderOptions = {}, context) {\n  // Apps can call the parse method directly, we so apply default options here\n  options = {...GLTFLoader.options, ...options};\n  // @ts-ignore\n  options.gltf = {...GLTFLoader.options.gltf, ...options.gltf};\n\n  const {byteOffset = 0} = options;\n  const gltf = {};\n  return await parseGLTF(gltf as GLTFWithBuffers, arrayBuffer, byteOffset, options, context);\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n// TODO - should we automatically parse the embedded glTF or leave it to the app?\n// - I.e. some apps might work directly on a GLB, in that case no need for us to decode...\n// - And if we decode, do we still keep the GLB in case it is needed?\n// - Do we add an option to control this?\n// - Also, should we have hard dependency on gltf module or use injection or auto-discovery for gltf parser?\n\nimport {GLTFLoader} from '@loaders.gl/gltf';\nimport {sliceArrayBuffer} from '@loaders.gl/loader-utils';\n\nexport const GLTF_FORMAT = {\n  URI: 0,\n  EMBEDDED: 1\n};\n\nexport function parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options) {\n  // Set flags\n  // glTF models need to be rotated from Y to Z up\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#y-up-to-z-up\n  tile.rotateYtoZ = true;\n\n  // Assume glTF consumes rest of tile\n  const gltfByteLength = tile.byteOffset + tile.byteLength - byteOffset;\n  if (gltfByteLength === 0) {\n    throw new Error('glTF byte length must be greater than 0.');\n  }\n\n  // Save gltf up axis\n  tile.gltfUpAxis =\n    options['3d-tiles'] && options['3d-tiles'].assetGltfUpAxis\n      ? options['3d-tiles'].assetGltfUpAxis\n      : 'Y';\n\n  // TODO - We can avoid copy if already 4-byte aligned...\n  // However the rest of the code may not be able to accept byteOffsets, so copy anyway\n  tile.gltfArrayBuffer = sliceArrayBuffer(arrayBuffer, byteOffset, gltfByteLength);\n  tile.gltfByteOffset = 0;\n  tile.gltfByteLength = gltfByteLength;\n\n  if (byteOffset % 4 === 0) {\n    // tile.gltfArrayBuffer = arrayBuffer;\n    // tile.gltfByteOffset = byteOffset;\n    // tile.gltfByteLength = gltfByteLength;\n  } else {\n    // Create a copy of the glb so that it is 4-byte aligned\n    // eslint-disable-next-line\n    console.warn(`${tile.type}: embedded glb is not aligned to a 4-byte boundary.`);\n  }\n\n  // Entire tile is consumed\n  return tile.byteOffset + tile.byteLength;\n}\n\nexport async function extractGLTF(tile, gltfFormat, options, context) {\n  const tile3DOptions = options['3d-tiles'] || {};\n\n  extractGLTFBufferOrURL(tile, gltfFormat, options);\n\n  if (tile3DOptions.loadGLTF) {\n    const {parse, fetch} = context;\n    if (tile.gltfUrl) {\n      tile.gltfArrayBuffer = await fetch(tile.gltfUrl, options);\n      tile.gltfByteOffset = 0;\n    }\n    if (tile.gltfArrayBuffer) {\n      // TODO - Should handle byteOffset... However, not used now...\n      tile.gltf = await parse(tile.gltfArrayBuffer, GLTFLoader, options, context);\n      delete tile.gltfArrayBuffer;\n      delete tile.gltfByteOffset;\n      delete tile.gltfByteLength;\n    }\n  }\n}\n\nfunction extractGLTFBufferOrURL(tile, gltfFormat, options) {\n  switch (gltfFormat) {\n    case GLTF_FORMAT.URI:\n      // We need to remove padding from the end of the model URL in case this tile was part of a composite tile.\n      // This removes all white space and null characters from the end of the string.\n      const gltfUrlBytes = new Uint8Array(tile.gltfArrayBuffer, tile.gltfByteOffset);\n      const textDecoder = new TextDecoder();\n      const gltfUrl = textDecoder.decode(gltfUrlBytes);\n      tile.gltfUrl = gltfUrl.replace(/[\\s\\0]+$/, '');\n      delete tile.gltfArrayBuffer;\n      delete tile.gltfByteOffset;\n      delete tile.gltfByteLength;\n      break;\n    case GLTF_FORMAT.EMBEDDED:\n      break;\n    default:\n      throw new Error('b3dm: Illegal glTF format field');\n  }\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {GL} from '@loaders.gl/math'; // math.gl/geometry;\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\n// import Tile3DBatchTable from '../classes/tile-3d-batch-table';\n\nimport {parse3DTileHeaderSync} from './helpers/parse-3d-tile-header';\nimport {parse3DTileTablesHeaderSync, parse3DTileTablesSync} from './helpers/parse-3d-tile-tables';\nimport {parse3DTileGLTFViewSync, extractGLTF, GLTF_FORMAT} from './helpers/parse-3d-tile-gltf-view';\n\nexport async function parseBatchedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parseBatchedModel(tile, arrayBuffer, byteOffset, options, context);\n  await extractGLTF(tile, GLTF_FORMAT.EMBEDDED, options, context);\n\n  const extensions = tile?.gltf?.extensions;\n  if (extensions && extensions.CESIUM_RTC) {\n    tile.rtcCenter = extensions.CESIUM_RTC.center;\n  }\n\n  return byteOffset;\n}\n\nfunction parseBatchedModel(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n\n  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);\n\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n\n  return byteOffset;\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {Vector3, Matrix3, Matrix4, Quaternion} from '@math.gl/core';\nimport {Ellipsoid} from '@math.gl/geospatial';\nimport {GL} from '@loaders.gl/math'; // 'math.gl/geometry';\nimport Tile3DFeatureTable from '../classes/tile-3d-feature-table';\nimport Tile3DBatchTable from '../classes/tile-3d-batch-table';\n\nimport {parse3DTileHeaderSync} from './helpers/parse-3d-tile-header';\nimport {parse3DTileTablesHeaderSync, parse3DTileTablesSync} from './helpers/parse-3d-tile-tables';\nimport {parse3DTileGLTFViewSync, extractGLTF} from './helpers/parse-3d-tile-gltf-view';\n\nexport async function parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parseInstancedModel(tile, arrayBuffer, byteOffset, options, context);\n  await extractGLTF(tile, tile.gltfFormat, options, context);\n  return byteOffset;\n}\n\nfunction parseInstancedModel(tile, arrayBuffer, byteOffset, options, context) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n  if (tile.version !== 1) {\n    throw new Error(`Instanced 3D Model version ${tile.version} is not supported`);\n  }\n\n  byteOffset = parse3DTileTablesHeaderSync(tile, arrayBuffer, byteOffset);\n\n  const view = new DataView(arrayBuffer);\n\n  tile.gltfFormat = view.getUint32(byteOffset, true);\n  byteOffset += 4;\n\n  // PARSE FEATURE TABLE\n  byteOffset = parse3DTileTablesSync(tile, arrayBuffer, byteOffset, options);\n\n  byteOffset = parse3DTileGLTFViewSync(tile, arrayBuffer, byteOffset, options);\n\n  // TODO - Is the feature table sometimes optional or can check be moved into table header parser?\n  if (tile.featureTableJsonByteLength === 0) {\n    throw new Error('i3dm parser: featureTableJsonByteLength is zero.');\n  }\n\n  const featureTable = new Tile3DFeatureTable(tile.featureTableJson, tile.featureTableBinary);\n\n  const instancesLength = featureTable.getGlobalProperty('INSTANCES_LENGTH');\n  featureTable.featuresLength = instancesLength;\n\n  if (!Number.isFinite(instancesLength)) {\n    throw new Error('i3dm parser: INSTANCES_LENGTH must be defined');\n  }\n\n  tile.eastNorthUp = featureTable.getGlobalProperty('EAST_NORTH_UP');\n  tile.rtcCenter = featureTable.getGlobalProperty('RTC_CENTER', GL.FLOAT, 3);\n\n  const batchTable = new Tile3DBatchTable(\n    tile.batchTableJson,\n    tile.batchTableBinary,\n    instancesLength\n  );\n\n  extractInstancedAttributes(tile, featureTable, batchTable, instancesLength);\n\n  return byteOffset;\n}\n\n// eslint-disable-next-line max-statements, complexity\nfunction extractInstancedAttributes(tile, featureTable, batchTable, instancesLength) {\n  // Create model instance collection\n  const collectionOptions = {\n    instances: new Array(instancesLength),\n    batchTable: tile._batchTable,\n    cull: false, // Already culled by 3D Tiles\n    url: undefined,\n    // requestType: RequestType.TILES3D,\n    gltf: undefined,\n    basePath: undefined,\n    incrementallyLoadTextures: false,\n    // TODO - tileset is not available at this stage, tile is parsed independently\n    // upAxis: (tileset && tileset._gltfUpAxis) || [0, 1, 0],\n    forwardAxis: [1, 0, 0]\n  };\n\n  const instances = collectionOptions.instances;\n  const instancePosition = new Vector3();\n  const instanceNormalRight = new Vector3();\n  const instanceNormalUp = new Vector3();\n  const instanceNormalForward = new Vector3();\n  const instanceRotation = new Matrix3();\n  const instanceQuaternion = new Quaternion();\n  const instanceScale = new Vector3();\n  const instanceTranslationRotationScale = {};\n  const instanceTransform = new Matrix4();\n  const scratch1 = [];\n  const scratch2 = [];\n  const scratchVector1 = new Vector3();\n  const scratchVector2 = new Vector3();\n\n  for (let i = 0; i < instancesLength; i++) {\n    let position;\n\n    // Get the instance position\n    if (featureTable.hasProperty('POSITION')) {\n      position = featureTable.getProperty('POSITION', GL.FLOAT, 3, i, instancePosition);\n    } else if (featureTable.hasProperty('POSITION_QUANTIZED')) {\n      position = featureTable.getProperty(\n        'POSITION_QUANTIZED',\n        GL.UNSIGNED_SHORT,\n        3,\n        i,\n        instancePosition\n      );\n\n      const quantizedVolumeOffset = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_OFFSET',\n        GL.FLOAT,\n        3,\n        scratchVector1\n      );\n      if (!quantizedVolumeOffset) {\n        throw new Error(\n          'i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.'\n        );\n      }\n\n      const quantizedVolumeScale = featureTable.getGlobalProperty(\n        'QUANTIZED_VOLUME_SCALE',\n        GL.FLOAT,\n        3,\n        scratchVector2\n      );\n      if (!quantizedVolumeScale) {\n        throw new Error(\n          'i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.'\n        );\n      }\n\n      const MAX_UNSIGNED_SHORT = 65535.0;\n      for (let j = 0; j < 3; j++) {\n        position[j] =\n          (position[j] / MAX_UNSIGNED_SHORT) * quantizedVolumeScale[j] + quantizedVolumeOffset[j];\n      }\n    }\n\n    if (!position) {\n      throw new Error('i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.');\n    }\n\n    instancePosition.copy(position);\n    // @ts-expect-error\n    instanceTranslationRotationScale.translation = instancePosition;\n\n    // Get the instance rotation\n    tile.normalUp = featureTable.getProperty('NORMAL_UP', GL.FLOAT, 3, i, scratch1);\n    tile.normalRight = featureTable.getProperty('NORMAL_RIGHT', GL.FLOAT, 3, i, scratch2);\n\n    const hasCustomOrientation = false;\n    if (tile.normalUp) {\n      if (!tile.normalRight) {\n        throw new Error('i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.');\n      }\n      // Vector3.unpack(normalUp, 0, instanceNormalUp);\n      // Vector3.unpack(normalRight, 0, instanceNormalRight);\n      tile.hasCustomOrientation = true;\n    } else {\n      tile.octNormalUp = featureTable.getProperty(\n        'NORMAL_UP_OCT32P',\n        GL.UNSIGNED_SHORT,\n        2,\n        scratch1\n      );\n      tile.octNormalRight = featureTable.getProperty(\n        'NORMAL_RIGHT_OCT32P',\n        GL.UNSIGNED_SHORT,\n        2,\n        scratch2\n      );\n\n      if (tile.octNormalUp) {\n        if (!tile.octNormalRight) {\n          throw new Error(\n            'i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P'\n          );\n        }\n\n        throw new Error('i3dm: oct-encoded orientation not implemented');\n        /*\n        AttributeCompression.octDecodeInRange(octNormalUp[0], octNormalUp[1], 65535, instanceNormalUp);\n        AttributeCompression.octDecodeInRange(octNormalRight[0], octNormalRight[1], 65535, instanceNormalRight);\n        hasCustomOrientation = true;\n        */\n      } else if (tile.eastNorthUp) {\n        Ellipsoid.WGS84.eastNorthUpToFixedFrame(instancePosition, instanceTransform);\n        instanceTransform.getRotationMatrix3(instanceRotation);\n      } else {\n        instanceRotation.identity();\n      }\n    }\n\n    if (hasCustomOrientation) {\n      instanceNormalForward.copy(instanceNormalRight).cross(instanceNormalUp).normalize();\n      instanceRotation.setColumn(0, instanceNormalRight);\n      instanceRotation.setColumn(1, instanceNormalUp);\n      instanceRotation.setColumn(2, instanceNormalForward);\n    }\n\n    instanceQuaternion.fromMatrix3(instanceRotation);\n    // @ts-expect-error\n    instanceTranslationRotationScale.rotation = instanceQuaternion;\n\n    // Get the instance scale\n    instanceScale.set(1.0, 1.0, 1.0);\n    const scale = featureTable.getProperty('SCALE', GL.FLOAT, 1, i);\n    if (Number.isFinite(scale)) {\n      instanceScale.multiplyByScalar(scale);\n    }\n    const nonUniformScale = featureTable.getProperty('SCALE_NON_UNIFORM', GL.FLOAT, 3, i, scratch1);\n    if (nonUniformScale) {\n      instanceScale.scale(nonUniformScale);\n    }\n\n    // @ts-expect-error\n    instanceTranslationRotationScale.scale = instanceScale;\n\n    // Get the batchId\n    let batchId = featureTable.getProperty('BATCH_ID', GL.UNSIGNED_SHORT, 1, i);\n    if (batchId === undefined) {\n      // If BATCH_ID semantic is undefined, batchId is just the instance number\n      batchId = i;\n    }\n\n    // @ts-expect-error\n    const rotationMatrix = new Matrix4().fromQuaternion(instanceTranslationRotationScale.rotation);\n\n    // Create the model matrix and the instance\n    instanceTransform.identity();\n    // @ts-expect-error\n    instanceTransform.translate(instanceTranslationRotationScale.translation);\n    instanceTransform.multiplyRight(rotationMatrix);\n    // @ts-expect-error\n    instanceTransform.scale(instanceTranslationRotationScale.scale);\n\n    const modelMatrix = instanceTransform.clone();\n    instances[i] = {\n      modelMatrix,\n      batchId\n    };\n  }\n\n  tile.instances = instances;\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n// Reference code:\n// https://github.com/AnalyticalGraphicsInc/cesium/blob/master/Source/Scene/Composite3DTileContent.js#L182\n\nimport {parse3DTileHeaderSync} from './helpers/parse-3d-tile-header';\n\n// eslint-disable-next-line max-params\nexport async function parseComposite3DTile(\n  tile,\n  arrayBuffer,\n  byteOffset,\n  options,\n  context,\n  parse3DTile\n) {\n  byteOffset = parse3DTileHeaderSync(tile, arrayBuffer, byteOffset);\n\n  const view = new DataView(arrayBuffer);\n\n  // Extract number of tiles\n  tile.tilesLength = view.getUint32(byteOffset, true);\n  byteOffset += 4;\n\n  // extract each tile from the byte stream\n  tile.tiles = [];\n  while (tile.tiles.length < tile.tilesLength && tile.byteLength - byteOffset > 12) {\n    const subtile = {};\n    tile.tiles.push(subtile);\n    byteOffset = await parse3DTile(arrayBuffer, byteOffset, options, context, subtile);\n    // TODO - do we need to add any padding in between tiles?\n  }\n\n  return byteOffset;\n}\n", "import {GLTFLoader} from '@loaders.gl/gltf';\n\nexport async function parseGltf3DTile(tile, arrayBuffer, options, context) {\n  // Set flags\n  // glTF models need to be rotated from Y to Z up\n  // https://github.com/AnalyticalGraphicsInc/3d-tiles/tree/master/specification#y-up-to-z-up\n  tile.rotateYtoZ = true;\n  // Save gltf up axis\n  tile.gltfUpAxis =\n    options['3d-tiles'] && options['3d-tiles'].assetGltfUpAxis\n      ? options['3d-tiles'].assetGltfUpAxis\n      : 'Y';\n\n  const {parse} = context;\n  tile.gltf = await parse(arrayBuffer, GLTFLoader, options, context);\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {TILE3D_TYPE} from '../constants';\nimport {getMagicString} from './helpers/parse-utils';\n\nimport {parsePointCloud3DTile} from './parse-3d-tile-point-cloud';\nimport {parseBatchedModel3DTile} from './parse-3d-tile-batched-model';\nimport {parseInstancedModel3DTile} from './parse-3d-tile-instanced-model';\nimport {parseComposite3DTile} from './parse-3d-tile-composite';\nimport {parseGltf3DTile} from './parse-3d-tile-gltf';\n\n// Extracts\nexport async function parse3DTile(arrayBuffer, byteOffset = 0, options, context, tile = {}) {\n  // @ts-expect-error\n  tile.byteOffset = byteOffset;\n  // @ts-expect-error\n  tile.type = getMagicString(arrayBuffer, byteOffset);\n\n  // @ts-expect-error\n  switch (tile.type) {\n    case TILE3D_TYPE.COMPOSITE:\n      // Note: We pass this function as argument so that embedded tiles can be parsed recursively\n      return await parseComposite3DTile(\n        tile,\n        arrayBuffer,\n        byteOffset,\n        options,\n        context,\n        parse3DTile\n      );\n\n    case TILE3D_TYPE.BATCHED_3D_MODEL:\n      return await parseBatchedModel3DTile(tile, arrayBuffer, byteOffset, options, context);\n\n    case TILE3D_TYPE.GLTF:\n      return await parseGltf3DTile(tile, arrayBuffer, options, context);\n\n    case TILE3D_TYPE.INSTANCED_3D_MODEL:\n      return await parseInstancedModel3DTile(tile, arrayBuffer, byteOffset, options, context);\n\n    case TILE3D_TYPE.POINT_CLOUD:\n      return await parsePointCloud3DTile(tile, arrayBuffer, byteOffset, options, context);\n\n    default:\n      // @ts-expect-error\n      throw new Error(`3DTileLoader: unknown type ${tile.type}`); // eslint-disable-line\n  }\n}\n", "import type {Subtree, ExplicitBitstream} from '../../../types';\nimport type {LoaderContext, LoaderOptions} from '@loaders.gl/loader-utils';\n\nconst SUBTREE_FILE_MAGIC = 0x74627573;\nconst SUBTREE_FILE_VERSION = 1;\n\n/**\n * Parse subtree file\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling#subtree-file-format\n * @param data\n * @returns\n */\n// eslint-disable-next-line max-statements\nexport default async function parse3DTilesSubtree(\n  data: ArrayBuffer,\n  options: LoaderOptions | undefined,\n  context: LoaderContext | undefined\n): Promise<Subtree> {\n  const magic = new Uint32Array(data.slice(0, 4));\n\n  if (magic[0] !== SUBTREE_FILE_MAGIC) {\n    throw new Error('Wrong subtree file magic number');\n  }\n\n  const version = new Uint32Array(data.slice(4, 8));\n\n  if (version[0] !== SUBTREE_FILE_VERSION) {\n    throw new Error('Wrong subtree file verson, must be 1');\n  }\n\n  const jsonByteLength = parseUint64Value(data.slice(8, 16));\n  const stringAttribute = new Uint8Array(data, 24, jsonByteLength);\n\n  const textDecoder = new TextDecoder('utf8');\n  const string = textDecoder.decode(stringAttribute);\n  const subtree = JSON.parse(string);\n\n  const binaryByteLength = parseUint64Value(data.slice(16, 24));\n  let internalBinaryBuffer = new ArrayBuffer(0);\n\n  if (binaryByteLength) {\n    internalBinaryBuffer = data.slice(24 + jsonByteLength);\n  }\n\n  if ('bufferView' in subtree.tileAvailability) {\n    subtree.tileAvailability.explicitBitstream = await getExplicitBitstream(\n      subtree,\n      'tileAvailability',\n      internalBinaryBuffer,\n      context\n    );\n  }\n\n  if ('bufferView' in subtree.contentAvailability) {\n    subtree.contentAvailability.explicitBitstream = await getExplicitBitstream(\n      subtree,\n      'contentAvailability',\n      internalBinaryBuffer,\n      context\n    );\n  }\n\n  if ('bufferView' in subtree.childSubtreeAvailability) {\n    subtree.childSubtreeAvailability.explicitBitstream = await getExplicitBitstream(\n      subtree,\n      'childSubtreeAvailability',\n      internalBinaryBuffer,\n      context\n    );\n  }\n\n  return subtree;\n}\n\n/**\n * Get url for bitstream downloading\n * @param bitstreamRelativeUri\n * @param baseUri\n * @returns\n */\nfunction resolveBufferUri(bitstreamRelativeUri: string, basePath: string): string {\n  const hasProtocol = basePath.startsWith('http');\n\n  if (hasProtocol) {\n    const resolvedUri = new URL(bitstreamRelativeUri, basePath);\n    return decodeURI(resolvedUri.toString());\n  }\n\n  /**\n   * Adding http protocol only for new URL constructor usage.\n   * It allows to resolve relative paths like ../../example with basePath.\n   */\n  const basePathWithProtocol = `http://${basePath}`;\n  const resolvedUri = new URL(bitstreamRelativeUri, basePathWithProtocol);\n  /**\n   * Drop protocol and use just relative path.\n   */\n  return `/${resolvedUri.host}${resolvedUri.pathname}`;\n}\n\n/**\n * Get explicit bitstream for subtree availability data.\n * @param subtree\n * @param name\n * @param internalBinaryBuffer\n */\nasync function getExplicitBitstream(\n  subtree: Subtree,\n  name: string,\n  internalBinaryBuffer: ArrayBuffer,\n  context: LoaderContext | undefined\n): Promise<ExplicitBitstream> {\n  const bufferViewIndex = subtree[name].bufferView;\n  const bufferView = subtree.bufferViews[bufferViewIndex];\n  const buffer = subtree.buffers[bufferView.buffer];\n\n  if (!context?.url || !context.fetch) {\n    throw new Error('Url is not provided');\n  }\n\n  if (!context.fetch) {\n    throw new Error('fetch is not provided');\n  }\n\n  // External bitstream loading\n  if (buffer.uri) {\n    const bufferUri = resolveBufferUri(buffer.uri, context?.url);\n    const response = await context.fetch(bufferUri);\n    const data = await response.arrayBuffer();\n    // Return view of bitstream.\n    return new Uint8Array(data, bufferView.byteOffset, bufferView.byteLength);\n  }\n  // Return view of bitstream.\n  return new Uint8Array(internalBinaryBuffer, bufferView.byteOffset, bufferView.byteLength);\n}\n\n/**\n * Parse buffer to return uint64 value\n * @param buffer\n * @returns 64-bit value until precision is lost after Number.MAX_SAFE_INTEGER\n */\nfunction parseUint64Value(buffer: ArrayBuffer): number {\n  const dataView = new DataView(buffer);\n  const left = dataView.getUint32(0, true);\n  const right = dataView.getUint32(4, true);\n  // combine the two 32-bit values\n  return left + 2 ** 32 * right;\n}\n", "import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport parse3DTilesSubtree from './lib/parsers/helpers/parse-3d-tile-subtree';\nimport {VERSION} from './lib/utils/version';\n\n/**\n * Loader for 3D Tiles Subtree\n *\n */\nexport const Tile3DSubtreeLoader: LoaderWithParser = {\n  id: '3d-tiles-subtree',\n  name: '3D Tiles Subtree',\n  module: '3d-tiles',\n  version: VERSION,\n  extensions: ['subtree'],\n  mimeTypes: ['application/octet-stream'],\n  tests: ['subtree'],\n  parse: parse3DTilesSubtree,\n  options: {}\n};\n", "import type {Availability, BoundingVolume, Subtree} from '../../../types';\nimport {Tile3DSubtreeLoader} from '../../../tile-3d-subtree-loader';\nimport {load} from '@loaders.gl/core';\n\nconst QUADTREE_DEVISION_COUNT = 4;\nconst OCTREE_DEVISION_COUNT = 8;\n\nconst SUBDIVISION_COUNT_MAP = {\n  QUADTREE: QUADTREE_DEVISION_COUNT,\n  OCTREE: OCTREE_DEVISION_COUNT\n};\n\n/**\n * Recursively parse implicit tiles tree\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling\n * TODO Check out do we able to use Tile3D class as return type here.\n * @param subtree\n * @param lodMetricValue\n * @param options\n * @param parentData\n * @param childIndex\n * @param level\n * @param globalData\n */\n// eslint-disable-next-line max-statements\nexport async function parseImplicitTiles(params: {\n  subtree: Subtree;\n  options: any;\n  parentData?: {mortonIndex: number; x: number; y: number; z: number};\n  childIndex?: number;\n  level?: number;\n  globalData?: {level: number; mortonIndex: number; x: number; y: number; z: number};\n}) {\n  const {\n    options,\n    parentData = {\n      mortonIndex: 0,\n      x: 0,\n      y: 0,\n      z: 0\n    },\n    childIndex = 0,\n    globalData = {\n      level: 0,\n      mortonIndex: 0,\n      x: 0,\n      y: 0,\n      z: 0\n    }\n  } = params;\n  let {subtree, level = 0} = params;\n  const {\n    subdivisionScheme,\n    subtreeLevels,\n    maximumLevel,\n    contentUrlTemplate,\n    subtreesUriTemplate,\n    basePath\n  } = options;\n\n  const tile = {children: [], lodMetricValue: 0, contentUrl: ''};\n\n  const childrenPerTile = SUBDIVISION_COUNT_MAP[subdivisionScheme];\n\n  const childX = childIndex & 0b01;\n  const childY = (childIndex >> 1) & 0b01;\n  const childZ = (childIndex >> 2) & 0b01;\n\n  const levelOffset = (childrenPerTile ** level - 1) / (childrenPerTile - 1);\n  let childTileMortonIndex = concatBits(parentData.mortonIndex, childIndex);\n  let tileAvailabilityIndex = levelOffset + childTileMortonIndex;\n\n  // Local tile coordinates\n  let childTileX = concatBits(parentData.x, childX);\n  let childTileY = concatBits(parentData.y, childY);\n  let childTileZ = concatBits(parentData.z, childZ);\n\n  let isChildSubtreeAvailable = false;\n\n  if (level + 1 > subtreeLevels) {\n    isChildSubtreeAvailable = getAvailabilityResult(\n      subtree.childSubtreeAvailability,\n      childTileMortonIndex\n    );\n  }\n\n  const x = concatBits(globalData.x, childTileX);\n  const y = concatBits(globalData.y, childTileY);\n  const z = concatBits(globalData.z, childTileZ);\n  const lev = level + globalData.level;\n\n  if (isChildSubtreeAvailable) {\n    const subtreePath = `${basePath}/${subtreesUriTemplate}`;\n    const childSubtreeUrl = replaceContentUrlTemplate(subtreePath, lev, x, y, z);\n    const childSubtree = await load(childSubtreeUrl, Tile3DSubtreeLoader);\n\n    subtree = childSubtree;\n\n    globalData.mortonIndex = childTileMortonIndex;\n    globalData.x = childTileX;\n    globalData.y = childTileY;\n    globalData.z = childTileZ;\n    globalData.level = level;\n\n    childTileMortonIndex = 0;\n    tileAvailabilityIndex = 0;\n    childTileX = 0;\n    childTileY = 0;\n    childTileZ = 0;\n    level = 0;\n  }\n\n  const isTileAvailable = getAvailabilityResult(subtree.tileAvailability, tileAvailabilityIndex);\n\n  if (!isTileAvailable || level > maximumLevel) {\n    return tile;\n  }\n\n  const isContentAvailable = getAvailabilityResult(\n    subtree.contentAvailability,\n    tileAvailabilityIndex\n  );\n\n  if (isContentAvailable) {\n    tile.contentUrl = replaceContentUrlTemplate(contentUrlTemplate, lev, x, y, z);\n  }\n\n  const childTileLevel = level + 1;\n  const pData = {mortonIndex: childTileMortonIndex, x: childTileX, y: childTileY, z: childTileZ};\n\n  for (let index = 0; index < childrenPerTile; index++) {\n    const currentTile = await parseImplicitTiles({\n      subtree,\n      options,\n      parentData: pData,\n      childIndex: index,\n      level: childTileLevel,\n      globalData\n    });\n\n    if (currentTile.contentUrl || currentTile.children.length) {\n      const globalLevel = lev + 1;\n      const childCoordinates = {childTileX, childTileY, childTileZ};\n      const formattedTile = formatTileData(currentTile, globalLevel, childCoordinates, options);\n      // @ts-ignore\n      tile.children.push(formattedTile);\n    }\n  }\n\n  return tile;\n}\n\nfunction getAvailabilityResult(availabilityData: Availability, index: number): boolean {\n  if ('constant' in availabilityData) {\n    return Boolean(availabilityData.constant);\n  }\n\n  if (availabilityData.explicitBitstream) {\n    return getBooleanValueFromBitstream(index, availabilityData.explicitBitstream);\n  }\n\n  return false;\n}\n\n/**\n * Do formatting of implicit tile data.\n * TODO Check out do we able to use Tile3D class as type here.\n * @param tile\n * @param lodMetricValue\n * @param options\n * @returns\n */\nfunction formatTileData(\n  tile,\n  level: number,\n  childCoordinates: {childTileX: number; childTileY: number; childTileZ: number},\n  options: any\n) {\n  const {\n    basePath,\n    refine,\n    getRefine,\n    lodMetricType,\n    getTileType,\n    rootLodMetricValue,\n    rootBoundingVolume\n  } = options;\n  const uri = tile.contentUrl && tile.contentUrl.replace(`${basePath}/`, '');\n  const lodMetricValue = rootLodMetricValue / 2 ** level;\n  const boundingVolume = calculateBoundingVolumeForChildTile(\n    level,\n    rootBoundingVolume,\n    childCoordinates\n  );\n\n  return {\n    children: tile.children,\n    contentUrl: tile.contentUrl,\n    content: {uri},\n    id: tile.contentUrl,\n    refine: getRefine(refine),\n    type: getTileType(tile),\n    lodMetricType,\n    lodMetricValue,\n    geometricError: lodMetricValue,\n    transform: tile.transform,\n    boundingVolume\n  };\n}\n\n/**\n * Calculate child bounding volume.\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling#subdivision-rules\n * @param level\n * @param rootBoundingVolume\n * @param childCoordinates\n */\nfunction calculateBoundingVolumeForChildTile(\n  level: number,\n  rootBoundingVolume: BoundingVolume,\n  childCoordinates: {childTileX: number; childTileY: number; childTileZ: number}\n): BoundingVolume | null {\n  if (rootBoundingVolume.region) {\n    const {childTileX, childTileY, childTileZ} = childCoordinates;\n    const [west, south, east, north, minimumHeight, maximumHeight] = rootBoundingVolume.region;\n    const boundingVolumesCount = 2 ** level;\n\n    const sizeX = (east - west) / boundingVolumesCount;\n    const sizeY = (north - south) / boundingVolumesCount;\n    const sizeZ = (maximumHeight - minimumHeight) / boundingVolumesCount;\n\n    const [childWest, childEast] = [west + sizeX * childTileX, west + sizeX * (childTileX + 1)];\n    const [childSouth, childNorth] = [south + sizeY * childTileY, south + sizeY * (childTileY + 1)];\n    const [childMinimumHeight, childMaximumHeight] = [\n      minimumHeight + sizeZ * childTileZ,\n      minimumHeight + sizeZ * (childTileZ + 1)\n    ];\n\n    return {\n      region: [childWest, childSouth, childEast, childNorth, childMinimumHeight, childMaximumHeight]\n    };\n  }\n\n  // eslint-disable-next-line no-console\n  console.warn('Unsupported bounding volume type: ', rootBoundingVolume);\n  return null;\n}\n\n/**\n * Do binary concatenation\n * @param first\n * @param second\n */\nfunction concatBits(first: number, second: number): number {\n  return parseInt(first.toString(2) + second.toString(2), 2);\n}\n\n/**\n * Replace implicit tile content url with real coordinates.\n * @param templateUrl\n * @param level\n * @param x\n * @param y\n * @param z\n */\nexport function replaceContentUrlTemplate(\n  templateUrl: string,\n  level: number,\n  x: number,\n  y: number,\n  z: number\n): string {\n  const mapUrl = generateMapUrl({level, x, y, z});\n  return templateUrl.replace(/{level}|{x}|{y}|{z}/gi, (matched) => mapUrl[matched]);\n}\n\n/**\n * Get Map object for content url generation\n * @param items\n */\nfunction generateMapUrl(items: {[key: string]: number}): {[key: string]: string} {\n  const mapUrl = {};\n\n  for (const key in items) {\n    mapUrl[`{${key}}`] = items[key];\n  }\n  return mapUrl;\n}\n\n/**\n * Get boolean value from bistream by index\n * A boolean value is encoded as a single bit, either 0 (false) or 1 (true).\n * Multiple boolean values are packed tightly in the same buffer.\n * These buffers of tightly-packed bits are sometimes referred to as bitstreams.\n * Spec - https://github.com/CesiumGS/3d-tiles/tree/implicit-revisions/specification/Metadata#booleans\n * @param availabilitiIndex\n */\nfunction getBooleanValueFromBitstream(\n  availabilityIndex: number,\n  availabilityBuffer: Uint8Array\n): boolean {\n  const byteIndex = Math.floor(availabilityIndex / 8);\n  const bitIndex = availabilityIndex % 8;\n  const bitValue = (availabilityBuffer[byteIndex] >> bitIndex) & 1;\n\n  return bitValue === 1;\n}\n", "import type {LoaderOptions} from '@loaders.gl/loader-utils';\nimport {Tile3DSubtreeLoader} from '../../tile-3d-subtree-loader';\nimport {load} from '@loaders.gl/core';\nimport {Tileset3D, LOD_METRIC_TYPE, TILE_REFINEMENT, TILE_TYPE, Tile3D} from '@loaders.gl/tiles';\nimport {ImplicitTilingExtension, Subtree} from '../../types';\nimport {parseImplicitTiles, replaceContentUrlTemplate} from './helpers/parse-3d-implicit-tiles';\n\nfunction getTileType(tile) {\n  if (!tile.contentUrl) {\n    return TILE_TYPE.EMPTY;\n  }\n\n  const contentUrl = tile.contentUrl;\n  const fileExtension = contentUrl.split('.').pop();\n  switch (fileExtension) {\n    case 'pnts':\n      return TILE_TYPE.POINTCLOUD;\n    case 'i3dm':\n    case 'b3dm':\n    case 'glb':\n    case 'gltf':\n      return TILE_TYPE.SCENEGRAPH;\n    default:\n      return fileExtension;\n  }\n}\n\nfunction getRefine(refine) {\n  switch (refine) {\n    case 'REPLACE':\n    case 'replace':\n      return TILE_REFINEMENT.REPLACE;\n    case 'ADD':\n    case 'add':\n      return TILE_REFINEMENT.ADD;\n    default:\n      return refine;\n  }\n}\n\nfunction resolveUri(uri, basePath) {\n  // url scheme per RFC3986\n  const urlSchemeRegex = /^[a-z][0-9a-z+.-]*:/i;\n\n  if (urlSchemeRegex.test(basePath)) {\n    const url = new URL(uri, `${basePath}/`);\n    return decodeURI(url.toString());\n  } else if (uri.startsWith('/')) {\n    return uri;\n  }\n\n  return `${basePath}/${uri}`;\n}\n\nexport function normalizeTileData(tile, options) {\n  if (!tile) {\n    return null;\n  }\n  if (tile.content) {\n    const contentUri = tile.content.uri || tile.content.url;\n    tile.contentUrl = resolveUri(contentUri, options.basePath);\n  }\n  tile.id = tile.contentUrl;\n  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tile.lodMetricValue = tile.geometricError;\n  tile.transformMatrix = tile.transform;\n  tile.type = getTileType(tile);\n  tile.refine = getRefine(tile.refine);\n\n  return tile;\n}\n\n// normalize tile headers\nexport async function normalizeTileHeaders(\n  tileset: Tileset3D,\n  options: LoaderOptions\n): Promise<Tileset3D> {\n  const basePath = tileset.basePath;\n  let root: Tileset3D;\n\n  const rootImplicitTilingExtension = getImplicitTilingExtensionData(tileset?.root);\n  if (rootImplicitTilingExtension && tileset.root) {\n    root = await normalizeImplicitTileHeaders(\n      tileset.root,\n      tileset,\n      rootImplicitTilingExtension,\n      options\n    );\n  } else {\n    root = normalizeTileData(tileset.root, tileset);\n  }\n\n  const stack: any[] = [];\n  stack.push(root);\n\n  while (stack.length > 0) {\n    const tile = stack.pop() || {};\n    const children = tile.children || [];\n    for (let childHeader of children) {\n      const childImplicitTilingExtension = getImplicitTilingExtensionData(childHeader);\n      if (childImplicitTilingExtension) {\n        childHeader = await normalizeImplicitTileHeaders(\n          childHeader,\n          tileset,\n          childImplicitTilingExtension,\n          options\n        );\n      } else {\n        normalizeTileData(childHeader, {basePath});\n      }\n\n      stack.push(childHeader);\n    }\n  }\n\n  return root;\n}\n\n/**\n * Do normalisation of implicit tile headers\n * TODO Check if Tile3D class can be a return type here.\n * @param tileset\n */\nexport async function normalizeImplicitTileHeaders(\n  tile: Tile3D,\n  tileset: Tileset3D,\n  implicitTilingExtension: ImplicitTilingExtension,\n  options: LoaderOptions\n) {\n  const basePath = tileset.basePath;\n  const {\n    subdivisionScheme,\n    maximumLevel,\n    subtreeLevels,\n    subtrees: {uri: subtreesUriTemplate}\n  } = implicitTilingExtension;\n  const replacedUrlTemplate = replaceContentUrlTemplate(subtreesUriTemplate, 0, 0, 0, 0);\n  const subtreeUrl = resolveUri(replacedUrlTemplate, basePath);\n  const subtree = await load(subtreeUrl, Tile3DSubtreeLoader, options);\n  const contentUrlTemplate = resolveUri(tile.content.uri, basePath);\n  const refine = tileset?.root?.refine;\n  // @ts-ignore\n  const rootLodMetricValue = tile.geometricError;\n  const rootBoundingVolume = tile.boundingVolume;\n\n  const implicitOptions = {\n    contentUrlTemplate,\n    subtreesUriTemplate,\n    subdivisionScheme,\n    subtreeLevels,\n    maximumLevel,\n    refine,\n    basePath,\n    lodMetricType: LOD_METRIC_TYPE.GEOMETRIC_ERROR,\n    rootLodMetricValue,\n    rootBoundingVolume,\n    getTileType,\n    getRefine\n  };\n\n  return await normalizeImplicitTileData(tile, subtree, implicitOptions);\n}\n\n/**\n * Do implicit data normalisation to create hierarchical tile structure\n * @param tile\n * @param rootSubtree\n * @param options\n * @returns\n */\nexport async function normalizeImplicitTileData(tile, rootSubtree: Subtree, options: any) {\n  if (!tile) {\n    return null;\n  }\n\n  tile.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tile.lodMetricValue = tile.geometricError;\n  tile.transformMatrix = tile.transform;\n\n  const {children, contentUrl} = await parseImplicitTiles({subtree: rootSubtree, options});\n\n  if (contentUrl) {\n    tile.contentUrl = contentUrl;\n    tile.content = {uri: contentUrl.replace(`${options.basePath}/`, '')};\n  }\n\n  tile.refine = getRefine(tile.refine);\n  tile.type = getTileType(tile);\n  tile.children = children;\n  tile.id = tile.contentUrl;\n\n  return tile;\n}\n\n/**\n * Implicit Tiling data can be in 3DTILES_implicit_tiling for 3DTiles v.Next or directly in implicitTiling object for 3DTiles v1.1.\n * Spec 3DTiles v.Next - https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_implicit_tiling\n * Spec 3DTiles v.1.1 - https://github.com/CesiumGS/3d-tiles/tree/draft-1.1/specification/ImplicitTiling\n * @param tile\n * @returns\n */\nfunction getImplicitTilingExtensionData(tile: Tile3D | null): ImplicitTilingExtension {\n  return tile?.extensions?.['3DTILES_implicit_tiling'] || tile?.implicitTiling;\n}\n", "import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport {path} from '@loaders.gl/loader-utils';\nimport {TILESET_TYPE, LOD_METRIC_TYPE} from '@loaders.gl/tiles';\nimport {VERSION} from './lib/utils/version';\nimport {parse3DTile} from './lib/parsers/parse-3d-tile';\nimport {normalizeTileHeaders} from './lib/parsers/parse-3d-tile-header';\n\n/**\n * Loader for 3D Tiles\n */\nexport const Tiles3DLoader: LoaderWithParser = {\n  id: '3d-tiles',\n  name: '3D Tiles',\n  module: '3d-tiles',\n  version: VERSION,\n  extensions: ['cmpt', 'pnts', 'b3dm', 'i3dm'],\n  mimeTypes: ['application/octet-stream'],\n  tests: ['cmpt', 'pnts', 'b3dm', 'i3dm'],\n  parse,\n  options: {\n    '3d-tiles': {\n      loadGLTF: true,\n      decodeQuantizedPositions: false,\n      isTileset: 'auto',\n      assetGltfUpAxis: null\n    }\n  }\n};\n\nfunction getBaseUri(tileset) {\n  return path.dirname(tileset.url);\n}\n\nasync function parseTile(arrayBuffer, options, context) {\n  const tile = {\n    content: {\n      featureIds: null\n    }\n  };\n  const byteOffset = 0;\n  await parse3DTile(arrayBuffer, byteOffset, options, context, tile.content);\n  return tile.content;\n}\n\nasync function parseTileset(data, options, context) {\n  const tilesetJson = JSON.parse(new TextDecoder().decode(data));\n  // eslint-disable-next-line no-use-before-define\n  tilesetJson.loader = options.loader || Tiles3DLoader;\n  tilesetJson.url = context.url;\n  // base path that non-absolute paths in tileset are relative to.\n  tilesetJson.basePath = getBaseUri(tilesetJson);\n  tilesetJson.root = await normalizeTileHeaders(tilesetJson, options);\n\n  tilesetJson.type = TILESET_TYPE.TILES3D;\n\n  tilesetJson.lodMetricType = LOD_METRIC_TYPE.GEOMETRIC_ERROR;\n  tilesetJson.lodMetricValue = tilesetJson.root?.lodMetricValue || 0;\n\n  return tilesetJson;\n}\n\nasync function parse(data, options, context) {\n  // auto detect file type\n  const loaderOptions = options['3d-tiles'] || {};\n  let isTileset;\n  if (loaderOptions.isTileset === 'auto') {\n    isTileset = context.url && context.url.indexOf('.json') !== -1;\n  } else {\n    isTileset = loaderOptions.isTileset;\n  }\n\n  if (isTileset) {\n    data = await parseTileset(data, options, context);\n  } else {\n    data = await parseTile(data, options, context);\n  }\n\n  return data;\n}\n", "// Minimal support to load tilsets from the Cesium ION services\n\nimport {fetchFile} from '@loaders.gl/core';\nimport {assert} from '@loaders.gl/loader-utils';\n\nconst CESIUM_ION_URL = 'https://api.cesium.com/v1/assets';\n\n// Returns `{url, headers, type, attributions}` for an ion tileset\nexport async function getIonTilesetMetadata(accessToken, assetId) {\n  // Step 1, if no asset id, look for first 3DTILES asset associated with this token.\n  if (!assetId) {\n    const assets = await getIonAssets(accessToken);\n    for (const item of assets.items) {\n      if (item.type === '3DTILES') {\n        assetId = item.id;\n      }\n    }\n  }\n\n  // Step 2: Query metdatadata for this asset.\n  const ionAssetMetadata = await getIonAssetMetadata(accessToken, assetId);\n  const {type, url} = ionAssetMetadata;\n  assert(type === '3DTILES' && url);\n\n  // Prepare a headers object for fetch\n  ionAssetMetadata.headers = {\n    Authorization: `Bearer ${ionAssetMetadata.accessToken}`\n  };\n  return ionAssetMetadata;\n}\n\n// Return a list of all assets associated with accessToken\nexport async function getIonAssets(accessToken) {\n  assert(accessToken);\n  const url = CESIUM_ION_URL;\n  const headers = {Authorization: `Bearer ${accessToken}`};\n  const response = await fetchFile(url, {fetch: {headers}});\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  }\n  return await response.json();\n}\n\n// Return metadata for a specific asset associated with token\nexport async function getIonAssetMetadata(accessToken, assetId) {\n  assert(accessToken, assetId);\n  const headers = {Authorization: `Bearer ${accessToken}`};\n\n  const url = `${CESIUM_ION_URL}/${assetId}`;\n  // https://cesium.com/docs/rest-api/#operation/getAsset\n  // Retrieves metadata information about a specific asset.\n  let response = await fetchFile(`${url}`, {fetch: {headers}});\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  }\n  let metadata = await response.json();\n\n  // https://cesium.com/docs/rest-api/#operation/getAssetEndpoint\n  // Retrieves information and credentials that allow you to access the tiled asset data for visualization and analysis.\n  response = await fetchFile(`${url}/endpoint`, {fetch: {headers}});\n  if (!response.ok) {\n    throw new Error(response.statusText);\n  }\n  const tilesetInfo = await response.json();\n\n  // extract dataset description\n  metadata = {\n    ...metadata,\n    ...tilesetInfo\n  };\n\n  return metadata;\n}\n", "import type {LoaderWithParser} from '@loaders.gl/loader-utils';\nimport {Tiles3DLoader} from './tiles-3d-loader';\nimport {getIonTilesetMetadata} from './lib/ion/ion';\n\nasync function preload(url, options = {}) {\n  options = options['cesium-ion'] || {};\n  // @ts-ignore\n  const {accessToken} = options;\n  // @ts-ignore\n  let assetId = options.assetId;\n  if (!Number.isFinite(assetId)) {\n    const matched = url.match(/\\/([0-9]+)\\/tileset.json/);\n    assetId = matched && matched[1];\n  }\n  return getIonTilesetMetadata(accessToken, assetId);\n}\n\n/**\n * Loader for 3D tiles from Cesium ION\n */\nexport const CesiumIonLoader: LoaderWithParser = {\n  ...Tiles3DLoader,\n  id: 'cesium-ion',\n  name: 'Cesium Ion',\n  // @ts-ignore\n  preload,\n  parse: async (data, options?, context?) => {\n    options = {...options};\n    options['3d-tiles'] = options['cesium-ion'];\n    // @ts-ignore\n    options.loader = CesiumIonLoader;\n    return Tiles3DLoader.parse(data, options, context); // , loader);\n  },\n  options: {\n    'cesium-ion': {\n      ...Tiles3DLoader.options['3d-tiles'],\n      accessToken: null\n    }\n  }\n};\n", "// HELPER ENCODERS\nimport {assert} from '@loaders.gl/loader-utils';\n\nexport function encode3DTileHeader(tile, dataView, byteOffset) {\n  const HEADER_SIZE = 12;\n\n  if (!dataView) {\n    return byteOffset + HEADER_SIZE;\n  }\n\n  const {magic, version = 1, byteLength = 12} = tile;\n\n  assert(Array.isArray(magic) && Number.isFinite(version) && Number.isFinite(byteLength));\n\n  dataView.setUint8(byteOffset + 0, magic[0]);\n  dataView.setUint8(byteOffset + 1, magic[1]);\n  dataView.setUint8(byteOffset + 2, magic[2]);\n  dataView.setUint8(byteOffset + 3, magic[3]);\n  dataView.setUint32(byteOffset + 4, version, true); // version\n  dataView.setUint32(byteOffset + 8, byteLength, true); // byteLength\n\n  byteOffset += HEADER_SIZE;\n\n  return byteOffset;\n}\n\n// Bytelength is sometimes only known at the end of writing a tile\nexport function encode3DTileByteLength(dataView, byteOffsetTileStart, byteLength) {\n  if (!dataView) {\n    return;\n  }\n\n  dataView.setUint32(byteOffsetTileStart + 8, byteLength, true); // byteLength\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {MAGIC_ARRAY} from '../constants';\nimport {encode3DTileHeader, encode3DTileByteLength} from './helpers/encode-3d-tile-header';\n\nexport function encodeComposite3DTile(tile, dataView, byteOffset, options, encode3DTile) {\n  // Add default magic for this tile type\n  tile = {magic: MAGIC_ARRAY.COMPOSITE, tiles: [], ...tile};\n\n  const byteOffsetStart = byteOffset;\n\n  byteOffset += encode3DTileHeader(tile, dataView, byteOffset);\n\n  if (dataView) {\n    dataView.setUint32(byteOffset, tile.tiles.length, true); // tilesLength\n  }\n  byteOffset += 4;\n\n  for (let i = 0; i < tile.tiles.length; ++i) {\n    byteOffset += encode3DTile(tile.tiles[i], dataView, byteOffset, options);\n  }\n\n  // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n\n  return byteOffset;\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {\n  padToNBytes,\n  copyBinaryToDataView,\n  copyPaddedStringToDataView\n} from '@loaders.gl/loader-utils';\nimport {MAGIC_ARRAY} from '../constants';\nimport {encode3DTileHeader, encode3DTileByteLength} from './helpers/encode-3d-tile-header';\n\n// Procedurally encode the tile array dataView for testing purposes\nexport function encodeBatchedModel3DTile(tile, dataView, byteOffset, options) {\n  const {featuresLength = 0, batchTable} = tile;\n\n  const featureTableJson = {\n    BATCH_LENGTH: featuresLength\n  };\n  const featureTableJsonString = JSON.stringify(featureTableJson);\n  const batchTableJsonString = batchTable ? JSON.stringify(batchTable) : '';\n  const featureTableJsonByteLength = padToNBytes(featureTableJsonString.length, 8);\n  const batchTableJsonByteLength = batchTableJsonString\n    ? padToNBytes(batchTableJsonString.length, 8)\n    : 0;\n\n  // Add default magic for this tile type\n  tile = {magic: MAGIC_ARRAY.BATCHED_MODEL, ...tile};\n\n  const byteOffsetStart = byteOffset;\n\n  byteOffset = encode3DTileHeader(tile, dataView, byteOffset);\n\n  if (dataView) {\n    dataView.setUint32(12, featureTableJsonByteLength, true); // featureTableJsonByteLength\n    dataView.setUint32(16, 0, true); // featureTableBinaryByteLength\n    dataView.setUint32(20, batchTableJsonByteLength, true); // batchTableJsonByteLength\n    dataView.setUint32(24, 0, true); // batchTableBinaryByteLength\n  }\n  byteOffset += 16;\n\n  // TODO feature table binary\n  byteOffset = copyPaddedStringToDataView(dataView, byteOffset, featureTableJsonString, 8);\n\n  if (batchTable) {\n    byteOffset = copyPaddedStringToDataView(dataView, byteOffset, batchTableJsonString, 8);\n  }\n\n  // Add encoded GLTF to the end of data\n  const gltfEncoded = tile.gltfEncoded;\n  if (gltfEncoded) {\n    byteOffset = copyBinaryToDataView(dataView, byteOffset, gltfEncoded, gltfEncoded.byteLength);\n  }\n\n  // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n\n  return byteOffset;\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {copyStringToDataView} from '@loaders.gl/loader-utils';\nimport {MAGIC_ARRAY} from '../constants';\nimport {encode3DTileHeader, encode3DTileByteLength} from './helpers/encode-3d-tile-header';\n\n// Procedurally encode the tile array buffer for testing purposes\n// eslint-disable-next-line max-statements\nexport function encodeInstancedModel3DTile(tile, dataView, byteOffset, options) {\n  const {featuresLength = 1, gltfFormat = 1, gltfUri = ''} = tile;\n\n  const gltfUriByteLength = gltfUri.length;\n\n  const featureTableJson = {\n    INSTANCES_LENGTH: featuresLength,\n    POSITION: new Array(featuresLength * 3).fill(0)\n  };\n  const featureTableJsonString = JSON.stringify(featureTableJson);\n  const featureTableJsonByteLength = featureTableJsonString.length;\n\n  // Add default magic for this tile type\n  tile = {magic: MAGIC_ARRAY.INSTANCED_MODEL, ...tile};\n\n  const byteOffsetStart = byteOffset;\n\n  byteOffset = encode3DTileHeader(tile, dataView, 0);\n\n  if (dataView) {\n    dataView.setUint32(12, featureTableJsonByteLength, true); // featureTableJsonByteLength\n    dataView.setUint32(16, 0, true); // featureTableBinaryByteLength\n    dataView.setUint32(20, 0, true); // batchTableJsonByteLength\n    dataView.setUint32(24, 0, true); // batchTableBinaryByteLength\n    dataView.setUint32(28, gltfFormat, true); // gltfFormat\n  }\n\n  byteOffset += 20;\n\n  byteOffset += copyStringToDataView(\n    dataView,\n    byteOffset,\n    featureTableJsonString,\n    featureTableJsonByteLength\n  );\n  byteOffset += copyStringToDataView(dataView, byteOffset, gltfUri, gltfUriByteLength);\n\n  // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n\n  return byteOffset;\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {MAGIC_ARRAY} from '../constants';\nimport {encode3DTileHeader, encode3DTileByteLength} from './helpers/encode-3d-tile-header';\nimport {\n  padStringToByteAlignment,\n  copyStringToDataView,\n  copyBinaryToDataView\n} from '@loaders.gl/loader-utils';\n\nconst DEFAULT_FEATURE_TABLE_JSON = {\n  POINTS_LENGTH: 1,\n  POSITIONS: {\n    byteOffset: 0\n  }\n};\n\nexport function encodePointCloud3DTile(tile, dataView, byteOffset, options) {\n  const {featureTableJson = DEFAULT_FEATURE_TABLE_JSON} = tile;\n\n  let featureTableJsonString = JSON.stringify(featureTableJson);\n  featureTableJsonString = padStringToByteAlignment(featureTableJsonString, 4);\n\n  const {featureTableJsonByteLength = featureTableJsonString.length} = tile;\n\n  const featureTableBinary = new ArrayBuffer(12); // Enough space to hold 3 floats\n  const featureTableBinaryByteLength = featureTableBinary.byteLength;\n\n  // Add default magic for this tile type\n  tile = {magic: MAGIC_ARRAY.POINT_CLOUD, ...tile};\n\n  const byteOffsetStart = byteOffset;\n\n  byteOffset += encode3DTileHeader(tile, dataView, 0);\n\n  if (dataView) {\n    dataView.setUint32(byteOffset + 0, featureTableJsonByteLength, true); // featureTableJsonByteLength\n    dataView.setUint32(byteOffset + 4, featureTableBinaryByteLength, true); // featureTableBinaryByteLength\n    dataView.setUint32(byteOffset + 8, 0, true); // batchTableJsonByteLength\n    dataView.setUint32(byteOffset + 12, 0, true); // batchTableBinaryByteLength\n  }\n  byteOffset += 16;\n\n  byteOffset += copyStringToDataView(\n    dataView,\n    byteOffset,\n    featureTableJsonString,\n    featureTableJsonByteLength\n  );\n  byteOffset += copyBinaryToDataView(\n    dataView,\n    byteOffset,\n    featureTableBinary,\n    featureTableBinaryByteLength\n  );\n\n  // Go \"back\" and rewrite the tile's `byteLength` now that we know the value\n  encode3DTileByteLength(dataView, byteOffsetStart, byteOffset - byteOffsetStart);\n\n  return byteOffset;\n}\n", "// This file is derived from the Cesium code base under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\nimport {TILE3D_TYPE} from '../constants';\nimport {assert} from '@loaders.gl/loader-utils';\n\nimport {encodeComposite3DTile} from './encode-3d-tile-composite';\nimport {encodeBatchedModel3DTile} from './encode-3d-tile-batched-model';\nimport {encodeInstancedModel3DTile} from './encode-3d-tile-instanced-model';\nimport {encodePointCloud3DTile} from './encode-3d-tile-point-cloud';\n\nexport default function encode3DTile(tile, options) {\n  const byteLength = encode3DTileToDataView(tile, null, 0, options);\n  const arrayBuffer = new ArrayBuffer(byteLength);\n  const dataView = new DataView(arrayBuffer);\n  encode3DTileToDataView(tile, dataView, 0, options);\n  return arrayBuffer;\n}\n\nfunction encode3DTileToDataView(tile, dataView, byteOffset, options) {\n  assert(typeof tile.type === 'string');\n\n  switch (tile.type) {\n    case TILE3D_TYPE.COMPOSITE:\n      return encodeComposite3DTile(tile, dataView, byteOffset, options, encode3DTileToDataView);\n    case TILE3D_TYPE.POINT_CLOUD:\n      return encodePointCloud3DTile(tile, dataView, byteOffset, options);\n    case TILE3D_TYPE.BATCHED_3D_MODEL:\n      return encodeBatchedModel3DTile(tile, dataView, byteOffset, options);\n    case TILE3D_TYPE.INSTANCED_3D_MODEL:\n      return encodeInstancedModel3DTile(tile, dataView, byteOffset, options);\n    default:\n      throw new Error('3D Tiles: unknown tile type');\n  }\n}\n", "import type {Writer} from '@loaders.gl/loader-utils';\nimport {VERSION} from './lib/utils/version';\nimport encode3DTile from './lib/encoders/encode-3d-tile';\n\n/**\n * Exporter for 3D Tiles\n */\nexport const Tile3DWriter: Writer = {\n  name: '3D Tile',\n  id: '3d-tiles',\n  module: '3d-tiles',\n  version: VERSION,\n  extensions: ['cmpt', 'pnts', 'b3dm', 'i3dm'],\n  mimeTypes: ['application/octet-stream'],\n  encodeSync,\n  binary: true,\n  options: {\n    ['3d-tiles']: {}\n  }\n};\n\nfunction encodeSync(tile, options) {\n  return encode3DTile(tile, options);\n}\n"],
  "mappings": "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",
  "names": ["WGS84_RADIUS_X", "WGS84_RADIUS_Y", "WGS84_RADIUS_Z", "WGS84_CONSTANTS", "radii", "radiiSquared", "oneOverRadii", "oneOverRadiiSquared", "maximumRadius", "Math", "max", "centerToleranceSquared", "identity", "x", "scratchVector", "Vector3", "fromCartographic", "cartographic", "result", "map", "longitude", "latitude", "height", "y", "z", "fromCartographicToRadians", "vector", "config", "_cartographicRadians", "toRadians", "toCartographic", "vector", "cartographic", "map", "identity", "longitude", "latitude", "height", "x", "y", "z", "toCartographicFromRadians", "config", "_cartographicRadians", "toDegrees", "scratchVector", "Vector3", "scaleToGeodeticSurfaceIntersection", "scaleToGeodeticSurfaceGradient", "cartesian", "ellipsoid", "result", "oneOverRadii", "oneOverRadiiSquared", "centerToleranceSquared", "from", "positionX", "x", "positionY", "y", "positionZ", "z", "oneOverRadiiX", "oneOverRadiiY", "oneOverRadiiZ", "x2", "y2", "z2", "squaredNorm", "ratio", "Math", "sqrt", "Number", "isFinite", "undefined", "intersection", "copy", "scale", "to", "oneOverRadiiSquaredX", "oneOverRadiiSquaredY", "oneOverRadiiSquaredZ", "gradient", "set", "lambda", "len", "correction", "xMultiplier", "yMultiplier", "zMultiplier", "func", "xMultiplier2", "yMultiplier2", "zMultiplier2", "xMultiplier3", "yMultiplier3", "zMultiplier3", "denominator", "derivative", "abs", "_MathUtils", "EPSILON12", "EPSILON14", "scratchOrigin", "Vector3", "VECTOR_PRODUCT_LOCAL_FRAME", "up", "south", "north", "west", "east", "down", "degeneratePositionLocalFrame", "scratchAxisVectors", "scratchVector1", "scratchVector2", "scratchVector3", "ellipsoid", "firstAxis", "secondAxis", "thirdAxis", "cartesianOrigin", "result", "thirdAxisInferred", "assert", "firstAxisVector", "secondAxisVector", "thirdAxisVector", "origin", "copy", "atPole", "equalsEpsilon", "x", "y", "sign", "Math", "z", "fromArray", "scale", "set", "normalize", "geodeticSurfaceNormal", "cross", "scratchVector", "Vector3", "scratchNormal", "scratchK", "scratchPosition", "scratchHeight", "scratchCartesian", "Ellipsoid", "constructor", "x", "y", "z", "_MathUtils", "EPSILON1", "assert", "radii", "Vector3", "radiiSquared", "radiiToTheFourth", "oneOverRadii", "oneOverRadiiSquared", "minimumRadius", "Math", "min", "maximumRadius", "max", "squaredXOverSquaredZ", "Object", "freeze", "equals", "right", "Boolean", "toString", "cartographicToCartesian", "cartographic", "result", "normal", "scratchNormal", "k", "scratchK", "height", "geodeticSurfaceNormalCartographic", "copy", "scale", "gamma", "sqrt", "dot", "add", "to", "cartesianToCartographic", "cartesian", "scratchCartesian", "from", "point", "scaleToGeodeticSurface", "scratchPosition", "undefined", "geodeticSurfaceNormal", "h", "scratchHeight", "subtract", "longitude", "atan2", "latitude", "asin", "sign", "length", "toCartographicFromRadians", "eastNorthUpToFixedFrame", "origin", "Matrix4", "localFrameToFixedFrame", "firstAxis", "secondAxis", "thirdAxis", "geocentricSurfaceNormal", "scratchVector", "normalize", "cartographicVectorRadians", "fromCartographicToRadians", "cosLatitude", "cos", "set", "sin", "scaleToGeocentricSurface", "positionX", "positionY", "positionZ", "beta", "multiplyScalar", "transformPositionToScaledSpace", "position", "transformPositionFromScaledSpace", "getSurfaceNormalIntersectionWithZAxis", "buffer", "EPSILON15", "abs", "WGS84_RADIUS_X", "WGS84_RADIUS_Y", "WGS84_RADIUS_Z", "DoublyLinkedListNode", "constructor", "item", "previous", "next", "DoublyLinkedList", "length", "_length", "add", "item", "node", "DoublyLinkedListNode", "tail", "next", "head", "remove", "previous", "splice", "nextNode", "_insert", "oldNodeNext", "defined", "x", "undefined", "TilesetCache", "constructor", "_list", "DoublyLinkedList", "_sentinel", "add", "_trimTiles", "reset", "splice", "tail", "touch", "tile", "node", "_cacheNode", "tileset", "addCallback", "unloadTile", "unloadCallback", "remove", "unloadTiles", "trimTiles", "list", "maximumMemoryUsageInBytes", "maximumMemoryUsage", "sentinel", "head", "gpuMemoryUsageInBytes", "item", "next", "trim", "calculateTransformProps", "tileHeader", "tile", "assert", "rtcCenter", "gltfUpAxis", "computedTransform", "boundingVolume", "center", "modelMatrix", "Matrix4", "translate", "rotationY", "rotateX", "Math", "PI", "multiplyRight", "rotationX", "rotateY", "isQuantized", "quantizedVolumeOffset", "scale", "quantizedVolumeScale", "cartesianOrigin", "Vector3", "cartesianModelMatrix", "cartographicOrigin", "Ellipsoid", "WGS84", "cartesianToCartographic", "fromFixedFrameMatrix", "eastNorthUpToFixedFrame", "toFixedFrameMatrix", "invert", "cartographicModelMatrix", "coordinateSystem", "INTERSECTION", "OUTSIDE", "INTERSECTING", "INSIDE", "scratchVector", "Vector3", "scratchNormal", "AxisAlignedBoundingBox", "constructor", "minimum", "maximum", "center", "copy", "add", "scale", "halfDiagonal", "subtract", "clone", "equals", "right", "Boolean", "transform", "transformAsPoint", "intersectPlane", "plane", "normal", "from", "e", "x", "Math", "abs", "y", "z", "s", "dot", "distance", "INTERSECTION", "INSIDE", "OUTSIDE", "INTERSECTING", "distanceTo", "point", "sqrt", "distanceSquaredTo", "offset", "distanceSquared", "d", "scratchVector", "Vector3", "scratchVector2", "BoundingSphere", "constructor", "center", "radius", "fromCenterRadius", "from", "fromCornerPoints", "corner", "oppositeCorner", "add", "scale", "distance", "equals", "right", "Boolean", "clone", "union", "boundingSphere", "leftCenter", "leftRadius", "rightCenter", "rightRadius", "toRightCenter", "copy", "subtract", "centerSeparation", "magnitude", "halfDistanceBetweenTangentPoints", "expand", "point", "scratchPoint", "transform", "getScaling", "Math", "max", "distanceSquaredTo", "d", "distanceTo", "delta", "len", "intersectPlane", "plane", "normal", "distanceToPlane", "dot", "INTERSECTION", "OUTSIDE", "INTERSECTING", "INSIDE", "scratchVector3", "Vector3", "scratchOffset", "scratchVectorU", "scratchVectorV", "scratchVectorW", "scratchCorner", "scratchToCenter", "MATRIX3", "COLUMN0ROW0", "COLUMN0ROW1", "COLUMN0ROW2", "COLUMN1ROW0", "COLUMN1ROW1", "COLUMN1ROW2", "COLUMN2ROW0", "COLUMN2ROW1", "COLUMN2ROW2", "OrientedBoundingBox", "constructor", "center", "halfAxes", "from", "Matrix3", "halfSize", "xAxis", "getColumn", "yAxis", "zAxis", "len", "quaternion", "normXAxis", "normalize", "normYAxis", "normZAxis", "Quaternion", "fromMatrix3", "fromCenterHalfSizeQuaternion", "quaternionObject", "directionsMatrix", "fromQuaternion", "clone", "equals", "right", "Boolean", "getBoundingSphere", "result", "BoundingSphere", "u", "v", "w", "cornerVector", "copy", "add", "radius", "magnitude", "intersectPlane", "plane", "normal", "normalX", "x", "normalY", "y", "normalZ", "z", "radEffective", "Math", "abs", "distanceToPlane", "dot", "distance", "INTERSECTION", "OUTSIDE", "INSIDE", "INTERSECTING", "distanceTo", "point", "sqrt", "distanceSquaredTo", "offset", "subtract", "uHalf", "vHalf", "wHalf", "distanceSquared", "d", "computePlaneDistances", "position", "direction", "minDist", "Number", "POSITIVE_INFINITY", "maxDist", "NEGATIVE_INFINITY", "corner", "toCenter", "mag", "min", "max", "transform", "transformation", "transformAsPoint", "getTransform", "Error", "scratchPosition", "Vector3", "scratchNormal", "Plane", "constructor", "normal", "distance", "fromNormalDistance", "assert", "Number", "isFinite", "from", "normalize", "fromPointNormal", "point", "dot", "fromCoefficients", "a", "b", "c", "d", "set", "equals", "len", "clone", "right", "getPointDistance", "transform", "matrix4", "copy", "transformAsVector", "scale", "projectPointOntoPlane", "result", "pointDistance", "scaledNormal", "subtract", "to", "faces", "Vector3", "scratchPlaneCenter", "scratchPlaneNormal", "scratchPlane", "Plane", "CullingVolume", "constructor", "planes", "fromBoundingSphere", "boundingSphere", "length", "center", "radius", "planeIndex", "faceNormal", "plane0", "plane1", "plane0Center", "copy", "scale", "add", "plane0Distance", "dot", "fromPointNormal", "plane1Center", "negatedFaceNormal", "negate", "plane1Distance", "computeVisibility", "boundingVolume", "intersect", "INTERSECTION", "INSIDE", "plane", "result", "intersectPlane", "OUTSIDE", "INTERSECTING", "computeVisibilityWithPlaneMask", "parentPlaneMask", "assert", "Number", "isFinite", "MASK_OUTSIDE", "MASK_INSIDE", "mask", "k", "flag", "scratchPlaneUpVector", "Vector3", "scratchPlaneRightVector", "scratchPlaneNearCenter", "scratchPlaneFarCenter", "scratchPlaneNormal", "fromPointsXMin", "Vector3", "fromPointsYMin", "fromPointsZMin", "fromPointsXMax", "fromPointsYMax", "fromPointsZMax", "fromPointsCurrentPos", "fromPointsScratch", "fromPointsRitterCenter", "fromPointsMinBoxPt", "fromPointsMaxBoxPt", "fromPointsNaiveCenterScratch", "volumeConstant", "Math", "PI", "scratchMatrix", "Matrix3", "scratchUnitary", "scratchDiagonal", "jMatrix", "jMatrixTranspose", "matrix", "result", "EIGEN_TOLERANCE", "_MathUtils", "EPSILON20", "EIGEN_MAX_SWEEPS", "count", "sweep", "unitaryMatrix", "diagonalMatrix", "identity", "copy", "epsilon", "computeFrobeniusNorm", "offDiagonalFrobeniusNorm", "shurDecomposition", "transpose", "multiplyRight", "multiplyLeft", "unitary", "toTarget", "diagonal", "norm", "i", "temp", "Math", "sqrt", "rowVal", "colVal", "getElementIndex", "tolerance", "EPSILON15", "maxDiagonal", "rotAxis", "abs", "p", "q", "c", "s", "qq", "pp", "qp", "tau", "t", "IDENTITY", "to", "scratchVector2", "Vector3", "scratchVector3", "scratchVector4", "scratchVector5", "scratchVector6", "scratchCovarianceResult", "Matrix3", "scratchEigenResult", "diagonal", "unitary", "makeOrientedBoundingBoxFromPoints", "positions", "result", "OrientedBoundingBox", "length", "halfAxes", "center", "meanPoint", "position", "add", "invLength", "multiplyByScalar", "exx", "exy", "exz", "eyy", "eyz", "ezz", "p", "copy", "subtract", "x", "y", "z", "covarianceMatrix", "computeEigenDecomposition", "rotation", "v1", "getColumn", "v2", "v3", "u1", "Number", "MAX_VALUE", "u2", "u3", "l1", "l2", "l3", "Math", "max", "dot", "min", "scale", "set", "scaleMatrix", "multiplyRight", "scratchVector", "Vector3", "scratchPosition", "cullingVolume", "CullingVolume", "Plane", "getFrameState", "viewport", "frameNumber", "cameraDirection", "cameraUp", "height", "metersPerUnit", "distanceScales", "viewportCenterCartesian", "worldToCartesian", "center", "enuToFixedTransform", "Ellipsoid", "WGS84", "eastNorthUpToFixedFrame", "cameraPositionCartographic", "unprojectPosition", "cameraPosition", "cameraPositionCartesian", "cartographicToCartesian", "cameraDirectionCartesian", "transformAsVector", "scale", "normalize", "cameraUpCartesian", "commonSpacePlanesToWGS84", "ViewportClass", "constructor", "longitude", "latitude", "width", "bearing", "zoom", "topDownViewport", "pitch", "camera", "position", "direction", "up", "sseDenominator", "limitSelectedTiles", "tiles", "frameState", "maximumTilesSelected", "length", "tuples", "viewportLongitude", "viewportLatitude", "index", "tile", "entries", "header", "mbs", "deltaLon", "Math", "abs", "deltaLat", "distance", "sqrt", "push", "tuplesSorted", "sort", "a", "b", "selectedTiles", "i", "unselectedTiles", "frustumPlanes", "getFrustumPlanes", "nearCenterCommon", "closestPointOnPlane", "near", "nearCenterCartesian", "cameraCartesian", "planes", "fromPointNormal", "copy", "subtract", "dir", "plane", "posCommon", "cartesianPos", "refPoint", "out", "distanceToRef", "normal", "dot", "add", "point", "cartographicPos", "WGS84_RADIUS_X", "WGS84_RADIUS_Y", "WGS84_RADIUS_Z", "scratchVector", "Vector3", "getZoomFromBoundingVolume", "boundingVolume", "cartorgraphicCenter", "OrientedBoundingBox", "halfAxes", "obbSize", "getObbSize", "Math", "log2", "BoundingSphere", "radius", "width", "height", "zoomX", "zoomY", "getZoomFromFullExtent", "fullExtent", "cartesianCenter", "extentVertex", "Ellipsoid", "WGS84", "cartographicToCartesian", "xmax", "ymax", "zmax", "extentSize", "sqrt", "pow", "getZoomFromExtent", "extent", "xmin", "ymin", "zmin", "getColumn", "axeY", "axeZ", "farthestVertex", "add", "size", "len", "TILE_CONTENT_STATE", "UNLOADED", "LOADING", "PROCESSING", "READY", "EXPIRED", "FAILED", "TILE_REFINEMENT", "ADD", "REPLACE", "TILE_TYPE", "EMPTY", "SCENEGRAPH", "POINTCLOUD", "MESH", "TILESET_TYPE", "I3S", "TILES3D", "LOD_METRIC_TYPE", "GEOMETRIC_ERROR", "MAX_SCREEN_THRESHOLD", "TILE3D_OPTIMIZATION_HINT", "NOT_COMPUTED", "USE_OPTIMIZATION", "SKIP_OPTIMIZATION", "defined", "x", "undefined", "scratchScale", "Vector3", "scratchNorthWest", "scratchSouthEast", "createBoundingVolume", "boundingVolumeHeader", "transform", "result", "assert", "box", "createBox", "region", "west", "south", "east", "north", "minHeight", "maxHeight", "northWest", "Ellipsoid", "WGS84", "cartographicToCartesian", "degrees", "southEast", "centerInCartesian", "addVectors", "multiplyScalar", "radius", "subVectors", "len", "createSphere", "Matrix4", "sphere", "Error", "center", "origin", "length", "halfSize", "slice", "quaternion", "Quaternion", "fromArray", "y", "z", "transformByQuaternion", "scale", "toArray", "xAxis", "transformAsVector", "yAxis", "zAxis", "halfAxes", "Matrix3", "OrientedBoundingBox", "getScale", "uniformScale", "Math", "max", "BoundingSphere", "scratchPositionNormal", "Vector3", "scratchCartographic", "scratchMatrix", "Matrix4", "scratchCenter", "scratchPosition", "scratchDirection", "fog", "distanceToCamera", "density", "scalar", "Math", "exp", "getDynamicScreenSpaceError", "tileset", "dynamicScreenSpaceError", "dynamicScreenSpaceErrorComputedDensity", "factor", "dynamicScreenSpaceErrorFactor", "dynamicError", "getTiles3DScreenSpaceError", "tile", "frameState", "useParentLodMetric", "parentLodMetricValue", "parent", "lodMetricValue", "distance", "max", "_distanceToCamera", "height", "sseDenominator", "viewDistanceScale", "options", "error", "cameraPositionCartesian", "Vector3", "toEye", "cameraPositionEnu", "extraVertexEnu", "projectedOriginVector", "enuToCartesianMatrix", "Matrix4", "cartesianToEnuMatrix", "getLodStatus", "tile", "frameState", "lodMetricValue", "isNaN", "screenSize", "getProjectedRadius", "header", "children", "topDownViewport", "viewport", "mbsLat", "mbs", "mbsLon", "mbsZ", "mbsR", "mbsCenterCartesian", "boundingVolume", "center", "cameraPositionCartographic", "unprojectPosition", "cameraPosition", "Ellipsoid", "WGS84", "cartographicToCartesian", "copy", "subtract", "normalize", "eastNorthUpToFixedFrame", "invert", "transform", "projection", "Math", "sqrt", "extraZ", "extraVertexCartesian", "extraVectorCartesian", "radiusVector", "cross", "scale", "sphereMbsBorderVertexCartesian", "add", "sphereMbsBorderVertexCartographic", "cartesianToCartographic", "projectedOrigin", "project", "projectedMbsBorderVertex", "projectedRadius", "magnitude", "get3dTilesOptions", "tileset", "assetGltfUpAxis", "asset", "gltfUpAxis", "ManagedArray", "constructor", "length", "Map", "_array", "Array", "_length", "values", "get", "index", "assert", "set", "element", "_map", "has", "delete", "splice", "peek", "push", "pop", "reserve", "resize", "trim", "undefined", "reset", "find", "target", "DEFAULT_PROPS", "loadSiblings", "skipLevelOfDetail", "maximumScreenSpaceError", "updateTransforms", "onTraversalEnd", "viewportTraversersMap", "basePath", "TilesetTraverser", "traversalFinished", "frameState", "constructor", "options", "Date", "getTime", "_traversalStack", "ManagedArray", "_emptyTraversalStack", "_frameNumber", "root", "selectedTiles", "requestedTiles", "emptyTiles", "traverse", "reset", "updateTile", "frameNumber", "executeTraversal", "stack", "_selectionDepth", "push", "length", "tile", "pop", "shouldRefine", "canTraverse", "updateChildTiles", "updateAndPushChildren", "hasRenderContent", "parent", "parentRefines", "Boolean", "_shouldRefine", "stoppedRefining", "id", "loadTile", "selectTile", "refine", "TILE_REFINEMENT", "ADD", "REPLACE", "touchTile", "newTime", "lastUpdate", "updateDebounceTime", "children", "child", "depth", "sort", "compareDistanceToCamera", "bind", "checkRefines", "hasVisibleChild", "refines", "isVisibleAndInRequestVolume", "find", "delete", "childRefines", "_inRequestVolume", "executeEmptyTraversal", "contentAvailable", "updateTileVisibility", "shouldSelectTile", "_selectedFrame", "shouldLoadTile", "_requestedFrame", "_priority", "_getPriority", "tileset", "_cache", "touch", "_touchedFrame", "useParentMetric", "ignoreVisibility", "hasChildren", "hasTilesetContent", "contentExpired", "hasUnloadedContent", "screenSpaceError", "_screenSpaceError", "getScreenSpaceError", "viewportIds", "key", "value", "viewport", "updateVisibility", "b", "a", "_distanceToCamera", "anyChildrenVisible", "anyVisible", "allDescendantsLoaded", "scratchVector", "Vector3", "defined", "x", "undefined", "Tile3D", "constructor", "tileset", "header", "parentHeader", "extendedId", "id", "url", "parent", "refine", "_getRefine", "type", "contentUrl", "lodMetricType", "lodMetricValue", "boundingVolume", "content", "contentState", "TILE_CONTENT_STATE", "UNLOADED", "gpuMemoryUsageInBytes", "children", "hasEmptyContent", "hasTilesetContent", "depth", "viewportIds", "userData", "extensions", "_priority", "_touchedFrame", "_visitedFrame", "_selectedFrame", "_requestedFrame", "_screenSpaceError", "_cacheNode", "_frameNumber", "traverser", "TilesetTraverser", "_shouldRefine", "_distanceToCamera", "_centerZDepth", "_visible", "_inRequestVolume", "_stackLength", "_selectionDepth", "_initialTransform", "Matrix4", "transform", "_initializeLodMetric", "_initializeTransforms", "_initializeBoundingVolumes", "_initializeContent", "_initializeRenderingState", "_lodJudge", "_expireDate", "_expiredContent", "implicitTiling", "Object", "seal", "destroy", "isDestroyed", "selected", "isVisible", "isVisibleAndInRequestVolume", "hasRenderContent", "hasChildren", "length", "contentReady", "READY", "contentAvailable", "Boolean", "contentFailed", "hasUnloadedContent", "contentUnloaded", "contentExpired", "EXPIRED", "FAILED", "distanceToCamera", "screenSpaceError", "getScreenSpaceError", "frameState", "useParentLodMetric", "TILESET_TYPE", "I3S", "getProjectedRadius", "TILES3D", "getTiles3DScreenSpaceError", "Error", "unselect", "_getPriority", "_traverser", "skipLevelOfDetail", "options", "maySkipTile", "TILE_REFINEMENT", "ADD", "useParentScreenSpaceError", "rootScreenSpaceError", "root", "Math", "max", "loadContent", "expired", "LOADING", "requestToken", "_requestScheduler", "scheduleRequest", "bind", "getTileUrl", "loader", "loadOptions", "isTileset", "_getLoaderSpecificOptions", "load", "contentLoader", "_isTileset", "_initializeTileHeaders", "_onContentLoaded", "error", "done", "unloadContent", "updateVisibility", "frameNumber", "parentVisibilityPlaneMask", "_visibilityPlaneMask", "CullingVolume", "MASK_INDETERMINATE", "updateTransforms", "parentTransform", "computedTransform", "modelMatrix", "_updateTransform", "distanceToTile", "visibility", "MASK_OUTSIDE", "insideViewerRequestVolume", "cullingVolume", "computeVisibilityWithPlaneMask", "contentVisibility", "sqrt", "distanceSquaredTo", "camera", "position", "cameraSpaceZDepth", "subVectors", "center", "direction", "dot", "viewerRequestVolume", "_viewerRequestVolume", "updateExpiration", "now", "Date", "lessThan", "extras", "console", "warn", "tileHeader", "clone", "multiplyRight", "parentInitialTransform", "_contentBoundingVolume", "_updateBoundingVolume", "_tileset", "_tile", "level", "REPLACE", "indexOf", "disableSkipLevelOfDetail", "createBoundingVolume", "didTransformChange", "equals", "loaderId", "i3s", "_tileOptions", "attributeUrls", "textureUrl", "textureFormat", "textureLoaderOptions", "materialDefinition", "isDracoGeometry", "mbs", "_tilesetOptions", "store", "attributeStorageInfo", "fields", "isTileHeader", "get3dTilesOptions", "Tileset3DTraverser", "TilesetTraverser", "compareDistanceToCamera", "a", "b", "_distanceToCamera", "_centerZDepth", "updateTileVisibility", "tile", "frameState", "isVisibleAndInRequestVolume", "hasChildren", "children", "length", "hasTilesetContent", "firstChild", "_visible", "meetsScreenSpaceErrorEarly", "replace", "refine", "TILE_REFINEMENT", "REPLACE", "useOptimization", "_optimChildrenWithinParent", "TILE3D_OPTIMIZATION_HINT", "USE_OPTIMIZATION", "anyChildrenVisible", "parent", "ADD", "shouldRefine", "I3SPendingTilesRegister", "Map", "register", "viewportId", "frameNumber", "viewportMap", "frameNumberMap", "get", "oldCount", "set", "deregister", "isZero", "count", "STATUS", "REQUESTED", "COMPLETED", "ERROR", "I3STileManager", "constructor", "I3SPendingTilesRegister", "_statusMap", "add", "request", "key", "callback", "frameState", "frameNumber", "viewport", "id", "status", "pendingTilesRegister", "register", "then", "data", "actualFrameNumber", "deregister", "catch", "error", "update", "newFrameNumber", "newViewportId", "find", "hasPendingTiles", "viewportId", "isZero", "I3STilesetTraverser", "TilesetTraverser", "constructor", "options", "_tileManager", "I3STileManager", "traversalFinished", "frameState", "hasPendingTiles", "viewport", "id", "_frameNumber", "shouldRefine", "tile", "_lodJudge", "getLodStatus", "updateChildTiles", "children", "header", "childTiles", "tileset", "child", "extendedId", "childTile", "find", "t", "request", "_loadTile", "cachedRequest", "nodePages", "nodePagesTile", "formTileFromNodePages", "add", "_onTileLoad", "update", "updateTile", "nodeId", "loader", "nodeUrl", "getTileUrl", "url", "loadOptions", "i3s", "isTileHeader", "load", "Tile3D", "push", "frameNumber", "Date", "getTime", "lastUpdate", "updateDebounceTime", "executeTraversal", "DEFAULT_PROPS", "description", "ellipsoid", "Ellipsoid", "WGS84", "modelMatrix", "Matrix4", "throttleRequests", "maxRequests", "maximumMemoryUsage", "maximumTilesSelected", "debounceTime", "onTileLoad", "onTileUnload", "onTileError", "onTraversalComplete", "selectedTiles", "contentLoader", "undefined", "viewDistanceScale", "maximumScreenSpaceError", "loadTiles", "updateTransforms", "viewportTraversersMap", "loadOptions", "fetch", "attributions", "basePath", "i3s", "TILES_TOTAL", "TILES_IN_MEMORY", "TILES_IN_VIEW", "TILES_RENDERABLE", "TILES_LOADED", "TILES_LOADING", "TILES_UNLOADED", "TILES_LOAD_FAILED", "POINTS_COUNT", "TILES_GPU_MEMORY", "Tileset3D", "constructor", "json", "options", "draco", "meshopt", "dds", "ktx2", "assert", "tileset", "loader", "type", "url", "path", "dirname", "lodMetricType", "lodMetricValue", "refine", "root", "roots", "cartographicCenter", "cartesianCenter", "zoom", "boundingVolume", "traverseCounter", "geometricError", "_traverser", "_initializeTraverser", "_cache", "TilesetCache", "_requestScheduler", "RequestScheduler", "_frameNumber", "_pendingCount", "_tiles", "_emptyTiles", "_requestedTiles", "frameStateData", "lastUpdatedVieports", "_queryParams", "_queryParamsString", "gpuMemoryUsageInBytes", "stats", "Stats", "id", "_initializeStats", "_extensionsUsed", "dynamicScreenSpaceErrorComputedDensity", "extras", "asset", "credits", "tilesetInitializationPromise", "_initializeTileSet", "destroy", "_destroy", "isLoaded", "length", "tiles", "Object", "values", "frameNumber", "queryParams", "getQueryParamString", "setProps", "props", "setOptions", "getTileUrl", "tilePath", "isDataUrl", "startsWith", "hasExtension", "extensionName", "Boolean", "indexOf", "update", "viewports", "then", "doUpdate", "selectTiles", "updatePromise", "Promise", "resolve", "setTimeout", "preparedViewports", "Array", "reset", "viewportsToTraverse", "viewport", "_needTraverse", "push", "_initializeTileHeaders", "includes", "frameState", "getFrameState", "traverse", "viewportId", "traverserId", "_onTraversalEnd", "currentFrameStateData", "filteredSelectedTiles", "unselectedTiles", "limitSelectedTiles", "tile", "unselect", "requestedTiles", "emptyTiles", "_updateTiles", "frameStateKey", "frameStateDataValue", "concat", "_loadTiles", "_unloadTiles", "_updateStats", "_tilesChanged", "oldSelectedTiles", "set1", "Set", "map", "t", "set2", "changed", "filter", "x", "has", "contentUnloaded", "_loadTile", "unloadTiles", "_unloadTile", "tilesRenderable", "pointsRenderable", "contentAvailable", "content", "pointCount", "vertexCount", "get", "count", "tilesetJson", "TILESET_TYPE", "I3S", "calculateViewPropsI3S", "TILES3D", "_initializeTiles3DTileset", "calculateViewPropsTiles3D", "_initializeI3STileset", "fullExtent", "xmin", "xmax", "ymin", "ymax", "zmin", "zmax", "Vector3", "cartographicToCartesian", "getZoomFromFullExtent", "extent", "store", "getZoomFromExtent", "console", "warn", "center", "cartesianToCartographic", "radii", "getZoomFromBoundingVolume", "parentTileHeader", "rootTile", "Tile3D", "children", "depth", "stack", "pop", "incrementCount", "header", "childHeader", "childTile", "TraverserClass", "Tileset3DTraverser", "I3STilesetTraverser", "TilesetTraverser", "onTraversalEnd", "bind", "_destroyTileHeaders", "parentTile", "_destroySubtree", "loaded", "_onStartTileLoading", "loadContent", "error", "_onTileLoadError", "_onEndTileLoading", "_onTileLoad", "message", "toString", "nodesInNodePages", "nodePagesTile", "addCount", "calculateTransformProps", "updateContentTypes", "_addTileToCache", "isDracoGeometry", "contentFormats", "textureFormat", "extensionsRemoved", "gltf", "decrementCount", "add", "_updateCacheStats", "byteLength", "unloadContent", "child", "_destroyTile", "unloadTile", "Error", "version", "v", "tilesetVersion", "properties", "extensionsUsed", "token", "queryParamStrings", "key", "keys", "join", "VERSION", "TILE3D_TYPE", "COMPOSITE", "POINT_CLOUD", "BATCHED_3D_MODEL", "INSTANCED_3D_MODEL", "GEOMETRY", "VECTOR", "GLTF", "TILE3D_TYPES", "Object", "keys", "MAGIC_ARRAY", "BATCHED_MODEL", "INSTANCED_MODEL", "getStringFromArrayBuffer", "arrayBuffer", "byteOffset", "byteLength", "assert", "ArrayBuffer", "textDecoder", "TextDecoder", "typedArray", "Uint8Array", "string", "decode", "getMagicString", "arrayBuffer", "byteOffset", "dataView", "DataView", "String", "fromCharCode", "getUint8", "VERSION", "DEFAULT_DRACO_OPTIONS", "draco", "decoderType", "WebAssembly", "libraryPath", "extraAttributes", "attributeNameEntry", "undefined", "DracoLoader", "name", "id", "isBrowser", "module", "shapes", "version", "VERSION", "worker", "extensions", "mimeTypes", "binary", "tests", "options", "DEFAULT_ROW_COUNT", "RowTableBatchAggregator", "constructor", "schema", "options", "Array", "isArray", "_headers", "key", "index", "name", "rowCount", "length", "addArrayRow", "row", "cursor", "Number", "isFinite", "rows", "addObjectRow", "getBatch", "slice", "batch", "shape", "batchType", "data", "convertToObjectRow", "arrayRow", "headers", "Error", "objectRow", "i", "length", "convertToArrayRow", "Array", "DEFAULT_ROW_COUNT", "RowTableBatchAggregator", "constructor", "schema", "options", "Array", "isArray", "_headers", "key", "index", "name", "rowCount", "length", "addArrayRow", "row", "cursor", "Number", "isFinite", "shape", "rowObject", "convertToObjectRow", "addObjectRow", "arrayRows", "rowArray", "convertToArrayRow", "objectRows", "getBatch", "rows", "slice", "batchType", "data", "DEFAULT_ROW_COUNT", "ColumnarTableBatchAggregator", "constructor", "schema", "options", "_reallocateColumns", "rowCount", "length", "addArrayRow", "row", "i", "fieldName", "columns", "addObjectRow", "getBatch", "_pruneColumns", "Array", "isArray", "field", "name", "index", "batch", "shape", "batchType", "data", "allocated", "ArrayType", "type", "Float32Array", "oldColumn", "ArrayBuffer", "isView", "typedArray", "set", "columnName", "column", "Object", "entries", "slice", "DEFAULT_OPTIONS", "shape", "batchSize", "batchDebounceMs", "limit", "_limitMB", "ERR_MESSAGE", "TableBatchBuilder", "constructor", "schema", "options", "Date", "now", "limitReached", "Boolean", "totalLength", "totalBytes", "addRow", "row", "rowBytes", "_estimateRowMB", "Array", "isArray", "addArrayRow", "addObjectRow", "aggregator", "TableBatchType", "_getTableBatchType", "chunkComplete", "chunk", "ArrayBuffer", "bytesUsed", "byteLength", "length", "isChunkComplete", "getFullBatch", "_isFull", "_getBatch", "getFinalBatch", "Object", "keys", "rowCount", "lastBatchEmittedMs", "normalizedBatch", "getBatch", "count", "batchCount", "assign", "BaseTableBatchAggregator", "RowTableBatchAggregator", "ColumnarTableBatchAggregator", "ArrowBatch", "Error", "getMeshBoundingBox", "attributes", "minX", "Infinity", "minY", "minZ", "maxX", "maxY", "maxZ", "positions", "POSITION", "value", "len", "length", "i", "x", "y", "z", "assert", "condition", "message", "Error", "Schema", "constructor", "fields", "metadata", "assert", "Array", "isArray", "checkNames", "Map", "compareTo", "other", "length", "i", "select", "nameMap", "Object", "create", "columnNames", "name", "selectedFields", "filter", "field", "selectAt", "columnIndices", "map", "index", "Boolean", "assign", "schemaOrFields", "otherSchema", "mergeMaps", "fieldMap", "mergedFields", "values", "usedNames", "console", "warn", "m1", "m2", "Field", "constructor", "name", "type", "nullable", "metadata", "Map", "typeId", "clone", "compareTo", "other", "toString", "Type", "DataType", "isNull", "x", "typeId", "Type", "Null", "isInt", "Int", "isFloat", "Float", "isBinary", "Binary", "isUtf8", "Utf8", "isBool", "Bool", "isDecimal", "Decimal", "isDate", "Date", "isTime", "Time", "isTimestamp", "Timestamp", "isInterval", "Interval", "isList", "List", "isStruct", "Struct", "isUnion", "Union", "isFixedSizeBinary", "FixedSizeBinary", "isFixedSizeList", "FixedSizeList", "isMap", "Map", "isDictionary", "Dictionary", "NONE", "compareTo", "other", "Symbol", "toStringTag", "toString", "constructor", "isSigned", "bitWidth", "Int8", "Int16", "Int32", "Uint8", "Int", "constructor", "Uint16", "Uint32", "Precision", "HALF", "SINGLE", "DOUBLE", "Symbol", "toStringTag", "Float", "DataType", "constructor", "precision", "typeId", "Type", "toString", "Float32", "Float", "constructor", "Precision", "SINGLE", "Float64", "DOUBLE", "Binary", "DataType", "typeId", "Type", "toString", "Symbol", "toStringTag", "Utf8", "DateUnit", "DAY", "MILLISECOND", "Date", "unit", "TimeUnit", "SECOND", "MILLISECOND", "MICROSECOND", "NANOSECOND", "Symbol", "toStringTag", "Time", "DataType", "constructor", "unit", "bitWidth", "typeId", "Type", "toString", "Symbol", "toStringTag", "Timestamp", "DataType", "constructor", "unit", "timezone", "typeId", "Type", "toString", "TimeUnit", "IntervalUnit", "DAY_TIME", "YEAR_MONTH", "Symbol", "toStringTag", "Interval", "DataType", "constructor", "unit", "typeId", "Type", "toString", "Symbol", "toStringTag", "FixedSizeList", "DataType", "constructor", "listSize", "child", "children", "typeId", "Type", "valueType", "type", "valueField", "toString", "Struct", "map", "f", "name", "join", "getArrowTypeFromTypedArray", "array", "constructor", "Int8Array", "Int8", "Uint8Array", "Uint8", "Int16Array", "Int16", "Uint16Array", "Uint16", "Int32Array", "Int32", "Uint32Array", "Uint32", "Float32Array", "Float32", "Float64Array", "Float64", "Error", "deduceMeshField", "attributeName", "attribute", "optionalMetadata", "type", "getArrowTypeFromTypedArray", "value", "metadata", "makeMeshAttributeMetadata", "field", "Field", "FixedSizeList", "size", "makeMeshAttributeMetadata", "attribute", "result", "Map", "set", "byteOffset", "toString", "byteStride", "normalized", "ArrayQueue", "Array", "enqueue", "value", "push", "dequeue", "shift", "Symbol", "asyncIterator", "AsyncQueue", "constructor", "_values", "_settlers", "_closed", "close", "length", "resolve", "done", "Error", "settler", "reject", "next", "Promise", "getDracoSchema", "attributes", "loaderData", "indices", "metadataMap", "makeMetadata", "metadata", "fields", "namedLoaderDataAttributes", "transformAttributesLoaderData", "attributeName", "attribute", "field", "getArrowFieldFromAttribute", "push", "indicesField", "Schema", "result", "key", "dracoAttribute", "name", "undefined", "deduceMeshField", "Map", "set", "JSON", "stringify", "DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP", "POSITION", "NORMAL", "COLOR", "TEX_COORD", "DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP", "Int8Array", "Uint8Array", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "INDEX_ITEM_SIZE", "DracoParser", "constructor", "draco", "decoder", "Decoder", "metadataQuerier", "MetadataQuerier", "destroy", "parseSync", "arrayBuffer", "options", "buffer", "DecoderBuffer", "Init", "byteLength", "_disableAttributeTransforms", "geometry_type", "GetEncodedGeometryType", "dracoGeometry", "TRIANGULAR_MESH", "Mesh", "PointCloud", "dracoStatus", "DecodeBufferToMesh", "POINT_CLOUD", "DecodeBufferToPointCloud", "Error", "ok", "ptr", "message", "error_msg", "loaderData", "_getDracoLoaderData", "geometry", "_getMeshData", "boundingBox", "getMeshBoundingBox", "attributes", "schema", "getDracoSchema", "indices", "data", "loader", "header", "vertexCount", "num_points", "metadata", "_getTopLevelMetadata", "_getDracoAttributes", "num_attributes", "num_faces", "dracoAttributes", "attributeId", "dracoAttribute", "GetAttribute", "_getAttributeMetadata", "unique_id", "attribute_type", "data_type", "num_components", "byte_offset", "byte_stride", "normalized", "attribute_index", "quantization", "_getQuantizationTransform", "quantization_transform", "octahedron", "_getOctahedronTransform", "octahedron_transform", "_getMeshAttributes", "positionAttribute", "topology", "mode", "value", "_getTriangleStripIndices", "size", "_getTriangleListIndices", "loaderAttribute", "Object", "values", "attributeName", "_deduceAttributeName", "name", "_getAttributeValues", "byteOffset", "byteStride", "numFaces", "numIndices", "_malloc", "GetTrianglesUInt32Array", "HEAPF32", "slice", "_free", "dracoArray", "DracoInt32Array", "GetTriangleStripsFromMesh", "getUint32Array", "attribute", "TypedArrayCtor", "numComponents", "numPoints", "numValues", "BYTES_PER_ELEMENT", "dataType", "getDracoDataType", "GetAttributeDataArrayForAllPoints", "uniqueId", "attributeUniqueId", "entries", "extraAttributes", "thisAttributeType", "dracoAttributeConstant", "attributeType", "entryName", "attributeNameEntry", "string", "dracoMetadata", "GetMetadata", "_getDracoMetadata", "GetAttributeMetadata", "result", "numEntries", "NumEntries", "entryIndex", "GetEntryName", "_getDracoMetadataField", "GetIntEntryArray", "intArray", "getInt32Array", "int", "GetIntEntry", "GetStringEntry", "double", "GetDoubleEntry", "quantizedAttributes", "octahedronAttributes", "skipAttributes", "dracoAttributeName", "SkipAttributeTransform", "skip", "map", "type", "includes", "transform", "AttributeQuantizationTransform", "InitFromAttribute", "quantization_bits", "range", "min_values", "i", "min_value", "DT_FLOAT32", "DT_INT8", "DT_INT16", "DT_INT32", "DT_UINT8", "DT_UINT16", "DT_UINT32", "DT_INVALID", "GetValue", "DRACO_DECODER_VERSION", "DRACO_ENCODER_VERSION", "STATIC_DECODER_URL", "DRACO_JS_DECODER_URL", "DRACO_WASM_WRAPPER_URL", "DRACO_WASM_DECODER_URL", "DRACO_ENCODER_URL", "loadDecoderPromise", "loadDracoDecoderModule", "options", "modules", "draco3d", "loadDecoderPromise", "createDecoderModule", "then", "draco", "loadDracoDecoder", "loadDracoDecoder", "options", "DracoDecoderModule", "wasmBinary", "draco", "decoderType", "loadLibrary", "DRACO_JS_DECODER_URL", "Promise", "all", "DRACO_WASM_WRAPPER_URL", "DRACO_WASM_DECODER_URL", "globalThis", "initializeDracoDecoder", "resolve", "onModuleLoaded", "DracoLoader", "DracoWorkerLoader", "parse", "arrayBuffer", "options", "draco", "loadDracoDecoderModule", "dracoParser", "DracoParser", "parseSync", "destroy", "GL_PRIMITIVE_MODE", "POINTS", "LINES", "LINE_LOOP", "LINE_STRIP", "TRIANGLES", "TRIANGLE_STRIP", "TRIANGLE_FAN", "GL_TYPE", "BYTE", "UNSIGNED_BYTE", "SHORT", "UNSIGNED_SHORT", "INT", "UNSIGNED_INT", "FLOAT", "DOUBLE", "GL", "GL_TYPE_TO_ARRAY_TYPE", "GL", "DOUBLE", "Float64Array", "FLOAT", "Float32Array", "UNSIGNED_SHORT", "Uint16Array", "UNSIGNED_INT", "Uint32Array", "UNSIGNED_BYTE", "Uint8Array", "BYTE", "Int8Array", "SHORT", "Int16Array", "INT", "Int32Array", "NAME_TO_GL_TYPE", "ERR_TYPE_CONVERSION", "GLType", "fromTypedArray", "arrayOrType", "ArrayBuffer", "isView", "constructor", "glType", "ArrayType", "Error", "fromName", "name", "getArrayType", "UNSIGNED_SHORT_5_6_5", "UNSIGNED_SHORT_4_4_4_4", "UNSIGNED_SHORT_5_5_5_1", "getByteSize", "BYTES_PER_ELEMENT", "validate", "Boolean", "createTypedArray", "buffer", "byteOffset", "length", "undefined", "byteLength", "assert", "condition", "message", "Error", "decodeRGB565", "rgb565", "target", "r5", "g6", "b5", "RIGHT_SHIFT", "scratchVector2", "Vector2", "scratchVector3", "Vector3", "scratchEncodeVector2", "octEncodeScratch", "uint8ForceArray", "Uint8Array", "fromSNorm", "value", "rangeMaximum", "clamp", "signNotZero", "value", "octDecodeInRange", "x", "y", "rangeMax", "result", "assert", "Error", "fromSNorm", "z", "Math", "abs", "oldVX", "signNotZero", "normalize", "octDecode", "Tile3DFeatureTable", "constructor", "featureTableJson", "featureTableBinary", "json", "buffer", "getExtension", "extensionName", "extensions", "hasProperty", "propertyName", "Boolean", "getGlobalProperty", "componentType", "GL", "UNSIGNED_INT", "componentLength", "jsonValue", "Number", "isFinite", "byteOffset", "_getTypedArrayFromBinary", "getPropertyArray", "GLType", "fromName", "featuresLength", "_getTypedArrayFromArray", "getProperty", "featureId", "result", "typedArray", "i", "count", "cachedTypedArrays", "_cachedTypedArrays", "createTypedArray", "array", "COMPONENTS_PER_ATTRIBUTE", "SCALAR", "VEC2", "VEC3", "VEC4", "MAT2", "MAT3", "MAT4", "UNPACKER", "values", "i", "PACKER", "x", "createTypedArrayFromAccessor", "tile3DAccessor", "buffer", "byteOffset", "length", "componentType", "assert", "type", "GLType", "fromName", "size", "unpacker", "packer", "createTypedArray", "defined", "x", "undefined", "initializeHierarchy", "batchTable", "jsonHeader", "binaryBody", "hierarchy", "getExtension", "legacyHierarchy", "HIERARCHY", "console", "warn", "extensions", "initializeHierarchyValues", "hierarchyJson", "i", "classId", "binaryAccessor", "instancesLength", "classes", "classIds", "parentCounts", "parentIds", "parentIdsLength", "byteOffset", "componentType", "defaultValue", "GL", "UNSIGNED_SHORT", "type", "AttributeType", "SCALAR", "getBinaryAccessor", "createArrayBufferView", "buffer", "parentIndexes", "Uint16Array", "classesLength", "length", "classInstancesLength", "properties", "instances", "binaryProperties", "getBinaryProperties", "combine", "classCounts", "Array", "fill", "classIndexes", "validateHierarchy", "traverseHierarchy", "instanceIndex", "endConditionCallback", "traverseHierarchyMultipleParents", "traverseHierarchySingleParent", "visited", "scratchVisited", "Math", "max", "visitedMarker", "marker", "stack", "scratchStack", "push", "pop", "result", "parentCount", "parentIndex", "parentId", "hasParent", "Error", "scratchValidateStack", "validateInstance", "assert", "indexOf", "defined", "x", "undefined", "clone", "y", "IGNORED_PROPERTY_FIELDS", "HIERARCHY", "extensions", "extras", "Tile3DBatchTableParser", "constructor", "json", "binary", "featureCount", "options", "assert", "_extensions", "_properties", "propertyName", "_binaryProperties", "_initializeBinaryProperties", "_hierarchy", "initializeHierarchy", "getExtension", "extensionName", "memorySizeInBytes", "isClass", "batchId", "className", "_checkBatchId", "result", "traverseHierarchy", "hierarchy", "instanceIndex", "classId", "classIds", "instanceClass", "classes", "name", "isExactClass", "getExactClassName", "hasProperty", "_hasPropertyInHierarchy", "getPropertyNames", "results", "length", "propertyNames", "Object", "keys", "push", "_getPropertyNamesInHierarchy", "getProperty", "binaryProperty", "_getBinaryProperty", "propertyValues", "hierarchyProperty", "_getHierarchyProperty", "setProperty", "value", "_setBinaryProperty", "_setHierarchyProperty", "Array", "valid", "Error", "index", "unpack", "typedArray", "pack", "binaryProperties", "property", "_initializeBinaryProperty", "tile3DAccessor", "type", "accessor", "createTypedArrayFromAccessor", "buffer", "byteOffset", "values", "componentCount", "size", "unpacker", "packer", "instances", "hasOwnProperty", "indexOf", "indexInClass", "classIndexes", "batchTable", "SIZEOF_UINT32", "parse3DTileHeaderSync", "tile", "arrayBuffer", "byteOffset", "view", "DataView", "magic", "getUint32", "version", "byteLength", "Error", "SIZEOF_UINT32", "DEPRECATION_WARNING", "parse3DTileTablesHeaderSync", "tile", "arrayBuffer", "byteOffset", "view", "DataView", "batchLength", "header", "featureTableJsonByteLength", "getUint32", "featureTableBinaryByteLength", "batchTableJsonByteLength", "batchTableBinaryByteLength", "console", "warn", "parse3DTileTablesSync", "options", "parse3DTileFeatureTable", "parse3DTileBatchTable", "featureTableJson", "BATCH_LENGTH", "featureTableString", "getStringFromArrayBuffer", "JSON", "parse", "featureTableBinary", "Uint8Array", "batchTableString", "batchTableJson", "batchTableBinary", "normalize3DTileColorAttribute", "tile", "colors", "batchTable", "batchIds", "isRGB565", "pointCount", "colorArray", "Uint8ClampedArray", "i", "batchId", "dimensions", "getProperty", "color", "map", "d", "type", "GL", "UNSIGNED_BYTE", "value", "size", "normalized", "decodeRGB565", "length", "scratchNormal", "Vector3", "normalize3DTileNormalAttribute", "tile", "normals", "isOctEncoded16P", "decodedArray", "Float32Array", "pointsLength", "i", "octDecode", "toArray", "type", "GL", "FLOAT", "size", "value", "normalize3DTilePositionAttribute", "tile", "positions", "options", "isQuantized", "decodeQuantizedPositions", "type", "GL", "UNSIGNED_SHORT", "value", "size", "normalized", "scratchPosition", "Vector3", "decodedArray", "Float32Array", "pointCount", "i", "set", "scale", "quantizedRange", "multiply", "quantizedVolumeScale", "add", "quantizedVolumeOffset", "toArray", "parsePointCloud3DTile", "tile", "arrayBuffer", "byteOffset", "options", "context", "parse3DTileHeaderSync", "parse3DTileTablesHeaderSync", "parse3DTileTablesSync", "initializeTile", "featureTable", "batchTable", "parsePointCloudTables", "parseDraco", "parsePositions", "parseColors", "parseNormals", "attributes", "positions", "colors", "normals", "batchIds", "isQuantized", "isTranslucent", "isRGB565", "isOctEncoded16P", "Tile3DFeatureTable", "featureTableJson", "featureTableBinary", "pointsLength", "getGlobalProperty", "Number", "isFinite", "Error", "featuresLength", "pointCount", "rtcCenter", "GL", "FLOAT", "parseBatchIds", "hasProperty", "getPropertyArray", "UNSIGNED_SHORT", "quantizedRange", "quantizedVolumeScale", "quantizedVolumeOffset", "normalize3DTilePositionAttribute", "UNSIGNED_BYTE", "normalize3DTileColorAttribute", "constantRGBA", "normalize3DTileNormalAttribute", "batchFeatureLength", "batchTableJson", "batchTableBinary", "Tile3DBatchTable", "dracoBuffer", "dracoFeatureTableProperties", "dracoBatchTableProperties", "batchTableDraco", "extensions", "properties", "featureTableDraco", "getExtension", "dracoByteOffset", "dracoByteLength", "byteLength", "slice", "hasPositions", "POSITION", "hasColors", "RGB", "RGBA", "hasNormals", "NORMAL", "hasBatchIds", "BATCH_ID", "dracoData", "buffer", "featureTableProperties", "batchTableProperties", "dequantizeInShader", "loadDraco", "parse", "dracoOptions", "draco", "extraAttributes", "data", "DracoLoader", "decodedPositions", "value", "decodedColors", "COLOR_0", "decodedNormals", "decodedBatchIds", "isQuantizedDraco", "quantization", "isOctEncodedDraco", "range", "Vector3", "minValues", "quantizationBits", "octEncodedRange", "batchTableAttributes", "attributeName", "Object", "keys", "toLowerCase", "undefined", "VERSION", "VERSION", "VERSION", "BASIS_CDN_ENCODER_WASM", "BASIS_CDN_ENCODER_JS", "loadBasisTranscoderPromise", "loadBasisTrascoderModule", "options", "modules", "basis", "loadBasisTrascoder", "BASIS", "wasmBinary", "Promise", "all", "loadLibrary", "globalThis", "initializeBasisTrascoderModule", "BasisModule", "resolve", "then", "module", "BasisFile", "initializeBasis", "loadBasisEncoderPromise", "loadBasisEncoderModule", "basisEncoder", "loadBasisEncoder", "BASIS_ENCODER", "initializeBasisEncoderModule", "BasisEncoderModule", "KTX2File", "BasisEncoder", "GL_EXTENSIONS_CONSTANTS", "COMPRESSED_RGB_S3TC_DXT1_EXT", "COMPRESSED_RGBA_S3TC_DXT1_EXT", "COMPRESSED_RGBA_S3TC_DXT3_EXT", "COMPRESSED_RGBA_S3TC_DXT5_EXT", "COMPRESSED_R11_EAC", "COMPRESSED_SIGNED_R11_EAC", "COMPRESSED_RG11_EAC", "COMPRESSED_SIGNED_RG11_EAC", "COMPRESSED_RGB8_ETC2", "COMPRESSED_RGBA8_ETC2_EAC", "COMPRESSED_SRGB8_ETC2", "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", "COMPRESSED_RGB_ETC1_WEBGL", "COMPRESSED_RGB_ATC_WEBGL", "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", "COMPRESSED_RGBA_ASTC_4X4_KHR", "COMPRESSED_RGBA_ASTC_5X4_KHR", "COMPRESSED_RGBA_ASTC_5X5_KHR", "COMPRESSED_RGBA_ASTC_6X5_KHR", "COMPRESSED_RGBA_ASTC_6X6_KHR", "COMPRESSED_RGBA_ASTC_8X5_KHR", "COMPRESSED_RGBA_ASTC_8X6_KHR", "COMPRESSED_RGBA_ASTC_8X8_KHR", "COMPRESSED_RGBA_ASTC_10X5_KHR", "COMPRESSED_RGBA_ASTC_10X6_KHR", "COMPRESSED_RGBA_ASTC_10X8_KHR", "COMPRESSED_RGBA_ASTC_10X10_KHR", "COMPRESSED_RGBA_ASTC_12X10_KHR", "COMPRESSED_RGBA_ASTC_12X12_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR", "COMPRESSED_RED_RGTC1_EXT", "COMPRESSED_SIGNED_RED_RGTC1_EXT", "COMPRESSED_RED_GREEN_RGTC2_EXT", "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", "COMPRESSED_SRGB_S3TC_DXT1_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", "BROWSER_PREFIXES", "WEBGL_EXTENSIONS", "WEBGL_compressed_texture_s3tc", "WEBGL_compressed_texture_s3tc_srgb", "WEBGL_compressed_texture_etc1", "WEBGL_compressed_texture_etc", "WEBGL_compressed_texture_pvrtc", "WEBGL_compressed_texture_atc", "WEBGL_compressed_texture_astc", "EXT_texture_compression_rgtc", "formats", "getSupportedGPUTextureFormats", "gl", "getWebGLContext", "undefined", "Set", "prefix", "extension", "getExtension", "gpuTextureFormat", "add", "canvas", "document", "createElement", "getContext", "error", "NUL", "Uint8Array", "KTX2_ID", "KTX2SupercompressionScheme", "KTX2DataFormatType", "KTX2DataFormatModel", "KTX2DataFormatPrimaries", "KTX2DataFormatTransfer", "KTX2DataFormatFlags", "KTX2DataFormatChannelETC1S", "KTX2DataFormatChannelUASTC", "KTX2Container", "constructor", "this", "NONE", "vendorId", "descriptorType", "BASICFORMAT", "versionNumber", "descriptorBlockSize", "colorModel", "UNSPECIFIED", "colorPrimaries", "SRGB", "transferFunction", "flags", "ALPHA_STRAIGHT", "texelBlockDimension", "x", "y", "z", "w", "bytesPlane", "samples", "BufferReader", "data", "byteOffset", "byteLength", "littleEndian", "_dataView", "DataView", "buffer", "_littleEndian", "_offset", "_nextUint8", "value", "getUint8", "_nextUint16", "getUint16", "_nextUint32", "getUint32", "_nextUint64", "_skip", "bytes", "_scan", "maxByteLength", "term", "text", "decodeText", "buffer", "TextDecoder", "decode", "Buffer", "from", "toString", "result", "read", "data", "id", "Uint8Array", "buffer", "byteOffset", "KTX2_ID", "length", "Error", "container", "KTX2Container", "headerByteLength", "Uint32Array", "BYTES_PER_ELEMENT", "headerReader", "BufferReader", "vkFormat", "_nextUint32", "typeSize", "pixelWidth", "pixelHeight", "pixelDepth", "layerCount", "faceCount", "levelCount", "supercompressionScheme", "dfdByteOffset", "dfdByteLength", "kvdByteOffset", "kvdByteLength", "sgdByteOffset", "_nextUint64", "sgdByteLength", "levelReader", "i", "levels", "push", "levelData", "uncompressedByteLength", "dfdReader", "dfd", "vendorId", "_skip", "_nextUint16", "descriptorType", "versionNumber", "descriptorBlockSize", "colorModel", "_nextUint8", "colorPrimaries", "transferFunction", "flags", "texelBlockDimension", "x", "y", "z", "w", "bytesPlane", "samples", "numSamples", "bitOffset", "bitLength", "channelID", "samplePosition", "sampleLower", "sampleUpper", "dataFormatDescriptor", "kvdReader", "_offset", "keyValueByteLength", "keyData", "_scan", "key", "decodeText", "valueData", "byteLength", "keyValue", "match", "sgdReader", "endpointCount", "selectorCount", "endpointsByteLength", "selectorsByteLength", "tablesByteLength", "extendedByteLength", "imageDescs", "imageFlags", "rgbSliceByteOffset", "rgbSliceByteLength", "alphaSliceByteOffset", "alphaSliceByteLength", "endpointsByteOffset", "selectorsByteOffset", "tablesByteOffset", "extendedByteOffset", "endpointsData", "selectorsData", "tablesData", "extendedData", "globalData", "extractMipmapImages", "data", "options", "images", "Array", "mipMapLevels", "levelWidth", "width", "levelHeight", "height", "offset", "i", "levelSize", "getLevelSize", "levelData", "getLevelData", "compressed", "format", "internalFormat", "Math", "max", "index", "isArray", "Uint8Array", "buffer", "byteOffset", "sizeFunction", "VULKAN_TO_WEBGL_FORMAT_MAP", "GL_EXTENSIONS_CONSTANTS", "COMPRESSED_RGB_S3TC_DXT1_EXT", "COMPRESSED_SRGB_S3TC_DXT1_EXT", "COMPRESSED_RGBA_S3TC_DXT1_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", "COMPRESSED_RGBA_S3TC_DXT3_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", "COMPRESSED_RGBA_S3TC_DXT5_EXT", "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", "COMPRESSED_RED_RGTC1_EXT", "COMPRESSED_SIGNED_RED_RGTC1_EXT", "COMPRESSED_RED_GREEN_RGTC2_EXT", "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", "COMPRESSED_RGB8_ETC2", "COMPRESSED_SRGB8_ETC2", "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", "COMPRESSED_RGBA8_ETC2_EAC", "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", "COMPRESSED_R11_EAC", "COMPRESSED_SIGNED_R11_EAC", "COMPRESSED_RG11_EAC", "COMPRESSED_SIGNED_RG11_EAC", "COMPRESSED_RGBA_ASTC_4x4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", "COMPRESSED_RGBA_ASTC_5x4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR", "COMPRESSED_RGBA_ASTC_5x5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", "COMPRESSED_RGBA_ASTC_6x5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", "COMPRESSED_RGBA_ASTC_6x6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", "COMPRESSED_RGBA_ASTC_8x5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", "COMPRESSED_RGBA_ASTC_8x6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", "COMPRESSED_RGBA_ASTC_8x8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", "COMPRESSED_RGBA_ASTC_10x5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", "COMPRESSED_RGBA_ASTC_10x6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", "COMPRESSED_RGBA_ASTC_10x8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", "COMPRESSED_RGBA_ASTC_10x10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", "COMPRESSED_RGBA_ASTC_12x10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", "COMPRESSED_RGBA_ASTC_12x12_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", "mapVkFormatToWebGL", "vkFormat", "KTX2_ID", "isKTX", "data", "id", "Uint8Array", "notKTX", "byteLength", "length", "parseKTX", "arrayBuffer", "uint8Array", "ktx", "read", "mipMapLevels", "Math", "max", "levels", "width", "pixelWidth", "height", "pixelHeight", "internalFormat", "mapVkFormatToWebGL", "vkFormat", "extractMipmapImages", "sizeFunction", "level", "uncompressedByteLength", "OutputFormat", "etc1", "basisFormat", "compressed", "format", "GL_EXTENSIONS_CONSTANTS", "COMPRESSED_RGB_ETC1_WEBGL", "etc2", "bc1", "COMPRESSED_RGB_S3TC_DXT1_EXT", "bc3", "COMPRESSED_RGBA_S3TC_DXT5_EXT", "bc4", "bc5", "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", "COMPRESSED_RGBA_ASTC_4X4_KHR", "rgba32", "rgb565", "bgr565", "rgba4444", "data", "options", "basis", "containerFormat", "isKTX", "fileConstructors", "loadBasisEncoderModule", "parseKTX2File", "KTX2File", "BasisFile", "loadBasisTrascoderModule", "parseBasisFile", "module", "basisFile", "Uint8Array", "startTranscoding", "Error", "imageCount", "getNumImages", "images", "imageIndex", "levelsCount", "getNumLevels", "levels", "levelIndex", "push", "transcodeImage", "close", "delete", "width", "getImageWidth", "height", "getImageHeight", "hasAlpha", "getHasAlpha", "getBasisOptions", "decodedSize", "getImageTranscodedSizeInBytes", "decodedData", "ktx2File", "getLevels", "transcodeKTX2Image", "alphaFlag", "getImageLevelInfo", "levelSize", "selectSupportedBasisFormat", "alpha", "noAlpha", "toLowerCase", "supportedFormats", "getSupportedGPUTextureFormats", "has", "BasisWorkerLoader", "name", "id", "isBrowser", "module", "version", "VERSION", "worker", "extensions", "mimeTypes", "tests", "binary", "options", "basis", "format", "libraryPath", "containerFormat", "BasisLoader", "parse", "parseBasis", "DDS_CONSTANTS", "MAGIC_NUMBER", "HEADER_LENGTH", "MAGIC_NUMBER_INDEX", "HEADER_SIZE_INDEX", "HEADER_FLAGS_INDEX", "HEADER_HEIGHT_INDEX", "HEADER_WIDTH_INDEX", "MIPMAPCOUNT_INDEX", "HEADER_PF_FLAGS_INDEX", "HEADER_PF_FOURCC_INDEX", "DDSD_MIPMAPCOUNT", "DDPF_FOURCC", "DDS_PIXEL_FORMATS", "DXT1", "GL_EXTENSIONS_CONSTANTS", "COMPRESSED_RGB_S3TC_DXT1_EXT", "DXT3", "COMPRESSED_RGBA_S3TC_DXT3_EXT", "DXT5", "COMPRESSED_RGBA_S3TC_DXT5_EXT", "COMPRESSED_RGB_ATC_WEBGL", "ATCA", "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", "ATCI", "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", "getATCLevelSize", "getDxt1LevelSize", "getATCALevelSize", "getDxtXLevelSize", "getATCILevelSize", "DDS_SIZE_FUNCTIONS", "isDDS", "data", "header", "Uint32Array", "magic", "parseDDS", "Int32Array", "pixelFormatNumber", "assert", "Boolean", "fourCC", "int32ToFourCC", "internalFormat", "sizeFunction", "mipMapLevels", "Math", "max", "width", "height", "dataOffset", "image", "Uint8Array", "extractMipmapImages", "value", "String", "fromCharCode", "PVR_CONSTANTS", "MAGIC_NUMBER", "MAGIC_NUMBER_EXTRA", "HEADER_LENGTH", "HEADER_SIZE", "MAGIC_NUMBER_INDEX", "PIXEL_FORMAT_INDEX", "COLOUR_SPACE_INDEX", "HEIGHT_INDEX", "WIDTH_INDEX", "MIPMAPCOUNT_INDEX", "METADATA_SIZE_INDEX", "PVR_PIXEL_FORMATS", "GL_EXTENSIONS_CONSTANTS", "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", "COMPRESSED_RGB_ETC1_WEBGL", "COMPRESSED_RGB_S3TC_DXT1_EXT", "COMPRESSED_RGBA_S3TC_DXT3_EXT", "COMPRESSED_RGBA_S3TC_DXT5_EXT", "COMPRESSED_RGB8_ETC2", "COMPRESSED_RGBA8_ETC2_EAC", "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", "COMPRESSED_R11_EAC", "COMPRESSED_RG11_EAC", "COMPRESSED_RGBA_ASTC_4X4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR", "COMPRESSED_RGBA_ASTC_5X4_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR", "COMPRESSED_RGBA_ASTC_5X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR", "COMPRESSED_RGBA_ASTC_6X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR", "COMPRESSED_RGBA_ASTC_6X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR", "COMPRESSED_RGBA_ASTC_8X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR", "COMPRESSED_RGBA_ASTC_8X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR", "COMPRESSED_RGBA_ASTC_8X8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR", "COMPRESSED_RGBA_ASTC_10X5_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR", "COMPRESSED_RGBA_ASTC_10X6_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR", "COMPRESSED_RGBA_ASTC_10X8_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR", "COMPRESSED_RGBA_ASTC_10X10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR", "COMPRESSED_RGBA_ASTC_12X10_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR", "COMPRESSED_RGBA_ASTC_12X12_KHR", "COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR", "PVR_SIZE_FUNCTIONS", "pvrtc2bppSize", "pvrtc4bppSize", "dxtEtcSmallSize", "dxtEtcAstcBigSize", "atc5x4Size", "atc5x5Size", "atc6x5Size", "atc6x6Size", "atc8x5Size", "atc8x6Size", "atc8x8Size", "atc10x5Size", "atc10x6Size", "atc10x8Size", "atc10x10Size", "atc12x10Size", "atc12x12Size", "isPVR", "data", "header", "Uint32Array", "version", "parsePVR", "pvrFormat", "colourSpace", "pixelFormats", "internalFormat", "length", "sizeFunction", "mipMapLevels", "width", "height", "dataOffset", "image", "Uint8Array", "extractMipmapImages", "Math", "max", "floor", "parseCompressedTexture", "data", "isKTX", "parseKTX", "isDDS", "parseDDS", "isPVR", "parsePVR", "Error", "DEFAULT_TEXTURE_LOADER_OPTIONS", "libraryPath", "useBasis", "CompressedTextureWorkerLoader", "name", "id", "module", "version", "VERSION", "worker", "extensions", "mimeTypes", "binary", "options", "CompressedTextureLoader", "parse", "arrayBuffer", "basis", "format", "alpha", "noAlpha", "containerFormat", "parseBasis", "parseCompressedTexture", "systemIsLittleEndian", "a", "Uint32Array", "b", "Uint8Array", "buffer", "byteOffset", "byteLength", "LITTLE_ENDIAN_OS", "DTYPES", "u1", "i1", "Int8Array", "u2", "Uint16Array", "i2", "Int16Array", "u4", "i4", "Int32Array", "f4", "Float32Array", "f8", "Float64Array", "parseNPY", "arrayBuffer", "options", "view", "DataView", "header", "headerEndOffset", "parseHeader", "numpyType", "descr", "ArrayType", "slice", "Error", "nArrayElements", "shape", "reduce", "arrayByteLength", "BYTES_PER_ELEMENT", "data", "majorVersion", "getUint8", "offset", "headerLength", "getUint32", "getUint16", "encoding", "decoder", "TextDecoder", "headerArray", "headerText", "decode", "JSON", "parse", "replace", "NPY_MAGIC_NUMBER", "Uint8Array", "NPYWorkerLoader", "name", "id", "module", "version", "VERSION", "worker", "extensions", "mimeTypes", "tests", "buffer", "options", "npy", "NPYLoader", "parseSync", "parseNPY", "parse", "arrayBuffer", "assert", "condition", "message", "Error", "resolveUrl", "url", "options", "absolute", "startsWith", "baseUrl", "baseUri", "uri", "Error", "substr", "lastIndexOf", "getTypedArrayForBufferView", "json", "buffers", "bufferViewIndex", "bufferView", "bufferViews", "assert", "bufferIndex", "buffer", "binChunk", "byteOffset", "Uint8Array", "arrayBuffer", "byteLength", "TYPES", "ARRAY_CONSTRUCTOR_TO_WEBGL_CONSTANT", "Int8Array", "Uint8Array", "Int16Array", "Uint16Array", "Uint32Array", "Float32Array", "Float64Array", "ARRAY_TO_COMPONENT_TYPE", "Map", "ATTRIBUTE_TYPE_TO_COMPONENTS", "SCALAR", "VEC2", "VEC3", "VEC4", "MAT2", "MAT3", "MAT4", "ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE", "ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY", "getAccessorTypeFromSize", "size", "type", "getComponentTypeFromArray", "typedArray", "componentType", "get", "constructor", "Error", "getAccessorArrayTypeAndLength", "accessor", "bufferView", "ArrayType", "components", "bytesPerComponent", "length", "count", "byteLength", "assert", "DEFAULT_GLTF_JSON", "asset", "version", "generator", "buffers", "GLTFScenegraph", "constructor", "gltf", "json", "sourceBuffers", "byteLength", "getApplicationData", "key", "data", "getExtraData", "extras", "getExtension", "extensionName", "isExtension", "getUsedExtensions", "find", "name", "extensions", "getRequiredExtension", "isRequired", "getRequiredExtensions", "extensionsRequired", "extensionsUsed", "getRemovedExtensions", "extensionsRemoved", "getObjectExtension", "object", "getScene", "index", "getObject", "getNode", "getSkin", "getMesh", "getMaterial", "getAccessor", "getTexture", "getSampler", "getImage", "getBufferView", "getBuffer", "array", "Error", "getTypedArrayForBufferView", "bufferView", "bufferIndex", "buffer", "binChunk", "assert", "byteOffset", "Uint8Array", "arrayBuffer", "getTypedArrayForAccessor", "accessor", "ArrayType", "length", "getAccessorArrayTypeAndLength", "getTypedArrayForImageData", "image", "addApplicationData", "addExtraData", "addObjectExtension", "registerUsedExtension", "setObjectExtension", "removeObjectExtension", "extension", "addExtension", "extensionData", "addRequiredExtension", "registerRequiredExtension", "ext", "push", "removeExtension", "_removeStringFromArray", "Array", "isArray", "includes", "setDefaultScene", "sceneIndex", "scene", "addScene", "nodeIndices", "scenes", "nodes", "addNode", "node", "meshIndex", "matrix", "nodeData", "mesh", "addMesh", "attributes", "indices", "material", "mode", "accessors", "_addAttributes", "glTFMesh", "primitives", "indicesAccessor", "_addIndices", "Number", "isFinite", "meshes", "addPointCloud", "accessorIndices", "addImage", "imageData", "mimeTypeOpt", "metadata", "getBinaryImageMetadata", "mimeType", "bufferViewIndex", "addBufferView", "glTFImage", "images", "glTFBufferView", "padToNBytes", "bufferViews", "addAccessor", "glTFAccessor", "type", "getAccessorTypeFromSize", "size", "componentType", "count", "max", "min", "addBinaryBuffer", "sourceBuffer", "minMax", "_getAccessorMinMax", "accessorDefaults", "getComponentTypeFromArray", "Math", "round", "Object", "assign", "addTexture", "texture", "imageIndex", "glTFTexture", "source", "textures", "addMaterial", "pbrMaterialInfo", "materials", "createBinaryChunk", "totalByteLength", "ArrayBuffer", "targetArray", "dstByteOffset", "copyToArray", "binary", "string", "found", "indexOf", "splice", "result", "attributeKey", "attributeData", "attrName", "_getGltfAttributeName", "value", "attributeName", "toLowerCase", "initValues", "subarray", "componentIndex", "wasm_base", "wasm_simd", "detector", "Uint8Array", "wasmpack", "FILTERS", "NONE", "OCTAHEDRAL", "QUATERNION", "EXPONENTIAL", "DECODERS", "ATTRIBUTES", "TRIANGLES", "INDICES", "meshoptDecodeGltfBuffer", "target", "count", "size", "source", "mode", "filter", "instance", "loadWasmInstance", "decode", "exports", "DECODERS", "FILTERS", "wasmPromise", "loadWasmModule", "wasm", "wasm_base", "WebAssembly", "validate", "detector", "wasm_simd", "console", "log", "result", "instantiate", "unpack", "__wasm_call_ctors", "data", "Uint8Array", "length", "i", "ch", "charCodeAt", "write", "wasmpack", "buffer", "slice", "fun", "sbrk", "count4", "tp", "sp", "heap", "memory", "set", "res", "subarray", "Error", "EXT_MESHOPT_COMPRESSION", "name", "decode", "gltfData", "options", "scenegraph", "GLTFScenegraph", "gltf", "decompressMeshes", "promises", "bufferViewIndex", "json", "bufferViews", "push", "decodeMeshoptBufferView", "Promise", "all", "removeExtension", "bufferView", "meshoptExtension", "getObjectExtension", "byteOffset", "byteLength", "byteStride", "count", "mode", "filter", "buffer", "bufferIndex", "buffers", "source", "Uint8Array", "arrayBuffer", "result", "meshoptDecodeGltfBuffer", "EXT_TEXTURE_WEBP", "name", "preprocess", "gltfData", "options", "scenegraph", "GLTFScenegraph", "_isImageFormatSupported", "getRequiredExtensions", "includes", "Error", "json", "texture", "textures", "extension", "getObjectExtension", "source", "removeObjectExtension", "removeExtension", "KHR_TEXTURE_BASISU", "name", "preprocess", "gltfData", "options", "scene", "GLTFScenegraph", "json", "texture", "textures", "extension", "getObjectExtension", "source", "removeObjectExtension", "removeExtension", "getGLTFAccessors", "attributes", "accessors", "name", "attribute", "glTFAccessor", "getGLTFAccessor", "buffer", "size", "count", "getAccessorData", "value", "byteOffset", "type", "getAccessorTypeFromSize", "componentType", "getComponentTypeFromArray", "ArrayBuffer", "isView", "toTypedArray", "Float32Array", "length", "array", "ArrayType", "convertTypedArrays", "Array", "isArray", "KHR_DRACO_MESH_COMPRESSION", "name", "preprocess", "gltfData", "options", "context", "scenegraph", "Scenegraph", "primitive", "makeMeshPrimitiveIterator", "getObjectExtension", "decode", "gltf", "decompressMeshes", "promises", "push", "decompressPrimitive", "Promise", "all", "removeExtension", "encode", "mesh", "json", "meshes", "compressMesh", "addRequiredExtension", "dracoExtension", "buffer", "getTypedArrayForBufferView", "bufferView", "bufferCopy", "sliceArrayBuffer", "byteOffset", "parse", "dracoOptions", "decodedData", "DracoLoader", "decodedAttributes", "getGLTFAccessors", "attributes", "attributeName", "decodedAttribute", "Object", "entries", "accessorIndex", "accessor", "getAccessor", "min", "max", "indices", "getGLTFAccessor", "checkPrimitive", "mode", "DracoWriter", "Error", "compressedData", "encodeSync", "parseSync", "fauxAccessors", "_addFauxAttributes", "bufferViewIndex", "addBufferView", "glTFMesh", "primitives", "extensions", "keys", "length", "COMPONENTS", "SCALAR", "VEC2", "VEC3", "VEC4", "MAT2", "MAT3", "MAT4", "BYTES", "EXT_MESHOPT_TRANSFORM", "name", "scratchVector", "Vector3", "scratchRotationMatrix", "Matrix3", "scratchScaleMatrix", "decode", "gltfData", "options", "gltfScenegraph", "GLTFScenegraph", "extension", "getExtension", "materials", "json", "i", "length", "transformTexCoords", "materialIndex", "processedTexCoords", "material", "baseColorTexture", "pbrMetallicRoughness", "transformPrimitives", "emisiveTexture", "emissiveTexture", "normalTexture", "occlusionTexture", "metallicRoughnessTexture", "texture", "transformParameters", "getTransformParameters", "meshes", "mesh", "primitive", "primitives", "Number", "isFinite", "transformPrimitive", "textureInfo", "extensions", "texCoord", "originalTexCoord", "isProcessed", "findIndex", "original", "newTexCoord", "matrix", "makeTransformationMatrix", "push", "texCoordAccessor", "attributes", "accessor", "accessors", "bufferView", "bufferViews", "arrayBuffer", "byteOffset", "bufferByteOffset", "buffers", "buffer", "ArrayType", "getAccessorArrayTypeAndLength", "bytes", "BYTES", "componentType", "components", "COMPONENTS", "type", "elementAddressScale", "byteStride", "result", "Float32Array", "count", "uv", "set", "transformByMatrix3", "updateGltf", "createAttribute", "newTexCoordArray", "byteLength", "originalAccessor", "extensionData", "offset", "rotation", "scale", "translationMatirx", "rotationMatirx", "Math", "cos", "sin", "scaleMatrix", "multiplyRight", "KHR_LIGHTS_PUNCTUAL", "name", "decode", "gltfData", "gltfScenegraph", "GLTFScenegraph", "json", "extension", "getExtension", "lights", "removeExtension", "node", "nodes", "nodeExtension", "getObjectExtension", "light", "removeObjectExtension", "encode", "addExtension", "assert", "addObjectExtension", "KHR_MATERIALS_UNLIT", "name", "decode", "gltfData", "gltfScenegraph", "GLTFScenegraph", "json", "material", "materials", "extension", "extensions", "KHR_materials_unlit", "unlit", "removeObjectExtension", "removeExtension", "encode", "addObjectExtension", "addExtension", "KHR_TECHNIQUES_WEBGL", "name", "decode", "gltfData", "gltfScenegraph", "GLTFScenegraph", "json", "extension", "getExtension", "techniques", "resolveTechniques", "material", "materials", "materialExtension", "getObjectExtension", "technique", "Object", "assign", "values", "resolveValues", "removeObjectExtension", "removeExtension", "encode", "options", "techniquesExtension", "programs", "shaders", "textDecoder", "TextDecoder", "forEach", "shader", "Number", "isFinite", "bufferView", "code", "getTypedArrayForBufferView", "Error", "program", "fragmentShader", "vertexShader", "keys", "uniforms", "uniform", "value", "index", "undefined", "texture", "getTexture", "EXT_FEATURE_METADATA", "name", "decode", "gltfData", "scenegraph", "GLTFScenegraph", "decodeExtFeatureMetadata", "extension", "getExtension", "schemaClasses", "schema", "classes", "featureTables", "featureTextures", "console", "warn", "schemaName", "schemaClass", "featureTable", "findFeatureTableByName", "handleFeatureTableProperties", "propertyName", "properties", "schemaProperty", "featureTableProperty", "numberOfFeatures", "count", "data", "getPropertyDataFromBinarySource", "bufferView", "getTypedArrayForBufferView", "type", "stringOffsetBufferView", "offsetsData", "getStringAttributes", "schemaClassName", "featureTableName", "class", "stringsCount", "stringsArray", "textDecoder", "TextDecoder", "stringOffset", "bytesPerStringSize", "index", "stringByteSize", "stringData", "subarray", "stringAttribute", "push", "EXTENSIONS", "EXT_meshopt_compression", "EXT_texture_webp", "KHR_texture_basisu", "KHR_draco_mesh_compression", "KHR_lights_punctual", "KHR_materials_unlit", "KHR_techniques_webgl", "KHR_texture_transform", "EXT_feature_metadata", "preprocessExtensions", "gltf", "options", "context", "extensions", "filter", "extension", "useExtension", "name", "preprocess", "decodeExtensions", "decode", "extensionName", "excludes", "excludeExtensions", "exclude", "KHR_BINARY_GLTF", "preprocess", "gltfData", "gltfScenegraph", "GLTFScenegraph", "json", "image", "images", "extension", "getObjectExtension", "KHR_BINARY_GLTF", "Object", "assign", "removeObjectExtension", "buffers", "uri", "removeExtension", "GLTF_ARRAYS", "accessors", "animations", "buffers", "bufferViews", "images", "materials", "meshes", "nodes", "samplers", "scenes", "skins", "textures", "GLTF_KEYS", "accessor", "buffer", "bufferView", "image", "material", "mesh", "node", "sampler", "scene", "skin", "texture", "GLTFV1Normalizer", "normalize", "gltf", "options", "json", "asset", "version", "undefined", "console", "warn", "Error", "_addAsset", "_convertTopLevelObjectsToArrays", "KHR_binary_glTF", "preprocess", "_convertObjectIdsToArrayIndices", "_updateObjects", "_updateMaterial", "generator", "arrayName", "_convertTopLevelObjectToArray", "mapName", "objectMap", "Array", "isArray", "id", "object", "index", "length", "push", "idToIndexMap", "_convertIdsToIndices", "_convertIdToIndex", "_convertTextureIds", "_convertMeshIds", "_convertNodeIds", "_convertSceneIds", "source", "primitive", "primitives", "attributes", "indices", "attributeName", "children", "map", "child", "topLevelArrayName", "key", "Number", "isFinite", "type", "pbrMetallicRoughness", "baseColorFactor", "metallicFactor", "roughnessFactor", "textureId", "values", "tex", "texture2d_0", "diffuseTex", "textureIndex", "findIndex", "baseColorTexture", "normalizeGLTFV1", "COMPONENTS", "SCALAR", "VEC2", "VEC3", "VEC4", "MAT2", "MAT3", "MAT4", "BYTES", "GL_SAMPLER", "TEXTURE_MAG_FILTER", "TEXTURE_MIN_FILTER", "TEXTURE_WRAP_S", "TEXTURE_WRAP_T", "REPEAT", "LINEAR", "NEAREST_MIPMAP_LINEAR", "SAMPLER_PARAMETER_GLTF_TO_GL", "magFilter", "minFilter", "wrapS", "wrapT", "DEFAULT_SAMPLER", "getBytesFromComponentType", "componentType", "getSizeFromAccessorType", "type", "GLTFPostProcessor", "postProcess", "gltf", "options", "json", "buffers", "images", "baseUri", "assert", "_resolveTree", "bufferViews", "map", "bufView", "i", "_resolveBufferView", "image", "_resolveImage", "samplers", "sampler", "_resolveSampler", "textures", "texture", "_resolveTexture", "accessors", "accessor", "_resolveAccessor", "materials", "material", "_resolveMaterial", "meshes", "mesh", "_resolveMesh", "nodes", "node", "_resolveNode", "skins", "skin", "_resolveSkin", "scenes", "scene", "_resolveScene", "undefined", "getScene", "index", "_get", "getNode", "getSkin", "getMesh", "getMaterial", "getAccessor", "getCamera", "getTexture", "getSampler", "getImage", "getBufferView", "getBuffer", "array", "object", "console", "warn", "id", "children", "child", "length", "reduce", "accum", "meshIndex", "primitives", "concat", "camera", "inverseBindMatrices", "primitive", "attributes", "attribute", "indices", "normalTexture", "occlusionTexture", "occlustionTexture", "emissiveTexture", "emmisiveTexture", "emissiveFactor", "pbrMetallicRoughness", "mr", "baseColorTexture", "metallicRoughnessTexture", "bufferView", "bytesPerComponent", "components", "bytesPerElement", "buffer", "ArrayType", "byteLength", "getAccessorArrayTypeAndLength", "byteOffset", "cutBuffer", "arrayBuffer", "slice", "byteStride", "_getValueFromInterleavedBuffer", "count", "value", "result", "Uint8Array", "elementOffset", "set", "source", "parameters", "key", "glEnum", "_enumSamplerParameter", "preloadedImage", "bufferIndex", "data", "_resolveCamera", "perspective", "orthographic", "postProcessGLTF", "MAGIC_glTF", "GLB_FILE_HEADER_SIZE", "GLB_CHUNK_HEADER_SIZE", "GLB_CHUNK_TYPE_JSON", "GLB_CHUNK_TYPE_BIN", "GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED", "GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED", "GLB_V1_CONTENT_FORMAT_JSON", "LE", "getMagicString", "dataView", "byteOffset", "String", "fromCharCode", "getUint8", "isGLB", "arrayBuffer", "options", "DataView", "magic", "magic1", "getUint32", "glb", "type", "version", "byteLength", "Object", "assign", "header", "hasBinChunk", "json", "binChunks", "parseGLBV1", "parseGLBV2", "Error", "assert", "contentLength", "contentFormat", "parseJSONChunk", "parseBINChunk", "parseGLBChunksSync", "chunkLength", "chunkFormat", "strict", "padToNBytes", "jsonChunk", "Uint8Array", "buffer", "textDecoder", "TextDecoder", "jsonText", "decode", "JSON", "parse", "push", "parseGLTF", "gltf", "arrayBufferOrString", "byteOffset", "options", "context", "parseGLTFContainerSync", "normalizeGLTFV1", "normalize", "preprocessExtensions", "promises", "loadBuffers", "json", "buffers", "loadImages", "promise", "push", "decodeExtensions", "Promise", "all", "postProcess", "postProcessGLTF", "data", "uri", "baseUri", "ArrayBuffer", "isGLB", "textDecoder", "TextDecoder", "decode", "parseJSON", "glb", "parseGLBSync", "assert", "type", "_glb", "Array", "length", "fill", "header", "hasBinChunk", "binChunks", "arrayBuffer", "byteLength", "images", "i", "buffer", "fetch", "resolveUrl", "response", "imageIndices", "getReferencesImageIndices", "imageIndex", "loadImage", "Set", "textures", "texture", "source", "undefined", "add", "from", "sort", "image", "index", "parse", "hasOwnProperty", "bufferView", "Number", "isFinite", "array", "getTypedArrayForBufferView", "sliceArrayBuffer", "parsedImage", "ImageLoader", "BasisLoader", "mimeType", "basis", "format", "selectSupportedBasisFormat", "compressed", "mipmaps", "width", "height", "GLTFLoader", "name", "id", "module", "version", "VERSION", "extensions", "mimeTypes", "text", "binary", "tests", "parse", "options", "gltf", "normalize", "loadBuffers", "loadImages", "decompressMeshes", "postProcess", "log", "console", "deprecatedOptions", "fetchImages", "createImages", "decompress", "arrayBuffer", "context", "byteOffset", "parseGLTF", "GLTF_FORMAT", "URI", "EMBEDDED", "parse3DTileGLTFViewSync", "tile", "arrayBuffer", "byteOffset", "options", "rotateYtoZ", "gltfByteLength", "byteLength", "Error", "gltfUpAxis", "assetGltfUpAxis", "gltfArrayBuffer", "sliceArrayBuffer", "gltfByteOffset", "console", "warn", "type", "extractGLTF", "gltfFormat", "context", "tile3DOptions", "extractGLTFBufferOrURL", "loadGLTF", "parse", "fetch", "gltfUrl", "gltf", "GLTFLoader", "gltfUrlBytes", "Uint8Array", "textDecoder", "TextDecoder", "decode", "replace", "parseBatchedModel3DTile", "tile", "arrayBuffer", "byteOffset", "options", "context", "parseBatchedModel", "extractGLTF", "GLTF_FORMAT", "EMBEDDED", "extensions", "gltf", "CESIUM_RTC", "rtcCenter", "center", "parse3DTileHeaderSync", "parse3DTileTablesHeaderSync", "parse3DTileTablesSync", "parse3DTileGLTFViewSync", "featureTable", "Tile3DFeatureTable", "featureTableJson", "featureTableBinary", "getGlobalProperty", "GL", "FLOAT", "parseInstancedModel3DTile", "tile", "arrayBuffer", "byteOffset", "options", "context", "parseInstancedModel", "extractGLTF", "gltfFormat", "parse3DTileHeaderSync", "version", "Error", "parse3DTileTablesHeaderSync", "view", "DataView", "getUint32", "parse3DTileTablesSync", "parse3DTileGLTFViewSync", "featureTableJsonByteLength", "featureTable", "Tile3DFeatureTable", "featureTableJson", "featureTableBinary", "instancesLength", "getGlobalProperty", "featuresLength", "Number", "isFinite", "eastNorthUp", "rtcCenter", "GL", "FLOAT", "batchTable", "Tile3DBatchTable", "batchTableJson", "batchTableBinary", "extractInstancedAttributes", "collectionOptions", "instances", "Array", "_batchTable", "cull", "url", "undefined", "gltf", "basePath", "incrementallyLoadTextures", "forwardAxis", "instancePosition", "Vector3", "instanceNormalRight", "instanceNormalUp", "instanceNormalForward", "instanceRotation", "Matrix3", "instanceQuaternion", "Quaternion", "instanceScale", "instanceTranslationRotationScale", "instanceTransform", "Matrix4", "scratch1", "scratch2", "scratchVector1", "scratchVector2", "i", "position", "hasProperty", "getProperty", "UNSIGNED_SHORT", "quantizedVolumeOffset", "quantizedVolumeScale", "MAX_UNSIGNED_SHORT", "j", "copy", "translation", "normalUp", "normalRight", "hasCustomOrientation", "octNormalUp", "octNormalRight", "Ellipsoid", "WGS84", "eastNorthUpToFixedFrame", "getRotationMatrix3", "identity", "cross", "normalize", "setColumn", "fromMatrix3", "rotation", "set", "scale", "multiplyByScalar", "nonUniformScale", "batchId", "rotationMatrix", "fromQuaternion", "translate", "multiplyRight", "modelMatrix", "clone", "parseComposite3DTile", "tile", "arrayBuffer", "byteOffset", "options", "context", "parse3DTile", "parse3DTileHeaderSync", "view", "DataView", "tilesLength", "getUint32", "tiles", "length", "byteLength", "subtile", "push", "parseGltf3DTile", "tile", "arrayBuffer", "options", "context", "rotateYtoZ", "gltfUpAxis", "assetGltfUpAxis", "parse", "gltf", "GLTFLoader", "parse3DTile", "arrayBuffer", "byteOffset", "options", "context", "tile", "type", "getMagicString", "TILE3D_TYPE", "COMPOSITE", "parseComposite3DTile", "BATCHED_3D_MODEL", "parseBatchedModel3DTile", "GLTF", "parseGltf3DTile", "INSTANCED_3D_MODEL", "parseInstancedModel3DTile", "POINT_CLOUD", "parsePointCloud3DTile", "Error", "SUBTREE_FILE_MAGIC", "SUBTREE_FILE_VERSION", "data", "options", "context", "magic", "Uint32Array", "slice", "Error", "version", "jsonByteLength", "parseUint64Value", "stringAttribute", "Uint8Array", "textDecoder", "TextDecoder", "string", "decode", "subtree", "JSON", "parse", "binaryByteLength", "internalBinaryBuffer", "ArrayBuffer", "tileAvailability", "explicitBitstream", "getExplicitBitstream", "contentAvailability", "childSubtreeAvailability", "resolveBufferUri", "bitstreamRelativeUri", "basePath", "hasProtocol", "startsWith", "resolvedUri", "URL", "decodeURI", "toString", "basePathWithProtocol", "host", "pathname", "name", "bufferViewIndex", "bufferView", "bufferViews", "buffer", "buffers", "url", "fetch", "uri", "bufferUri", "response", "arrayBuffer", "byteOffset", "byteLength", "dataView", "DataView", "left", "getUint32", "right", "Tile3DSubtreeLoader", "id", "name", "module", "version", "VERSION", "extensions", "mimeTypes", "tests", "parse", "parse3DTilesSubtree", "options", "QUADTREE_DEVISION_COUNT", "OCTREE_DEVISION_COUNT", "SUBDIVISION_COUNT_MAP", "QUADTREE", "OCTREE", "parseImplicitTiles", "params", "options", "parentData", "mortonIndex", "x", "y", "z", "childIndex", "globalData", "level", "subtree", "subdivisionScheme", "subtreeLevels", "maximumLevel", "contentUrlTemplate", "subtreesUriTemplate", "basePath", "tile", "children", "lodMetricValue", "contentUrl", "childrenPerTile", "childX", "childY", "childZ", "levelOffset", "childTileMortonIndex", "concatBits", "tileAvailabilityIndex", "childTileX", "childTileY", "childTileZ", "isChildSubtreeAvailable", "getAvailabilityResult", "childSubtreeAvailability", "lev", "subtreePath", "childSubtreeUrl", "replaceContentUrlTemplate", "childSubtree", "load", "Tile3DSubtreeLoader", "isTileAvailable", "tileAvailability", "isContentAvailable", "contentAvailability", "childTileLevel", "pData", "index", "currentTile", "length", "globalLevel", "childCoordinates", "formattedTile", "formatTileData", "push", "availabilityData", "Boolean", "constant", "explicitBitstream", "getBooleanValueFromBitstream", "refine", "getRefine", "lodMetricType", "getTileType", "rootLodMetricValue", "rootBoundingVolume", "uri", "replace", "boundingVolume", "calculateBoundingVolumeForChildTile", "content", "id", "type", "geometricError", "transform", "region", "west", "south", "east", "north", "minimumHeight", "maximumHeight", "boundingVolumesCount", "sizeX", "sizeY", "sizeZ", "childWest", "childEast", "childSouth", "childNorth", "childMinimumHeight", "childMaximumHeight", "console", "warn", "first", "second", "parseInt", "toString", "templateUrl", "mapUrl", "generateMapUrl", "matched", "items", "key", "availabilityIndex", "availabilityBuffer", "byteIndex", "Math", "floor", "bitIndex", "bitValue", "getTileType", "tile", "contentUrl", "TILE_TYPE", "EMPTY", "fileExtension", "split", "pop", "POINTCLOUD", "SCENEGRAPH", "getRefine", "refine", "TILE_REFINEMENT", "REPLACE", "ADD", "resolveUri", "uri", "basePath", "urlSchemeRegex", "test", "url", "URL", "decodeURI", "toString", "startsWith", "normalizeTileData", "options", "content", "contentUri", "id", "lodMetricType", "LOD_METRIC_TYPE", "GEOMETRIC_ERROR", "lodMetricValue", "geometricError", "transformMatrix", "transform", "type", "normalizeTileHeaders", "tileset", "root", "rootImplicitTilingExtension", "getImplicitTilingExtensionData", "normalizeImplicitTileHeaders", "stack", "push", "length", "children", "childHeader", "childImplicitTilingExtension", "implicitTilingExtension", "subdivisionScheme", "maximumLevel", "subtreeLevels", "subtrees", "subtreesUriTemplate", "replacedUrlTemplate", "replaceContentUrlTemplate", "subtreeUrl", "subtree", "load", "Tile3DSubtreeLoader", "contentUrlTemplate", "rootLodMetricValue", "rootBoundingVolume", "boundingVolume", "implicitOptions", "normalizeImplicitTileData", "rootSubtree", "parseImplicitTiles", "replace", "extensions", "implicitTiling", "Tiles3DLoader", "id", "name", "module", "version", "VERSION", "extensions", "mimeTypes", "tests", "parse", "options", "loadGLTF", "decodeQuantizedPositions", "isTileset", "assetGltfUpAxis", "getBaseUri", "tileset", "path", "dirname", "url", "parseTile", "arrayBuffer", "context", "tile", "content", "featureIds", "byteOffset", "parse3DTile", "parseTileset", "data", "tilesetJson", "JSON", "TextDecoder", "decode", "loader", "basePath", "root", "normalizeTileHeaders", "type", "TILESET_TYPE", "TILES3D", "lodMetricType", "LOD_METRIC_TYPE", "GEOMETRIC_ERROR", "lodMetricValue", "loaderOptions", "indexOf", "CESIUM_ION_URL", "getIonTilesetMetadata", "accessToken", "assetId", "assets", "getIonAssets", "item", "items", "type", "id", "ionAssetMetadata", "getIonAssetMetadata", "url", "assert", "headers", "Authorization", "response", "fetchFile", "fetch", "ok", "Error", "statusText", "json", "metadata", "tilesetInfo", "preload", "url", "options", "accessToken", "assetId", "Number", "isFinite", "matched", "match", "getIonTilesetMetadata", "CesiumIonLoader", "Tiles3DLoader", "id", "name", "parse", "data", "context", "loader", "encode3DTileHeader", "tile", "dataView", "byteOffset", "HEADER_SIZE", "magic", "version", "byteLength", "assert", "Array", "isArray", "Number", "isFinite", "setUint8", "setUint32", "encode3DTileByteLength", "byteOffsetTileStart", "encodeComposite3DTile", "tile", "dataView", "byteOffset", "options", "encode3DTile", "magic", "MAGIC_ARRAY", "COMPOSITE", "tiles", "byteOffsetStart", "encode3DTileHeader", "setUint32", "length", "i", "encode3DTileByteLength", "encodeBatchedModel3DTile", "tile", "dataView", "byteOffset", "options", "featuresLength", "batchTable", "featureTableJson", "BATCH_LENGTH", "featureTableJsonString", "JSON", "stringify", "batchTableJsonString", "featureTableJsonByteLength", "padToNBytes", "length", "batchTableJsonByteLength", "magic", "MAGIC_ARRAY", "BATCHED_MODEL", "byteOffsetStart", "encode3DTileHeader", "setUint32", "copyPaddedStringToDataView", "gltfEncoded", "copyBinaryToDataView", "byteLength", "encode3DTileByteLength", "encodeInstancedModel3DTile", "tile", "dataView", "byteOffset", "options", "featuresLength", "gltfFormat", "gltfUri", "gltfUriByteLength", "length", "featureTableJson", "INSTANCES_LENGTH", "POSITION", "Array", "fill", "featureTableJsonString", "JSON", "stringify", "featureTableJsonByteLength", "magic", "MAGIC_ARRAY", "INSTANCED_MODEL", "byteOffsetStart", "encode3DTileHeader", "setUint32", "copyStringToDataView", "encode3DTileByteLength", "DEFAULT_FEATURE_TABLE_JSON", "POINTS_LENGTH", "POSITIONS", "byteOffset", "encodePointCloud3DTile", "tile", "dataView", "options", "featureTableJson", "featureTableJsonString", "JSON", "stringify", "padStringToByteAlignment", "featureTableJsonByteLength", "length", "featureTableBinary", "ArrayBuffer", "featureTableBinaryByteLength", "byteLength", "magic", "MAGIC_ARRAY", "POINT_CLOUD", "byteOffsetStart", "encode3DTileHeader", "setUint32", "copyStringToDataView", "copyBinaryToDataView", "encode3DTileByteLength", "tile", "options", "byteLength", "encode3DTileToDataView", "arrayBuffer", "ArrayBuffer", "dataView", "DataView", "byteOffset", "assert", "type", "TILE3D_TYPE", "COMPOSITE", "encodeComposite3DTile", "POINT_CLOUD", "encodePointCloud3DTile", "BATCHED_3D_MODEL", "encodeBatchedModel3DTile", "INSTANCED_3D_MODEL", "encodeInstancedModel3DTile", "Error", "Tile3DWriter", "name", "id", "module", "version", "VERSION", "extensions", "mimeTypes", "encodeSync", "binary", "options", "tile", "encode3DTile"]
}
